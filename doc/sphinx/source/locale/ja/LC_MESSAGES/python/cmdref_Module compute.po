# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2004-2017 GetFEM++ project
# This file is distributed under the same license as the GetFEM++ package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: GetFEM++ 5.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-22 15:02+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

# 8604d02a14e4406c8a9d18fe6866a66e
#: ../source/python/cmdref_Module compute.rst:8
msgid "Module compute"
msgstr ""

# 927df32875e743f8ada0a0c106fbf411
#: getfem.compute_L2_norm:1 of
msgid "Compute the L2 norm of the (real or complex) field `U`."
msgstr ""

# 7e4fe279edff43b8ba25ee157df77212
# 715b5f87c07d4832b9f9c01bfc38628e
# 59ea2dca77d94b39bd809371916fa3f7
# b396095db3c94deca60ad6d5332cf426
# 0b455d62d817458fbba0c445266c30bc
# 454e59d71d854217a032940f9986a704
# 63d7d91eaf314930b1f1c853ee9496e5
#: getfem.compute_H1_norm:3 getfem.compute_H1_semi_dist:3
#: getfem.compute_H1_semi_norm:3 getfem.compute_H2_norm:3
#: getfem.compute_H2_semi_norm:3 getfem.compute_L2_dist:3
#: getfem.compute_L2_norm:3 of
msgid ""
"If `CVids` is given, the norm will be computed only on the listed "
"elements."
msgstr ""

# f448bd0fb9734e98953e858be750ae12
#: getfem.compute_L2_dist:1 of
msgid "Compute the L2 distance between `U` and `U2`."
msgstr ""

# 683d341c123c4356ab5678ed68cf8c0f
#: getfem.compute_H1_semi_norm:1 of
msgid "Compute the L2 norm of grad(`U`)."
msgstr ""

# 0ab789d8303d45cf8f0e56d0c10e4c77
#: getfem.compute_H1_semi_dist:1 of
msgid "Compute the semi H1 distance between `U` and `U2`."
msgstr ""

# 30e43d20cad040fcbdc41f05a63efa14
#: getfem.compute_H1_norm:1 of
msgid "Compute the H1 norm of `U`."
msgstr ""

# 2b3d6a3056e04c06a706cc314b056b4a
#: getfem.compute_H2_semi_norm:1 of
msgid "Compute the L2 norm of D^2(`U`)."
msgstr ""

# 8e65d7e3318646058a8d9882f1f42d9d
#: getfem.compute_H2_norm:1 of
msgid "Compute the H2 norm of `U`."
msgstr ""

# 2c9f4c59c2ad45cfa3e88cb0e78c0192
#: getfem.compute_gradient:1 of
msgid "Compute the gradient of the field `U` defined on MeshFem `mf_du`."
msgstr ""

# 1efabb2013054d0c867e93a26705eb29
#: getfem.compute_gradient:3 of
msgid ""
"The gradient is interpolated on the MeshFem `mf_du`, and returned in "
"`DU`. For example, if `U` is defined on a P2 MeshFem, `DU` should be "
"evaluated on a P1-discontinuous MeshFem. `mf` and `mf_du` should share "
"the same mesh."
msgstr ""

# 4a2e26c376224019bd4760351f58c582
#: getfem.compute_gradient:8 of
msgid ""
"`U` may have any number of dimensions (i.e. this function is not "
"restricted to the gradient of scalar fields, but may also be used for "
"tensor fields). However the last dimension of `U` has to be equal to the "
"number of dof of `mf`. For example, if `U` is a [3x3xNmf] array (where "
"Nmf is the number of dof of `mf`), `DU` will be a [Nx3x3[xQ]xNmf_du] "
"array, where N is the dimension of the mesh, Nmf_du is the number of dof "
"of `mf_du`, and the optional Q dimension is inserted if `Qdim_mf != "
"Qdim_mf_du`, where Qdim_mf is the Qdim of `mf` and Qdim_mf_du is the Qdim"
" of `mf_du`."
msgstr ""

# 84aebd1b5cc2456fb95e3e4e7c65ecde
#: getfem.compute_hessian:1 of
msgid "Compute the hessian of the field `U` defined on MeshFem `mf_h`."
msgstr ""

# 148fe4e237284d42a18940df8fca0a44
#: getfem.compute_hessian:3 of
msgid "See also gf_compute('gradient', MeshFem mf_du)."
msgstr ""

# efaa1016f4db4a72b647eaba316ba9aa
#: getfem.compute_eval_on_triangulated_surface:1 of
msgid ""
"[OBSOLETE FUNCTION! will be removed in a future release] Utility function"
" designed for 2D triangular meshes : returns a list of triangles "
"coordinates with interpolated U values. This can be used for the accurate"
" visualization of data defined on a discontinous high order element. On "
"output, the six first rows of UP contains the triangle coordinates, and "
"the others rows contain the interpolated values of U (one for each "
"triangle vertex) CVLIST may indicate the list of convex number that "
"should be consider, if not used then all the mesh convexes will be used. "
"U should be a row vector."
msgstr ""

# fa39dfbceed1444cb5571a6b60fc31fc
#: getfem.compute_interpolate_on:1 of
msgid ""
"Synopsis: Ui = compute_interpolate_on(MeshFem MF, vec U, {MeshFem mfi | "
"Slice sli | vec pts})"
msgstr ""

# 1b86072bb3f34a0789d496f1034db28b
#: getfem.compute_interpolate_on:3 of
msgid "Interpolate a field on another MeshFem or a Slice or a list of points."
msgstr ""

# 1852a67622f34aacb1cd2e7b9376c657
#: getfem.compute_interpolate_on:6 of
msgid "Interpolation on another MeshFem `mfi`:"
msgstr ""

# 6bbc1d180ea84844bec330f38c792cb0
#: getfem.compute_interpolate_on:6 of
msgid ""
"`mfi` has to be Lagrangian. If `mf` and `mfi` share the same mesh object,"
" the interpolation will be much faster."
msgstr ""

# 83ed91521c9246b09c595f264b523a23
#: getfem.compute_interpolate_on:11 of
msgid "Interpolation on a Slice `sli`:"
msgstr ""

# a221e1c6ab774d98b82df1a3600b2ee2
#: getfem.compute_interpolate_on:9 of
msgid ""
"this is similar to interpolation on a refined P1-discontinuous mesh, but "
"it is much faster. This can also be used with Slice('points') to obtain "
"field values at a given set of points."
msgstr ""

# 87b6093aa5b442adb8396a412b4977c8
#: getfem.compute_interpolate_on:13 of
msgid "Interpolation on a set of points `pts`"
msgstr ""

# 7e645f2e12b34de78f19f7976c38cea1
#: getfem.compute_interpolate_on:15 of
msgid "See also gf_asm('interpolation matrix')"
msgstr ""

# 70509abc0ced432e9888b3b33f466da6
#: getfem.compute_extrapolate_on:1 of
msgid "Extrapolate a field on another MeshFem."
msgstr ""

# 5f91bb2d21a64a9d929038e41c0b1d0e
#: getfem.compute_extrapolate_on:3 of
msgid ""
"If the mesh of `mfe` is stricly included in the mesh of `mf`, this "
"function does stricly the same job as gf_compute('interpolate_on'). "
"However, if the mesh of `mfe` is not exactly included in `mf` (imagine "
"interpolation between a curved refined mesh and a coarse mesh), then "
"values which are outside `mf` will be extrapolated."
msgstr ""

# 1b23384cabb24ad6882c528ecdbba97f
#: getfem.compute_extrapolate_on:10 of
msgid "See also gf_asm('extrapolation matrix')"
msgstr ""

# 26d2e0cde4474ee499d7c3995a8e8f3c
#: getfem.compute_error_estimate:1 of
msgid "Compute an a posteriori error estimate."
msgstr ""

# 97621e73d5d14f978ef075b6b941d5c9
# d1f551d21a014514a6fb289f0ea4dcf4
#: getfem.compute_error_estimate:3 getfem.compute_error_estimate_nitsche:3 of
msgid ""
"Currently there is only one which is available: for each convex, the jump"
" of the normal derivative is integrated on its faces."
msgstr ""

# ebfd0691852e4bd29f69383fd2b6aa66
#: getfem.compute_error_estimate_nitsche:1 of
msgid "Compute an a posteriori error estimate in the case of Nitsche method."
msgstr ""

# 7373c640342a4cf1b6e97ec7c9e0849c
#: getfem.compute_convect:1 of
msgid ""
"Synopsis: compute_convect(MeshFem MF, vec U, MeshFem mf_v, vec V, scalar "
"dt, int nt[, string option[, vec per_min, vec per_max]])"
msgstr ""

# 96ffd9cbd19e4232b4a59515c337b5eb
#: getfem.compute_convect:3 of
msgid ""
"Compute a convection of `U` with regards to a steady state velocity field"
" `V` with a Characteristic-Galerkin method. The result is returned in-"
"place in `U`. This method is restricted to pure Lagrange fems for U. "
"`mf_v` should represent a continuous finite element method. `dt` is the "
"integration time and `nt` is the number of integration step on the "
"caracteristics. `option` is an option for the part of the boundary where "
"there is a re-entrant convection. `option = 'extrapolation'` for an "
"extrapolation on the nearest element, `option = 'unchanged'` for a "
"constant value on that boundary or `option = 'periodicity'` for a "
"peridiodic boundary. For this latter option the two vectors per_min, "
"per_max has to be given and represent the limits of the periodic domain "
"(on components where per_max[k] < per_min[k] no operation is done). This "
"method is rather dissipative, but stable."
msgstr ""

