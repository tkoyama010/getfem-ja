# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2004-2017 GetFEM++ project
# This file is distributed under the same license as the GetFEM++ package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: GetFEM++ 5.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-07-07 10:04+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

# 8319ad83c3b046d0a7cab3aea554d325
#: ../source/python/cmdref_Model.rst:8
msgid "Model"
msgstr ""

# 25b7f75167dd4f6a83bd641db5a861b6
#: getfem.Model:1 of
msgid "GeFEM Model object"
msgstr ""

# a8e936289f7d4bf2bac985ca42caaee6
#: getfem.Model:3 of
msgid ""
"Model variables store the variables and the state data and the "
"description of a model. This includes the global tangent matrix, the "
"right hand side and the constraints. There are two kinds of models, the "
"`real` and the `complex` models."
msgstr ""

# 3d1274b46d8e40a5b073237eb5ac5e46
#: getfem.Model:9 of
msgid "General constructor for Model objects"
msgstr ""

# f3d7615915e9430699ac6f71c98de1e5
#: getfem.Model:11 of
msgid "``MD = Model('real')`` Build a model for real unknowns."
msgstr ""

# 194f07e288804fbe972bbe52c8620d55
#: getfem.Model:14 of
msgid "``MD = Model('complex')`` Build a model for complex unknowns."
msgstr ""

# 4c071900326e4dbca3316685df6aaab0
#: getfem.Model.Neumann_term:1 of
msgid ""
"Gives the assembly string corresponding to the Neumann term of the fem "
"variable `varname` on `region`. It is deduced from the assembly string "
"declared by the model bricks. `region` should be the index of a boundary "
"region on the mesh where `varname` is defined. Care to call this function"
" only after all the volumic bricks have been declared. Complains, if a "
"brick omit to declare an assembly string."
msgstr ""

# 426d94544c7940ed8dedb0e2755c9a06
#: getfem.Model.add_Dirichlet_condition_with_Nitsche_method:1 of
msgid ""
"Synopsis: ind = Model.add_Dirichlet_condition_with_Nitsche_method(self, "
"MeshIm mim, string varname, string Neumannterm, string datagamma0, int "
"region[, scalar theta][, string dataname])"
msgstr ""

# bf6dea14173046fbb7d3e90b329ebeb8
#: getfem.Model.add_Dirichlet_condition_with_Nitsche_method:3 of
msgid ""
"Add a Dirichlet condition on the variable `varname` and the mesh region "
"`region`. This region should be a boundary. `Neumannterm` is the "
"expression of the Neumann term (obtained by the Green formula) described "
"as an expression of the high-level generic assembly language. This term "
"can be obtained by  Model.Neumann_term(varname, region) once all volumic "
"bricks have been added to the model. The Dirichlet condition is "
"prescribed with Nitsche's method. `datag` is the optional right hand side"
" of the Dirichlet condition. `datagamma0` is the Nitsche's method "
"parameter. `theta` is a scalar value which can be positive or negative. "
"`theta = 1` corresponds to the standard symmetric method which is "
"conditionnaly coercive for  `gamma0` small. `theta = -1` corresponds to "
"the skew-symmetric method which is inconditionnaly coercive. `theta = 0` "
"(default) is the simplest method for which the second derivative of the "
"Neumann term is not necessary even for nonlinear problems. Return the "
"brick index in the model."
msgstr ""

# 1c996d8e0d7b45748614261881dff644
#: getfem.Model.add_Dirichlet_condition_with_multipliers:1 of
msgid ""
"Add a Dirichlet condition on the variable `varname` and the mesh region "
"`region`. This region should be a boundary. The Dirichlet condition is "
"prescribed with a multiplier variable described by `mult_description`. If"
" `mult_description` is a string this is assumed to be the variable name "
"corresponding to the multiplier (which should be first declared as a "
"multiplier variable on the mesh region in the model). If it is a finite "
"element method (mesh_fem object) then a multiplier variable will be added"
" to the model and build on this finite element method (it will be "
"restricted to the mesh region `region` and eventually some conflicting "
"dofs with some other multiplier variables will be suppressed). If it is "
"an integer, then a  multiplier variable will be added to the model and "
"build on a classical finite element of degree that integer. `dataname` is"
" the optional right hand side of  the Dirichlet condition. It could be "
"constant or described on a fem; scalar or vector valued, depending on the"
" variable on which the Dirichlet condition is prescribed. Return the "
"brick index in the model."
msgstr ""

# f4587398a2e84abeb1f24b39cf1219ff
#: getfem.Model.add_Dirichlet_condition_with_penalization:1 of
msgid ""
"Add a Dirichlet condition on the variable `varname` and the mesh region "
"`region`. This region should be a boundary. The Dirichlet condition is "
"prescribed with penalization. The penalization coefficient is initially "
"`coeff` and will be added to the data of the model. `dataname` is the "
"optional right hand side of the Dirichlet condition. It could be constant"
" or described on a fem; scalar or vector valued, depending on the "
"variable on which the Dirichlet condition is prescribed. `mf_mult` is an "
"optional parameter which allows to weaken the Dirichlet condition "
"specifying a multiplier space. Return the brick index in the model."
msgstr ""

# 9a2940abb9a24a508bff5089d5f27feb
#: getfem.Model.add_Dirichlet_condition_with_simplification:1 of
msgid ""
"Adds a (simple) Dirichlet condition on the variable `varname` and the "
"mesh region `region`. The Dirichlet condition is prescribed by a simple "
"post-treatment of the final linear system (tangent system for nonlinear "
"problems) consisting of modifying the lines corresponding to the degree "
"of freedom of the variable on `region` (0 outside the diagonal, 1 on the "
"diagonal of the matrix and the expected value on the right hand side). "
"The symmetry of the linear system is kept if all other bricks are "
"symmetric. This brick is to be reserved for simple Dirichlet conditions "
"(only dof declared on the correspodning boundary are prescribed). The "
"application of this brick on reduced dof may be problematic. Intrinsic "
"vectorial finite element method are not supported.  `dataname` is the "
"optional right hand side of  the Dirichlet condition. It could be "
"constant (but in that case, it can only be applied to Lagrange f.e.m.) or"
" (important) described on the same finite element method as `varname`. "
"Returns the brick index in the model."
msgstr ""

# 994aeb1ec8c9411eac31be7cac2438f3
#: getfem.Model.add_Fourier_Robin_brick:1 of
msgid ""
"Add a Fourier-Robin term to the model relatively to the variable "
"`varname`. This corresponds to a weak term of the form :math:`\\int "
"(qu).v`. `dataexpr` is the parameter :math:`q` of the Fourier-Robin "
"condition.  It can be an arbitrary valid expression of the high-level "
"generic assembly language (except for the complex version for which it "
"should be a data of the model). `region` is the mesh region on which the "
"term is added. Return the brick index in the model."
msgstr ""

# 7ee1286f4ee949e49c0955b11564e87c
#: getfem.Model.add_Helmholtz_brick:1 of
msgid ""
"Add a Helmholtz term to the model relatively to the variable `varname`. "
"`dataexpr` is the wave number. `region` is an optional mesh region on "
"which the term is added. If it is not specified, it is added on the whole"
" mesh. Return the brick index in the model."
msgstr ""

# 733946114ce64f56b280432b5d8a95a0
#: getfem.Model.add_Kirchhoff_Love_Neumann_term_brick:1 of
msgid ""
"Add a Neumann term brick for Kirchhoff-Love model on the variable "
"`varname` and the mesh region `region`. `dataname_M` represents the "
"bending moment tensor and  `dataname_divM` its divergence. Return the "
"brick index in the model."
msgstr ""

# 5ea44c7ffb824a62b425854aec5942ac
#: getfem.Model.add_Kirchhoff_Love_plate_brick:1 of
msgid ""
"Add a bilaplacian brick on the variable `varname` and on the mesh region "
"`region`. This represent a term :math:`\\Delta(D \\Delta u)` where "
":math:`D(x)` is a the flexion modulus determined by `dataname_D`. The "
"term is integrated by part following a Kirchhoff-Love plate model with "
"`dataname_nu` the poisson ratio. Return the brick index in the model."
msgstr ""

# c27508bf2f7a41cb88d9374aab1b505e
#: getfem.Model.add_Laplacian_brick:1 of
msgid ""
"Add a Laplacian term to the model relatively to the variable `varname` "
"(in fact with a minus : :math:`-\\text{div}(\\nabla u)`). If this is a "
"vector valued variable, the Laplacian term is added componentwise. "
"`region` is an optional mesh region on which the term is added. If it is "
"not specified, it is added on the whole mesh. Return the brick index in "
"the model."
msgstr ""

# a1063cc08ef447c8b7769f6344f3198d
#: getfem.Model.add_Mindlin_Reissner_plate_brick:1 of
msgid ""
"Synopsis: ind = Model.add_Mindlin_Reissner_plate_brick(self, MeshIm mim, "
"MeshIm mim_reduced, string varname_u3, string varname_theta , string "
"param_E, string param_nu, string param_epsilon, string param_kappa [,int "
"variant [, int region]])"
msgstr ""

# 009f27832bd149f8a11c9da13479dc58
#: getfem.Model.add_Mindlin_Reissner_plate_brick:3 of
msgid ""
"Add a term corresponding to the classical Reissner-Mindlin plate model "
"for which `varname_u3` is the transverse displacement, `varname_theta` "
"the rotation of fibers normal to the midplane, 'param_E' the Young "
"Modulus, `param_nu` the poisson ratio, `param_epsilon` the plate "
"thickness, `param_kappa` the shear correction factor. Note that since "
"this brick uses the high level generic assembly language, the parameter "
"can be regular expression of this language. There are three variants. "
"`variant = 0` corresponds to the an unreduced formulation and in that "
"case only the integration method `mim` is used. Practically this variant "
"is not usable since it is subject to a strong locking phenomenon. "
"`variant = 1` corresponds to a reduced integration where `mim` is used "
"for the rotation term and `mim_reduced` for the transverse shear term. "
"`variant = 2` (default) corresponds to the projection onto a rotated RT0 "
"element of the transverse shear term. For the moment, this is adapted to "
"quadrilateral only (because it is not sufficient to remove the locking "
"phenomenon on triangle elements). Note also that if you use high order "
"elements, the projection on RT0 will reduce the order of the "
"approximation. Returns the brick index in the model."
msgstr ""

# 656bb573bf2147b2b69729424fb10a63
# 853893faf1c14b2b8483f1c1d25c68d0
#: getfem.Model.add_Newmark_scheme:1
#: getfem.Model.add_theta_method_for_second_order:1 of
msgid ""
"Attach a theta method for the time discretization of the variable "
"`varname`. Valid only if there is at most second order time derivative of"
" the variable."
msgstr ""

# 8040a0fa43044666a7a29d1cbd7ff080
#: getfem.Model.add_Nitsche_contact_with_rigid_obstacle_brick:1 of
msgid ""
"Synopsis: ind = Model.add_Nitsche_contact_with_rigid_obstacle_brick(self,"
" MeshIm mim, string varname, string Neumannterm, string "
"dataname_obstacle, string gamma0name,  int region[, scalar theta[, string"
" dataname_friction_coeff[, string dataname_alpha, string dataname_wt]]])"
msgstr ""

# 365ddb1206aa46cf9518072db77bb90f
#: getfem.Model.add_Nitsche_contact_with_rigid_obstacle_brick:3 of
msgid ""
"Adds a contact condition with or without Coulomb friction on the variable"
" `varname` and the mesh boundary `region`. The contact condition is "
"prescribed with Nitsche's method. The rigid obstacle should be described "
"with the data `dataname_obstacle` being a signed distance to the obstacle"
" (interpolated on a finite element method). `gamma0name` is the Nitsche's"
" method parameter. `theta` is a scalar value which can be positive or "
"negative. `theta = 1` corresponds to the standard symmetric method which "
"is conditionnaly coercive for  `gamma0` small. `theta = -1` corresponds "
"to the skew-symmetric method which is inconditionnaly coercive. `theta = "
"0` is the simplest method for which the second derivative of the Neumann "
"term is not necessary. The optional parameter `dataname_friction_coeff` "
"is the friction coefficient which could be constant or defined on a "
"finite element method. CAUTION: This brick has to be added in the model "
"after all the bricks corresponding to partial differential terms having a"
" Neumann term. Moreover, This brick can only be applied to bricks "
"declaring their Neumann terms. Returns the brick index in the model."
msgstr ""

# c35ce214ff7e41588688ec754fe43c59
#: getfem.Model.add_Nitsche_fictitious_domain_contact_brick:1 of
msgid ""
"Synopsis: ind = Model.add_Nitsche_fictitious_domain_contact_brick(self, "
"MeshIm mim, string varname1, string varname2, string dataname_d1, string "
"dataname_d2, string gamma0name [, scalar theta[, string "
"dataname_friction_coeff[, string dataname_alpha, string "
"dataname_wt1,string dataname_wt2]]])"
msgstr ""

# c4222a8c9bc44f3db44b9adca4c25359
#: getfem.Model.add_Nitsche_fictitious_domain_contact_brick:3 of
msgid ""
"Adds a contact condition with or without Coulomb friction between two "
"bodies in a fictitious domain. The contact condition is applied on  the "
"variable `varname_u1` corresponds with the first and slave body  with "
"Nitsche's method and on the variable `varname_u2` corresponds  with the "
"second and master body with Nitsche's method.  The contact condition is "
"evaluated on the fictitious slave boundary. The first body should be "
"described by the level-set `dataname_d1`  and the second body should be "
"described by the level-set `dataname_d2`. `gamma0name` is the Nitsche's "
"method parameter.  `theta` is a scalar value which can be positive or "
"negative.  `theta = 1` corresponds to the standard symmetric method which"
" is conditionnaly coercive for  `gamma0` small. `theta = -1` corresponds "
"to the skew-symmetric method which is inconditionnaly coercive. `theta = "
"0` is the simplest method for which the second derivative of the Neumann "
"term is not necessary. The optional parameter `dataname_friction_coeff` "
"is the friction coefficient which could be constant or defined on a "
"finite element method.  CAUTION: This brick has to be added in the model "
"after all the bricks corresponding to partial differential terms having a"
" Neumann term. Moreover, This brick can only be applied to bricks "
"declaring their Neumann terms. Returns the brick index in the model."
msgstr ""

# 6d7c58d3f0244b8d81312d021a2f3e52
#: getfem.Model.add_Nitsche_large_sliding_contact_brick_raytracing:1 of
msgid ""
"Synopsis: ind = "
"Model.add_Nitsche_large_sliding_contact_brick_raytracing(self, bool "
"unbiased_version, string dataname_r, scalar release_distance[, string "
"dataname_fr[, string dataname_alpha[, int version]]])"
msgstr ""

# 05069d6823324d90a970d43bb774b346
#: getfem.Model.add_Nitsche_large_sliding_contact_brick_raytracing:3 of
msgid ""
"Adds a large sliding contact with friction brick to the model based on "
"the Nitsche's method. This brick is able to deal with self-contact, "
"contact between several deformable bodies and contact with rigid "
"obstacles. It uses the high-level generic assembly. It adds to the model "
"a raytracing_interpolate_transformation object. \"unbiased_version\" "
"refers to the version of Nische's method to be used. (unbiased or biased "
"one). For each slave boundary a  material law should be defined as a "
"function of the dispacement variable on this boundary. The release "
"distance should be determined with care (generally a few times a mean "
"element size, and less than the thickness of the body). Initially, the "
"brick is added with no contact boundaries. The contact boundaries and "
"rigid bodies are added with special functions. `version` is 0 (the "
"default value) for the non-symmetric version and 1 for the more symmetric"
" one (not fully symmetric even without friction)."
msgstr ""

# 731c57b1903947f59171a1a30363a190
#: getfem.Model.add_Nitsche_midpoint_contact_with_rigid_obstacle_brick:1 of
msgid ""
"EXPERIMENTAL BRICK: for midpoint scheme only !! Adds a contact condition "
"with or without Coulomb friction on the variable `varname` and the mesh "
"boundary `region`. The contact condition is prescribed with Nitsche's "
"method. The rigid obstacle should be described with the data "
"`dataname_obstacle` being a signed distance to the obstacle (interpolated"
" on a finite element method). `gamma0name` is the Nitsche's method "
"parameter. `theta` is a scalar value which can be positive or negative. "
"`theta = 1` corresponds to the standard symmetric method which is "
"conditionnaly coercive for  `gamma0` small. `theta = -1` corresponds to "
"the skew-symmetric method which is inconditionnaly coercive. `theta = 0` "
"is the simplest method for which the second derivative of the Neumann "
"term is not necessary. The optional parameter `dataname_friction_coeff` "
"is the friction coefficient which could be constant or defined on a "
"finite element method. Returns the brick index in the model."
msgstr ""

# 0ed2b429d0324b2788ca3395be68f294
#: getfem.Model.add_assembly_assignment:1 of
msgid ""
"Synopsis: Model.add_assembly_assignment(self, string dataname, string "
"expression[, int region[, int order[, int before]]])"
msgstr ""

# a4da14f3605b48e99620e10488eb1b21
#: getfem.Model.add_assembly_assignment:3 of
msgid ""
"Adds expression `expr` to be evaluated at assembly time and being "
"assigned to the data `dataname` which has to be of im_data type. This "
"allows for instance to store a sub-expression of an assembly computation "
"to be used on an other assembly. It can be used for instance to store the"
" plastic strain in plasticity models. `order` represents the order of "
"assembly where this assignement has to be done (potential(0), weak "
"form(1) or tangent system(2) or at each order(-1)). The default value is "
"1. If before = 1, the the assignement is perfromed before the computation"
" of the other assembly terms, such that the data can be used in the "
"remaining of the assembly as an intermediary result (be careful that it "
"is still considered as a data, no derivation of the expression is "
"performed for the tangent system).      If before = 0 (default), the "
"assignement is done after the assembly terms."
msgstr ""

# ecd487c511e4479685fd236b4308c74a
#: getfem.Model.add_basic_contact_brick:1 of
msgid ""
"Synopsis: ind = Model.add_basic_contact_brick(self, string varname_u, "
"string multname_n[, string multname_t], string dataname_r, Spmat BN[, "
"Spmat BT, string dataname_friction_coeff][, string dataname_gap[, string "
"dataname_alpha[, int augmented_version[, string dataname_gamma, string "
"dataname_wt]]])"
msgstr ""

# b127e10b51344e20a2683f9ad7a0bdfe
#: getfem.Model.add_basic_contact_brick:3 of
msgid ""
"Add a contact with or without friction brick to the model. If U is the "
"vector of degrees of freedom on which the unilateral constraint is "
"applied, the matrix `BN` have to be such that this constraint is defined "
"by :math:`B_N U \\le 0`. A friction condition can be considered by adding"
" the three parameters `multname_t`, `BT` and `dataname_friction_coeff`. "
"In this case, the tangential displacement is :math:`B_T U` and the matrix"
" `BT` should have as many rows as `BN` multiplied by :math:`d-1` where "
":math:`d` is the domain dimension. In this case also, "
"`dataname_friction_coeff` is a data which represents the coefficient of "
"friction. It can be a scalar or a vector representing a value on each "
"contact condition.  The unilateral constraint is prescribed thank to a "
"multiplier `multname_n` whose dimension should be equal to the number of "
"rows of `BN`. If a friction condition is added, it is prescribed with a "
"multiplier `multname_t` whose dimension should be equal to the number of "
"rows of `BT`. The augmentation parameter `r` should be chosen in a range "
"of acceptabe values (see Getfem user documentation). `dataname_gap` is an"
" optional parameter representing the initial gap. It can be a single "
"value or a vector of value. `dataname_alpha` is an optional "
"homogenization parameter for the augmentation parameter (see Getfem user "
"documentation).  The parameter `augmented_version` indicates the "
"augmentation strategy : 1 for the non-symmetric Alart-Curnier augmented "
"Lagrangian, 2 for the symmetric one (except for the coupling between "
"contact and Coulomb friction), 3 for the unsymmetric method with "
"augmented multipliers, 4 for the unsymmetric method with augmented "
"multipliers and De Saxce projection."
msgstr ""

# 894c455768ae4537913d0d9503434cc0
#: getfem.Model.add_basic_contact_brick_two_deformable_bodies:1 of
msgid ""
"Synopsis: ind = Model.add_basic_contact_brick_two_deformable_bodies(self,"
" string varname_u1, string varname_u2, string multname_n, string "
"dataname_r, Spmat BN1, Spmat BN2[, string dataname_gap[, string "
"dataname_alpha[, int augmented_version]]])"
msgstr ""

# 2c5a211fde4e4ee5b03e66f0c835a75b
#: getfem.Model.add_basic_contact_brick_two_deformable_bodies:18 of
msgid "Add a frictionless contact condition to the model between two deformable"
msgstr ""

# 9171a1345da5485fb69a85c4bcb212ce
#: getfem.Model.add_basic_contact_brick_two_deformable_bodies:4 of
msgid ""
"bodies. If U1, U2 are the vector of degrees of freedom on which the "
"unilateral constraint is applied, the matrices `BN1` and `BN2` have to be"
" such that this condition is defined by $B_{N1} U_1 B_{N2} U_2 + \\le "
"gap$. The constraint is prescribed thank to a multiplier `multname_n` "
"whose dimension should be equal to the number of lines of `BN`. The "
"augmentation parameter `r` should be chosen in a range of acceptabe "
"values (see Getfem user documentation). `dataname_gap` is an optional "
"parameter representing the initial gap. It can be a single value or a "
"vector of value. `dataname_alpha` is an optional homogenization parameter"
" for the augmentation parameter (see Getfem user documentation). The "
"parameter `aug_version` indicates the augmentation strategy : 1 for the "
"non-symmetric Alart-Curnier augmented Lagrangian, 2 for the symmetric "
"one, 3 for the unsymmetric method with augmented multiplier."
msgstr ""

# 12c36516ef0d452e8319efad65464846
#: getfem.Model.add_bilaplacian_brick:1 of
msgid ""
"Add a bilaplacian brick on the variable `varname` and on the mesh region "
"`region`. This represent a term :math:`\\Delta(D \\Delta u)`. where "
":math:`D(x)` is a coefficient determined by `dataname` which could be "
"constant or described on a f.e.m. The corresponding weak form is "
":math:`\\int D(x)\\Delta u(x) \\Delta v(x) dx`. Return the brick index in"
" the model."
msgstr ""

# 6320ecea558848dd9c8754a89d9b6873
#: getfem.Model.add_constraint_with_multipliers:1 of
msgid ""
"Synopsis: ind = Model.add_constraint_with_multipliers(self, string "
"varname, string multname, Spmat B, {vec L | string dataname})"
msgstr ""

# 1f80466a66eb4cb0a501ff4265c8047d
#: getfem.Model.add_constraint_with_multipliers:3 of
msgid ""
"Add an additional explicit constraint on the variable `varname` thank to "
"a multiplier `multname` peviously added to the model (should be a fixed "
"size variable). The constraint is :math:`BU=L` with `B` being a "
"rectangular sparse matrix. It is possible to change the constraint at any"
" time with the methods Model.set_private_matrix() and "
"Model.set_private_rhs(). If `dataname` is specified instead of `L`, the "
"vector `L` is defined in the model as data with the given name. Return "
"the brick index in the model."
msgstr ""

# 4870498677ad4a53b7b5b9ff96287598
#: getfem.Model.add_constraint_with_penalization:1 of
msgid ""
"Synopsis: ind = Model.add_constraint_with_penalization(self, string "
"varname, scalar coeff, Spmat B, {vec L | string dataname})"
msgstr ""

# 39d203da312e496b9ba37e28744eb122
#: getfem.Model.add_constraint_with_penalization:3 of
msgid ""
"Add an additional explicit penalized constraint on the variable "
"`varname`. The constraint is :math`BU=L` with `B` being a rectangular "
"sparse matrix. Be aware that `B` should not contain a palin row, "
"otherwise the whole tangent matrix will be plain. It is possible to "
"change the constraint at any time with the methods "
"Model.set_private_matrix() and Model.set_private_rhs(). The method "
"Model.change_penalization_coeff() can be used. If `dataname` is specified"
" instead of `L`, the vector `L` is defined in the model as data with the "
"given name. Return the brick index in the model."
msgstr ""

# 5d7389601c454f51b8775e3de901c910
#: getfem.Model.add_contact_boundary_to_unbiased_Nitsche_large_sliding_contact_brick:1
#: of
msgid ""
"Adds a contact boundary to an existing unbiased Nitschelarge sliding "
"contact with friction brick which is both master and slave."
msgstr ""

# 3822efe60a9d4c3bbbd0554e37c124ad
#: getfem.Model.add_contact_with_rigid_obstacle_brick:1 of
msgid ""
"Synopsis: ind = Model.add_contact_with_rigid_obstacle_brick(self,  MeshIm"
" mim, string varname_u, string multname_n[, string multname_t], string "
"dataname_r[, string dataname_friction_coeff], int region, string "
"obstacle[,  int augmented_version])"
msgstr ""

# 9cc59755c56c4dbea48c53d39ddcd45d
#: getfem.Model.add_contact_with_rigid_obstacle_brick:3 of
msgid ""
"DEPRECATED FUNCTION. Use 'add nodal contact with rigid obstacle brick' "
"instead."
msgstr ""

# 00a42899339c4cda985a9bc8e6755d88
#: getfem.Model.add_data:1 of
msgid ""
"Add a fixed size data to the model.  `sizes` is either a integer (for a "
"scalar or vector data) or a vector of dimensions for a tensor data. "
"`name` is the data name."
msgstr ""

# 9ccaf2d76c2c49ed91bdbac5848418a3
#: getfem.Model.add_elastoplasticity_brick:1 of
msgid ""
"Old (obsolete) brick which do not use the high level generic assembly. "
"Add a nonlinear elastoplastic term to the model relatively to the "
"variable `varname`, in small deformations, for an isotropic material and "
"for a quasistatic model. `projname` is the type of projection that used: "
"only the Von Mises projection is available with 'VM' or 'Von Mises'. "
"`datasigma` is the variable representing the constraints on the material."
" `previous_dep_name` represents the displacement at the previous time "
"step. Moreover, the finite element method on which `varname` is described"
" is an K ordered mesh_fem, the `datasigma` one have to be at least an K-1"
" ordered mesh_fem. `datalambda` and `datamu` are the Lame coefficients of"
" the studied material. `datathreshold` is the plasticity threshold of the"
" material. The three last variables could be constants or described on "
"the same finite element method. `region` is an optional mesh region on "
"which the term is added. If it is not specified, it is added on the whole"
" mesh. Return the brick index in the model."
msgstr ""

# 83ae3603c7b14196814968ac3968a97f
#: getfem.Model.add_element_extrapolation_transformation:1 of
msgid ""
"Add a special interpolation transformation which represents the identity "
"transformation but allows to evaluate the expression on another element "
"than the current element by polynomial extrapolation. It is used for "
"stabilization term in fictitious domain applications. the array elt_cor "
"should be a two entry array whose first line contains the elements "
"concerned by the transformation and the second line the respective "
"elements on which the extrapolation has to be made. If an element is not "
"listed in elt_cor the evaluation is just made on the current element."
msgstr ""

# 9c018f5eeddb474d81f2777dc03c88be
#: getfem.Model.add_elementary_rotated_RT0_projection:1 of
msgid "Experimental method ..."
msgstr ""

# 408c610a894143ecb217dab6be719b61
#: getfem.Model.add_explicit_matrix:1 of
msgid ""
"Synopsis: ind = Model.add_explicit_matrix(self, string varname1, string "
"varname2, Spmat B[, int issymmetric[, int iscoercive]])"
msgstr ""

# 5ed2120e3cdc41a6863b72c4dd4f0dd6
#: getfem.Model.add_explicit_matrix:3 of
msgid ""
"Add a brick representing an explicit matrix to be added to the tangent "
"linear system relatively to the variables `varname1` and `varname2`. The "
"given matrix should have has many rows as the dimension of `varname1` and"
" as many columns as the dimension of `varname2`. If the two variables are"
" different and if `issymmetric` is set to 1 then the transpose of the "
"matrix is also added to the tangent system (default is 0). Set "
"`iscoercive` to 1 if the term does not affect the coercivity of the "
"tangent system (default is 0). The matrix can be changed by the command "
"Model.set_private_matrix(). Return the brick index in the model."
msgstr ""

# a2a8d9a6d407434697f2fcf18911ebe9
#: getfem.Model.add_explicit_rhs:1 of
msgid ""
"Add a brick representing an explicit right hand side to be added to the "
"right hand side of the tangent linear system relatively to the variable "
"`varname`. The given rhs should have the same size than the dimension of "
"`varname`. The rhs can be changed by the command Model.set_private_rhs()."
" If `dataname` is specified instead of `L`, the vector `L` is defined in "
"the model as data with the given name. Return the brick index in the "
"model."
msgstr ""

# cdebfe88bf4f4b3eb016e1d16d2dd6f4
#: getfem.Model.add_fem_data:1 of
msgid ""
"Add a data to the model linked to a MeshFem. `name` is the data name, "
"`sizes` an optional parameter which is either an  integer  or a vector of"
" suplementary dimensions with respect to `mf`."
msgstr ""

# 1e878f205b5649689d912987eb3cd224
#: getfem.Model.add_fem_variable:1 of
msgid ""
"Add a variable to the model linked to a MeshFem. `name` is the variable "
"name."
msgstr ""

# 718e7b6a91424fbb82094f57843d3dd3
#: getfem.Model.add_filtered_fem_variable:1 of
msgid ""
"Add a variable to the model linked to a MeshFem. The variable is filtered"
" in the sense that only the dof on the region are considered. `name` is "
"the variable name."
msgstr ""

# 725f192e46cd434bb67850f7ba79472a
#: getfem.Model.add_finite_strain_elasticity_brick:1 of
msgid ""
"Add a nonlinear elasticity term to the model relatively to the variable "
"`varname`. `lawname` is the constitutive law which could be 'SaintVenant "
"Kirchhoff', 'Mooney Rivlin', 'Neo Hookean', 'Ciarlet Geymonat' or "
"'Generalized Blatz Ko'. 'Mooney Rivlin' and 'Neo Hookean' law names have "
"to be preceeded with the word 'Compressible' or 'Incompressible' to force"
" using the corresponding version. The compressible version of these laws "
"requires one additional material coefficient."
msgstr ""

# 33ac4963fbf74c15af573782dcd13a17
#: getfem.Model.add_finite_strain_elasticity_brick:11 of
msgid ""
"IMPORTANT : if the variable is defined on a 2D mesh, the plane strain "
"approximation is automatically used. `params` is a vector of parameters "
"for the constitutive law. Its length depends on the law. It could be a "
"short vector of constant values or a vector field described on a finite "
"element method for variable coefficients. `region` is an optional mesh "
"region on which the term is added. If it is not specified, it is added on"
" the whole mesh. This brick use the high-level generic assembly. Returns "
"the brick index in the model."
msgstr ""

# cf63adee8b2f4864874e946a604e43be
#: getfem.Model.add_finite_strain_elastoplasticity_brick:1 of
msgid ""
"Synopsis: ind = Model.add_finite_strain_elastoplasticity_brick(self, "
"MeshIm mim , string lawname, string unknowns_type [, string varnames, "
"...] [, string params, ...] [, int region = -1])"
msgstr ""

# 3b1293c94b5342c3a8adfefadf8127b1
#: getfem.Model.add_finite_strain_elastoplasticity_brick:3 of
msgid ""
"Add a finite strain elastoplasticity brick to the model. For the moment "
"there is only one supported law defined through  `lawname` as "
"\"Simo_Miehe\". This law supports to possibilities of unknown variables "
"to solve for defined by means of `unknowns_type` set to either "
"'DISPLACEMENT_AND_PLASTIC_MULTIPLIER' (integer value 1) or "
"'DISPLACEMENT_AND_PLASTIC_MULTIPLIER_AND_PRESSURE' (integer value 3). The"
"  \"Simo_Miehe\" law expects as `varnames` a set of the following names "
"that have to be defined as variables in the model:"
msgstr ""

# 9b7d1527cd054cfaaeee413a307ee5ea
#: getfem.Model.add_finite_strain_elastoplasticity_brick:13 of
msgid "the displacement variable which has to be defined as an unknown,"
msgstr ""

# 33872450ab854b608231300d9a18c1a0
#: getfem.Model.add_finite_strain_elastoplasticity_brick:14 of
msgid "the plastic multiplier which has also defined as an unknown,"
msgstr ""

# 4a10a411d06e43fc9b6fba7969951610
#: getfem.Model.add_finite_strain_elastoplasticity_brick:15 of
msgid ""
"optionally the pressure variable for a mixed displacement-pressure "
"formulation for 'DISPLACEMENT_AND_PLASTIC_MULTIPLIER_AND_PRESSURE' as "
"`unknowns_type`,"
msgstr ""

# 10d7cf4d258f41aab67e5058806a5dfe
#: getfem.Model.add_finite_strain_elastoplasticity_brick:18 of
msgid ""
"the name of a (scalar) fem_data or im_data field that holds the plastic "
"strain at the previous time step, and"
msgstr ""

# 3953e49aef6d45af9c0619703e45c7ee
#: getfem.Model.add_finite_strain_elastoplasticity_brick:20 of
msgid ""
"the name of a fem_data or im_data field that holds all non-repeated "
"components of the inverse of the plastic right Cauchy-Green tensor at the"
" previous time step (it has to be a 4 element vector for plane strain 2D "
"problems and a 6 element vector for 3D problems)."
msgstr ""

# 301bf16fdfd849719ba87483d56393f7
#: getfem.Model.add_finite_strain_elastoplasticity_brick:26 of
msgid ""
"The  \"Simo_Miehe\" law also expects as `params` a set of the following "
"three parameters:"
msgstr ""

# 7a0f15faea664751a682e627f6e415a3
#: getfem.Model.add_finite_strain_elastoplasticity_brick:29 of
msgid "an expression for the initial bulk modulus K,"
msgstr ""

# 1803703460c44597945bca1d6c1b87f4
#: getfem.Model.add_finite_strain_elastoplasticity_brick:30 of
msgid "an expression for the initial shear modulus G,"
msgstr ""

# df1c12c908854186842b5a366043555c
#: getfem.Model.add_finite_strain_elastoplasticity_brick:31 of
msgid ""
"the name of a user predefined function that decribes the yield limit as a"
" function of the hardening variable (both the yield limit and the "
"hardening variable values are assumed to be Frobenius norms of "
"appropriate stress and strain tensors, respectively)."
msgstr ""

# a4becca64305424caf101daa420fcbf7
#: getfem.Model.add_finite_strain_elastoplasticity_brick:37 of
msgid ""
"As usual, `region` is an optional mesh region on which the term is added."
" If it is not specified, it is added on the whole mesh. Return the brick "
"index in the model."
msgstr ""

# 549b8d12b7f0413abd81ca2f7b0134cc
#: getfem.Model.add_finite_strain_incompressibility_brick:1 of
msgid ""
"Add a finite strain incompressibility condition on `variable` (for large "
"strain elasticity). `multname_pressure` is a variable which represent the"
" pressure. Be aware that an inf-sup condition between the finite element "
"method describing the pressure and the primal variable has to be "
"satisfied. `region` is an optional mesh region on which the term is "
"added. If it is not specified, it is added on the whole mesh. Return the "
"brick index in the model. This brick is equivalent to the ``nonlinear "
"incompressibility brick`` but uses the high-level generic assembly adding"
" the term ``p*(1-Det(Id(meshdim)+Grad_u))`` if ``p`` is the multiplier "
"and ``u`` the variable which represent the displacement."
msgstr ""

# c46d1c0c0696494494ebb4b7cfb580b1
#: getfem.Model.add_generalized_Dirichlet_condition_with_Nitsche_method:1 of
msgid ""
"Add a Dirichlet condition on the variable `varname` and the mesh region "
"`region`. This version is for vector field. It prescribes a condition @f$"
" Hu = r @f$ where `H` is a matrix field. CAUTION : the matrix H should "
"have all eigenvalues equal to 1 or 0. The region should be a boundary.   "
"`Neumannterm` is the expression of the Neumann term (obtained by the "
"Green formula) described as an expression of the high-level generic "
"assembly language. This term can be obtained by  "
"Model.Neumann_term(varname, region) once all volumic bricks have been "
"added to the model.  The Dirichlet condition is prescribed with Nitsche's"
" method. `dataname` is the optional right hand side of the Dirichlet "
"condition. It could be constant or described on a fem. `gamma0name` is "
"the Nitsche's method parameter. `theta` is a scalar value which can be "
"positive or negative. `theta = 1` corresponds to the standard symmetric "
"method which is conditionnaly coercive for  `gamma0` small. `theta = -1` "
"corresponds to the skew-symmetric method which is inconditionnaly "
"coercive. `theta = 0` is the simplest method for which the second "
"derivative of the Neumann term is not necessary even for nonlinear "
"problems. `Hname` is the data corresponding to the matrix field `H`. It "
"has to be a constant matrix or described on a scalar fem. Returns the "
"brick index in the model. (This brick is not fully tested)"
msgstr ""

# 48c4d424f833451c86ee69f72958d659
#: getfem.Model.add_generalized_Dirichlet_condition_with_multipliers:1 of
msgid ""
"Add a Dirichlet condition on the variable `varname` and the mesh region "
"`region`.  This version is for vector field. It prescribes a condition "
":math:`Hu = r` where `H` is a matrix field. The region should be a "
"boundary. The Dirichlet condition is prescribed with a multiplier "
"variable described by `mult_description`. If `mult_description` is a "
"string this is assumed to be the variable name corresponding to the "
"multiplier (which should be first declared as a multiplier variable on "
"the mesh region in the model). If it is a finite element method (mesh_fem"
" object) then a multiplier variable will be added to the model and build "
"on this finite element method (it will be restricted to the mesh region "
"`region` and eventually some conflicting dofs with some other multiplier "
"variables will be suppressed). If it is an integer, then a  multiplier "
"variable will be added to the model and build on a classical finite "
"element of degree that integer. `dataname` is the right hand side of  the"
" Dirichlet condition. It could be constant or described on a fem; scalar "
"or vector valued, depending on the variable on which the Dirichlet "
"condition is prescribed. `Hname` is the data corresponding to the matrix "
"field `H`. Returns the brick index in the model."
msgstr ""

# 87a74b8582a541ca8749e1ad7b2e6fb6
#: getfem.Model.add_generalized_Dirichlet_condition_with_penalization:1 of
msgid ""
"Add a Dirichlet condition on the variable `varname` and the mesh region "
"`region`. This version is for vector field. It prescribes a condition "
":math:`Hu = r` where `H` is a matrix field. The region should be a "
"boundary. The Dirichlet condition is prescribed with penalization. The "
"penalization coefficient is intially `coeff` and will be added to the "
"data of the model. `dataname` is the right hand side of the Dirichlet "
"condition. It could be constant or described on a fem; scalar or vector "
"valued, depending on the variable on which the Dirichlet condition is "
"prescribed. `Hname` is the data corresponding to the matrix field `H`. It"
" has to be a constant matrix or described on a scalar fem. `mf_mult` is "
"an optional parameter which allows to weaken the Dirichlet condition "
"specifying a multiplier space. Return the brick index in the model."
msgstr ""

# decd5eb69d0943dd88567a6938e4068b
#: getfem.Model.add_generic_elliptic_brick:1 of
msgid ""
"Add a generic elliptic term to the model relatively to the variable "
"`varname`. The shape of the elliptic term depends both on the variable "
"and the data. This corresponds to a term :math:`-\\text{div}(a\\nabla u)`"
" where :math:`a` is the data and :math:`u` the variable. The data can be "
"a scalar, a matrix or an order four tensor. The variable can be vector "
"valued or not. If the data is a scalar or a matrix and the variable is "
"vector valued then the term is added componentwise. An order four tensor "
"data is allowed for vector valued variable only. The data can be constant"
" or describbed on a fem. Of course, when the data is a tensor describe on"
" a finite element method (a tensor field) the data can be a huge vector. "
"The components of the matrix/tensor have to be stored with the fortran "
"order (columnwise) in the data vector (compatibility with blas). The "
"symmetry of the given matrix/tensor is not verified (but assumed). If "
"this is a vector valued variable, the elliptic term is added "
"componentwise. `region` is an optional mesh region on which the term is "
"added. If it is not specified, it is added on the whole mesh. Note that "
"for the real version which uses the high-level generic assembly language,"
" `dataname` can be any regular expression of the high-level generic "
"assembly language (like \"1\", \"sin(X(1))\" or \"Norm(u)\" for instance)"
" even depending on model variables. Return the brick index in the model."
msgstr ""

# 3b8c61456747432b990f0392b54213c9
#: getfem.Model.add_im_data:1 of
msgid "Add a data set to the model linked to a MeshImd. `name` is the data name."
msgstr ""

# ad283ae1a5944e8696dbb5821bfd6deb
#: getfem.Model.add_initialized_data:1 of
msgid ""
"Add an initialized fixed size data to the model. `sizes` an optional "
"parameter which is either an  integer  or a vector dimensions that "
"describes the format of the data. By default, the data is considered to b"
" a vector field. `name` is the data name and `V` is the value of the "
"data."
msgstr ""

# e78aac8a35ca48948819043347c88bd1
#: getfem.Model.add_initialized_fem_data:1 of
msgid ""
"Add a data to the model linked to a MeshFem. `name` is the data name. The"
" data is initiakized with `V`. The data can be a scalar or vector field. "
"`sizes` an optional parameter which is either an  integer or a vector of "
"suplementary dimensions with respect to `mf`."
msgstr ""

# 8d782ddb69ea44e6851c826d39169db9
#: getfem.Model.add_integral_contact_between_nonmatching_meshes_brick:1 of
msgid ""
"Synopsis: ind = "
"Model.add_integral_contact_between_nonmatching_meshes_brick(self,  MeshIm"
" mim, string varname_u1, string varname_u2, string multname, string "
"dataname_r [, string dataname_friction_coeff], int region1, int region2 "
"[, int option [, string dataname_alpha [, string dataname_wt1 , string "
"dataname_wt2]]])"
msgstr ""

# 37c892ddc1584e16899c5ff69f90cc99
#: getfem.Model.add_integral_contact_between_nonmatching_meshes_brick:3 of
msgid ""
"Add a contact with or without friction condition between nonmatching "
"meshes to the model. This brick adds a contact which is defined in an "
"integral way. It is the direct approximation of an augmented agrangian "
"formulation (see Getfem user documentation) defined at the continuous "
"level. The advantage should be a better scalability: the number of Newton"
" iterations should be more or less independent of the mesh size. The "
"condition is applied on the variables `varname_u1` and `varname_u2` on "
"the boundaries corresponding to `region1` and `region2`. `multname` "
"should be a fem variable representing the contact stress for the "
"frictionless case and the contact and friction stress for the case with "
"friction. An inf-sup condition between `multname` and `varname_u1` and "
"`varname_u2` is required. The augmentation parameter `dataname_r` should "
"be chosen in a range of acceptable values. The optional parameter "
"`dataname_friction_coeff` is the friction coefficient which could be "
"constant or defined on a finite element method on the same mesh as "
"`varname_u1`. Possible values for `option` is 1 for the non-symmetric "
"Alart-Curnier augmented Lagrangian method, 2 for the symmetric one, 3 for"
" the non-symmetric Alart-Curnier method with an additional augmentation "
"and 4 for a new unsymmetric method. The default value is 1. In case of "
"contact with friction, `dataname_alpha`, `dataname_wt1` and "
"`dataname_wt2` are optional parameters to solve evolutionary friction "
"problems."
msgstr ""

# c3224cd4eb5f43ae9623d4e40f92d064
#: getfem.Model.add_integral_contact_with_rigid_obstacle_brick:1 of
msgid ""
"Synopsis: ind = "
"Model.add_integral_contact_with_rigid_obstacle_brick(self,  MeshIm mim, "
"string varname_u, string multname, string dataname_obstacle, string "
"dataname_r [, string dataname_friction_coeff], int region [, int option "
"[, string dataname_alpha [, string dataname_wt [, string dataname_gamma "
"[, string dataname_vt]]]]])"
msgstr ""

# 985a37a10c9d4685b8140a06412a7289
#: getfem.Model.add_integral_contact_with_rigid_obstacle_brick:3 of
msgid ""
"Add a contact with or without friction condition with a rigid obstacle to"
" the model. This brick adds a contact which is defined in an integral "
"way. It is the direct approximation of an augmented Lagrangian "
"formulation (see Getfem user documentation) defined at the continuous "
"level. The advantage is a better scalability: the number of Newton "
"iterations should be more or less independent of the mesh size. The "
"contact condition is applied on the variable `varname_u` on the boundary "
"corresponding to `region`. The rigid obstacle should be described with "
"the data `dataname_obstacle` being a signed distance to the obstacle "
"(interpolated on a finite element method). `multname` should be a fem "
"variable representing the contact stress. An inf-sup condition beetween "
"`multname` and `varname_u` is required. The augmentation parameter "
"`dataname_r` should be chosen in a range of acceptabe values. The "
"optional parameter `dataname_friction_coeff` is the friction coefficient "
"which could be constant or defined on a finite element method. Possible "
"values for `option` is 1 for the non-symmetric Alart-Curnier augmented "
"Lagrangian method, 2 for the symmetric one, 3 for the non-symmetric "
"Alart-Curnier method with an additional augmentation and 4 for a new "
"unsymmetric method. The default value is 1. In case of contact with "
"friction, `dataname_alpha` and `dataname_wt` are optional parameters to "
"solve evolutionary friction problems. `dataname_gamma` and `dataname_vt` "
"represent optional data for adding a parameter-dependent sliding velocity"
" to the friction condition."
msgstr ""

# 5b0939a283804d0280dd7cf4646c802d
#: getfem.Model.add_integral_large_sliding_contact_brick_raytracing:1 of
msgid ""
"Synopsis: ind = "
"Model.add_integral_large_sliding_contact_brick_raytracing(self, string "
"dataname_r, scalar release_distance, [, string dataname_fr[, string "
"dataname_alpha[, int version]]])"
msgstr ""

# b1bca0fdbf4a45bfa3efd7a127557842
#: getfem.Model.add_integral_large_sliding_contact_brick_raytracing:3 of
msgid ""
"Adds a large sliding contact with friction brick to the model. This brick"
" is able to deal with self-contact, contact between several deformable "
"bodies and contact with rigid obstacles. It uses the high-level generic "
"assembly. It adds to the model a raytracing_interpolate_transformation "
"object. For each slave boundary a multiplier variable should be defined. "
"The release distance should be determined with care (generally a few "
"times a mean element size, and less than the thickness of the body). "
"Initially, the brick is added with no contact boundaries. The contact "
"boundaries and rigid bodies are added with special functions. `version` "
"is 0 (the default value) for the non-symmetric version and 1 for the more"
" symmetric one (not fully symmetric even without friction)."
msgstr ""

# 14dae608782b456bacc3ada40881b503
#: getfem.Model.add_interpolate_transformation_from_expression:1 of
msgid ""
"Add a transformation to the model from mesh `source_mesh` to mesh "
"`target_mesh` given by the expression `expr` which corresponds to a high-"
"level generic assembly expression which may contains some variable of the"
" model. CAUTION: the derivative of the transformation with used variable "
"is taken into account in the computation of the tangen system. However, "
"order two derivative is not implemented, so such tranformation is not "
"allowed in the definition of a potential."
msgstr ""

# 88829f365e704729a8159b5e7c96c902
#: getfem.Model.add_isotropic_linearized_elasticity_brick:1 of
msgid ""
"Add an isotropic linearized elasticity term to the model relatively to "
"the variable `varname`. `dataname_lambda` and `dataname_mu` should "
"contain the Lame coefficients. `region` is an optional mesh region on "
"which the term is added. If it is not specified, it is added on the whole"
" mesh. Return the brick index in the model."
msgstr ""

# e1b6315ae5f84358960c5b1959f7cc17
#: getfem.Model.add_isotropic_linearized_elasticity_brick_pstrain:1 of
msgid ""
"Add an isotropic linearized elasticity term to the model relatively to "
"the variable `varname`. `data_E` and `data_nu` should contain the Young "
"modulus and Poisson ratio, respectively. `region` is an optional mesh "
"region on which the term is added. If it is not specified, it is added on"
" the whole mesh. On two-dimensional meshes, the term will correpsond to a"
" plain strain approximation. On three-dimensional meshes, it will "
"correspond to the standard model.  Return the brick index in the model."
msgstr ""

# f8f6415393e1444e89036240040200e5
#: getfem.Model.add_isotropic_linearized_elasticity_brick_pstress:1 of
msgid ""
"Add an isotropic linearized elasticity term to the model relatively to "
"the variable `varname`. `data_E` and `data_nu` should contain the Young "
"modulus and Poisson ratio, respectively. `region` is an optional mesh "
"region on which the term is added. If it is not specified, it is added on"
" the whole mesh. On two-dimensional meshes, the term will correpsond to a"
" plain stress approximation. On three-dimensional meshes, it will "
"correspond to the standard model.  Return the brick index in the model."
msgstr ""

# 537cf1e5ad604f449561600084718d9c
#: getfem.Model.add_linear_generic_assembly_brick:1 of
msgid ""
"Synopsis: ind = Model.add_linear_generic_assembly_brick(self, MeshIm mim,"
" string expression[, int region[, int is_symmetric[, int is_coercive]]])"
msgstr ""

# f7d4ce3f61a34749be5e3999d412a4b8
#: getfem.Model.add_linear_generic_assembly_brick:3 of
msgid "Deprecated. Use Model.add_linear_term() instead."
msgstr ""

# 4d3423356e8b4839b59018e853f115e4
#: getfem.Model.add_linear_incompressibility_brick:1 of
msgid ""
"Synopsis: ind = Model.add_linear_incompressibility_brick(self, MeshIm "
"mim, string varname, string multname_pressure[, int region[, string "
"dataexpr_coeff]])"
msgstr ""

# 4693fdb20dea4d7ab4b4f1ee373f1ed2
#: getfem.Model.add_linear_incompressibility_brick:3 of
msgid ""
"Add a linear incompressibility condition on `variable`. "
"`multname_pressure` is a variable which represent the pressure. Be aware "
"that an inf-sup condition between the finite element method describing "
"the pressure and the primal variable has to be satisfied. `region` is an "
"optional mesh region on which the term is added. If it is not specified, "
"it is added on the whole mesh. `dataexpr_coeff` is an optional "
"penalization coefficient for nearly incompressible elasticity for "
"instance. In this case, it is the inverse of the Lame coefficient "
":math:`\\lambda`. Return the brick index in the model."
msgstr ""

# cb1fe0fac88f4a8f95a15315e01419ee
#: getfem.Model.add_linear_term:1 of
msgid ""
"Synopsis: ind = Model.add_linear_term(self, MeshIm mim, string "
"expression[, int region[, int is_symmetric[, int is_coercive]]])"
msgstr ""

# 56ce72266699401d886cb031e6edcad7
#: getfem.Model.add_linear_term:3 of
msgid ""
"Adds a matrix term given by the assembly string `expr` which will be "
"assembled in region `region` and with the integration method `mim`. Only "
"the matrix term will be taken into account, assuming that it is linear. "
"The advantage of declaring a term linear instead of nonlinear is that it "
"will be assembled only once and no assembly is necessary for the "
"residual. Take care that if the expression contains some variables and if"
" the expression is a potential or of first order (i.e. describe the weak "
"form, not the derivative of the weak form), the expression will be "
"derivated with respect to all variables. You can specify if the term is "
"symmetric, coercive or not. If you are not sure, the better is to declare"
" the term not symmetric and not coercive. But some solvers (conjugate "
"gradient for instance) are not allowed for non-coercive problems. "
"`brickname` is an otpional name for the brick."
msgstr ""

# 5826956b2ca940b49b88218aa9948a8e
#: getfem.Model.add_macro:1 of
msgid ""
"Define a new macro for the high generic assembly language. The name "
"include the parameters. For instance name='sp(a,b)', expr='a.b' is a "
"valid definition. Macro without parameter can also be defined. For "
"instance name='x1', expr='X[1]' is valid. Teh form name='grad(u)', "
"expr='Grad_u' is also allowed but in that case, the parameter 'u' will "
"only be allowed to be a variable name when using the macro. Note that "
"macros can be directly defined inside the assembly strings with the "
"keyword 'Def'."
msgstr ""

# 584fd103e4c64d38ba09c9271a54ecef
#: getfem.Model.add_mass_brick:1 of
msgid ""
"Synopsis: ind = Model.add_mass_brick(self, MeshIm mim, string varname[, "
"string dataexpr_rho[, int region]])"
msgstr ""

# 32b4637353994538abb1ab61046cd32b
#: getfem.Model.add_mass_brick:3 of
msgid ""
"Add mass term to the model relatively to the variable `varname`. If "
"specified, the data `dataexpr_rho` is the density (1 if omitted). "
"`region` is an optional mesh region on which the term is added. If it is "
"not specified, it is added on the whole mesh. Return the brick index in "
"the model."
msgstr ""

# 47fb520f2ed9434da04f94eecbcf7bb9
#: getfem.Model.add_master_contact_boundary_to_biased_Nitsche_large_sliding_contact_brick:1
#: of
msgid ""
"Adds a master contact boundary to an existing biased Nitsche's large "
"sliding contact with friction brick."
msgstr ""

# eff3e8ed6ec44b6fbd1e06a2727f3199
#: getfem.Model.add_master_contact_boundary_to_large_sliding_contact_brick:1 of
msgid ""
"Adds a master contact boundary to an existing large sliding contact with "
"friction brick."
msgstr ""

# 6dffda71459c48e883add4ef4db2c704
#: getfem.Model.add_master_contact_boundary_to_projection_transformation:1 of
msgid ""
"Add a master contact boundary with corresponding displacement variable "
"`dispname` on a specific boundary `region` to an existing projection "
"interpolate transformation called `transname`."
msgstr ""

# 356ae09191024b86aee89074529b8651
#: getfem.Model.add_master_contact_boundary_to_raytracing_transformation:1 of
msgid ""
"Add a master contact boundary with corresponding displacement variable "
"`dispname` on a specific boundary `region` to an existing raytracing "
"interpolate transformation called `transname`."
msgstr ""

# 0c01451047d6469f99de72ed127f920e
#: getfem.Model.add_master_slave_contact_boundary_to_large_sliding_contact_brick:1
#: of
msgid ""
"Adds a contact boundary to an existing large sliding contact with "
"friction brick which is both master and slave (allowing the self-"
"contact)."
msgstr ""

# 75a89f6c74ec4639b3f51b3da38ce36f
#: getfem.Model.add_multiplier:1 of
msgid ""
"Add a particular variable linked to a fem being a multiplier with respect"
" to a primal variable. The dof will be filtered with the "
"``gmm::range_basis`` function applied on the terms of the model which "
"link the multiplier and the primal variable. This in order to retain only"
" linearly independent constraints on the primal variable. Optimized for "
"boundary multipliers."
msgstr ""

# 23a8a196a21e4dc2bc35805b3554c42b
#: getfem.Model.add_nodal_contact_between_nonmatching_meshes_brick:1 of
msgid ""
"Synopsis: ind = "
"Model.add_nodal_contact_between_nonmatching_meshes_brick(self,  MeshIm "
"mim1[, MeshIm mim2], string varname_u1[, string varname_u2], string "
"multname_n[, string multname_t], string dataname_r[, string dataname_fr],"
" int rg1, int rg2[, int slave1, int slave2,  int augmented_version])"
msgstr ""

# e1993eb9408640b5a4648356d7dff5be
#: getfem.Model.add_nodal_contact_between_nonmatching_meshes_brick:3 of
msgid ""
"Add a contact with or without friction condition between two faces of one"
" or two elastic bodies. The condition is applied on the variable "
"`varname_u1` or the variables `varname_u1` and `varname_u2` depending if "
"a single or two distinct displacement fields are given. Integers `rg1` "
"and `rg2` represent the regions expected to come in contact with each "
"other. In the single displacement variable case the regions defined in "
"both `rg1` and `rg2` refer to the variable `varname_u1`. In the case of "
"two displacement variables, `rg1` refers to `varname_u1` and `rg2` refers"
" to `varname_u2`. `multname_n` should be a fixed size variable whose size"
" is the number of degrees of freedom on those regions among the ones "
"defined in `rg1` and `rg2` which are characterized as \"slaves\". It "
"represents the contact equivalent nodal normal forces. `multname_t` "
"should be a fixed size variable whose size corresponds to the size of "
"`multname_n` multiplied by qdim - 1 . It represents the contact "
"equivalent nodal tangent (frictional) forces. The augmentation parameter "
"`r` should be chosen in a range of acceptabe values (close to the Young "
"modulus of the elastic body, see Getfem user documentation). The friction"
" coefficient stored in the parameter `fr` is either a single value or a "
"vector of the same size as `multname_n`. The optional parameters `slave1`"
" and `slave2` declare if the regions defined in `rg1` and `rg2` are "
"correspondingly considered as \"slaves\". By default `slave1` is true and"
" `slave2` is false, i.e. `rg1` contains the slave surfaces, while 'rg2' "
"the master surfaces. Preferrably only one of `slave1` and `slave2` is set"
" to true.  The parameter `augmented_version` indicates the augmentation "
"strategy : 1 for the non-symmetric Alart-Curnier augmented Lagrangian, 2 "
"for the symmetric one (except for the coupling between contact and "
"Coulomb friction), 3 for the new unsymmetric method. Basically, this "
"brick computes the matrices BN and BT and the vectors gap and alpha and "
"calls the basic contact brick."
msgstr ""

# b74732c9fbcb4c7d8e41bfd9ddcf79c7
#: getfem.Model.add_nodal_contact_with_rigid_obstacle_brick:1 of
msgid ""
"Synopsis: ind = Model.add_nodal_contact_with_rigid_obstacle_brick(self,  "
"MeshIm mim, string varname_u, string multname_n[, string multname_t], "
"string dataname_r[, string dataname_friction_coeff], int region, string "
"obstacle[,  int augmented_version])"
msgstr ""

# 53584db384a1423d8233b757196a8f8b
#: getfem.Model.add_nodal_contact_with_rigid_obstacle_brick:3 of
msgid ""
"Add a contact with or without friction condition with a rigid obstacle to"
" the model. The condition is applied on the variable `varname_u` on the "
"boundary corresponding to `region`. The rigid obstacle should be "
"described with the string `obstacle` being a signed distance to the "
"obstacle. This string should be an expression where the coordinates are "
"'x', 'y' in 2D and 'x', 'y', 'z' in 3D. For instance, if the rigid "
"obstacle correspond to :math:`z \\le 0`, the corresponding signed "
"distance will be simply \"z\". `multname_n` should be a fixed size "
"variable whose size is the number of degrees of freedom on boundary "
"`region`. It represents the contact equivalent nodal forces. In order to "
"add a friction condition one has to add the `multname_t` and "
"`dataname_friction_coeff` parameters. `multname_t` should be a fixed size"
" variable whose size is the number of degrees of freedom on boundary "
"`region` multiplied by :math:`d-1` where :math:`d` is the domain "
"dimension. It represents the friction equivalent nodal forces. The "
"augmentation parameter `r` should be chosen in a range of acceptabe "
"values (close to the Young modulus of the elastic body, see Getfem user "
"documentation).  `dataname_friction_coeff` is the friction coefficient. "
"It could be a scalar or a vector of values representing the friction "
"coefficient on each contact node.  The parameter `augmented_version` "
"indicates the augmentation strategy : 1 for the non-symmetric Alart-"
"Curnier augmented Lagrangian, 2 for the symmetric one (except for the "
"coupling between contact and Coulomb friction), 3 for the new unsymmetric"
" method. Basically, this brick compute the matrix BN and the vectors gap "
"and alpha and calls the basic contact brick."
msgstr ""

# 7593c6b155314aacae622558abb94798
#: getfem.Model.add_nonlinear_elasticity_brick:1 of
msgid ""
"Add a nonlinear elasticity term to the model relatively to the variable "
"`varname` (deprecated brick, use add_finite_strain_elaticity instead). "
"`lawname` is the constitutive law which could be 'SaintVenant Kirchhoff',"
" 'Mooney Rivlin', 'neo Hookean', 'Ciarlet Geymonat' or 'generalized Blatz"
" Ko'. 'Mooney Rivlin' and 'neo Hookean' law names can be preceded with "
"the word 'compressible' or 'incompressible' to force using the "
"corresponding version. The compressible version of these laws requires "
"one additional material coefficient. By default, the incompressible "
"version of 'Mooney Rivlin' law and the compressible one of the 'neo "
"Hookean' law are considered. In general, 'neo Hookean' is a special case "
"of the 'Mooney Rivlin' law that requires one coefficient less. IMPORTANT "
": if the variable is defined on a 2D mesh, the plane strain approximation"
" is automatically used. `dataname` is a vector of parameters for the "
"constitutive law. Its length depends on the law. It could be a short "
"vector of constant values or a vector field described on a finite element"
" method for variable coefficients. `region` is an optional mesh region on"
" which the term is added. If it is not specified, it is added on the "
"whole mesh. This brick use the low-level generic assembly. Returns the "
"brick index in the model."
msgstr ""

# 9e43678d9c18459ea2e5fdccb37cee4e
#: getfem.Model.add_nonlinear_generic_assembly_brick:1 of
msgid ""
"Synopsis: ind = Model.add_nonlinear_generic_assembly_brick(self, MeshIm "
"mim, string expression[, int region[, int is_symmetric[, int "
"is_coercive]]])"
msgstr ""

# c237ee97e623460098567e4e885db019
#: getfem.Model.add_nonlinear_generic_assembly_brick:3 of
msgid "Deprecated. Use Model.add_nonlinear_term() instead."
msgstr ""

# f2ca757523604eff8e0207bb9809a64c
#: getfem.Model.add_nonlinear_incompressibility_brick:1 of
msgid ""
"Add a nonlinear incompressibility condition on `variable` (for large "
"strain elasticity). `multname_pressure` is a variable which represent the"
" pressure. Be aware that an inf-sup condition between the finite element "
"method describing the pressure and the primal variable has to be "
"satisfied. `region` is an optional mesh region on which the term is "
"added. If it is not specified, it is added on the whole mesh. Return the "
"brick index in the model."
msgstr ""

# 95bf794f70ea4d79b7c967ff35ae4ca0
#: getfem.Model.add_nonlinear_term:1 of
msgid ""
"Synopsis: ind = Model.add_nonlinear_term(self, MeshIm mim, string "
"expression[, int region[, int is_symmetric[, int is_coercive]]])"
msgstr ""

# 68444bbaae414e578b443de7886332a5
#: getfem.Model.add_nonlinear_term:3 of
msgid ""
"Adds a nonlinear term given by the assembly string `expr` which will be "
"assembled in region `region` and with the integration method `mim`. The "
"expression can describe a potential or a weak form. Second order terms "
"(i.e. containing second order test functions, Test2) are not allowed. You"
" can specify if the term is symmetric, coercive or not. If you are not "
"sure, the better is to declare the term not symmetric and not coercive. "
"But some solvers (conjugate gradient for instance) are not allowed for "
"non-coercive problems. `brickname` is an otpional name for the brick."
msgstr ""

# 1e40e4e3f26b4ddbba2b8801f1ac6096
#: getfem.Model.add_nonmatching_meshes_contact_brick:1 of
msgid ""
"Synopsis: ind = Model.add_nonmatching_meshes_contact_brick(self,  MeshIm "
"mim1[, MeshIm mim2], string varname_u1[, string varname_u2], string "
"multname_n[, string multname_t], string dataname_r[, string dataname_fr],"
" int rg1, int rg2[, int slave1, int slave2,  int augmented_version])"
msgstr ""

# c12bcb1d8d3242caa1f844a3daf70f36
#: getfem.Model.add_nonmatching_meshes_contact_brick:3 of
msgid ""
"DEPRECATED FUNCTION. Use 'add nodal contact between nonmatching meshes "
"brick' instead."
msgstr ""

# b56114d6c9bd41ea9226256f769110c5
#: getfem.Model.add_normal_Dirichlet_condition_with_Nitsche_method:1 of
msgid ""
"Synopsis: ind = "
"Model.add_normal_Dirichlet_condition_with_Nitsche_method(self, MeshIm "
"mim, string varname, string Neumannterm, string gamma0name, int region[, "
"scalar theta][, string dataname])"
msgstr ""

# bfe9be7799354b68b20943cca6a620a5
#: getfem.Model.add_normal_Dirichlet_condition_with_Nitsche_method:3 of
msgid ""
"Add a Dirichlet condition to the normal component of the vector (or "
"tensor) valued variable `varname` and the mesh region `region`. This "
"region should be a boundary. `Neumannterm` is the expression of the "
"Neumann term (obtained by the Green formula) described as an expression "
"of the high-level generic assembly language. This term can be obtained by"
"  Model.Neumann_term(varname, region) once all volumic bricks have been "
"added to the model. The Dirichlet condition is prescribed with Nitsche's "
"method. `dataname` is the optional right hand side of the Dirichlet "
"condition. It could be constant or described on a fem. `gamma0name` is "
"the Nitsche's method parameter. `theta` is a scalar value which can be "
"positive or negative. `theta = 1` corresponds to the standard symmetric "
"method which is conditionnaly coercive for  `gamma0` small. `theta = -1` "
"corresponds to the skew-symmetric method which is inconditionnaly "
"coercive. `theta = 0` is the simplest method for which the second "
"derivative of the Neumann term is not necessary even for nonlinear "
"problems.  Returns the brick index in the model. (This brick is not fully"
" tested)"
msgstr ""

# 993eef719f2043fa853dc5a31d3740f6
#: getfem.Model.add_normal_Dirichlet_condition_with_multipliers:1 of
msgid ""
"Add a Dirichlet condition to the normal component of the vector (or "
"tensor) valued variable `varname` and the mesh region `region`. This "
"region should be a boundary. The Dirichlet condition is prescribed with a"
" multiplier variable described by `mult_description`. If "
"`mult_description` is a string this is assumed to be the variable name "
"corresponding to the multiplier (which should be first declared as a "
"multiplier variable on the mesh region in the model). If it is a finite "
"element method (mesh_fem object) then a multiplier variable will be added"
" to the model and build on this finite element method (it will be "
"restricted to the mesh region `region` and eventually some conflicting "
"dofs with some other multiplier variables will be suppressed). If it is "
"an integer, then a  multiplier variable will be added to the model and "
"build on a classical finite element of degree that integer. `dataname` is"
" the optional right hand side of  the Dirichlet condition. It could be "
"constant or described on a fem; scalar or vector valued, depending on the"
" variable on which the Dirichlet condition is prescribed (scalar if the "
"variable is vector valued, vector if the variable is tensor valued). "
"Returns the brick index in the model."
msgstr ""

# e0cce6c3bd934977a23ac3f09678ab05
#: getfem.Model.add_normal_Dirichlet_condition_with_penalization:1 of
msgid ""
"Add a Dirichlet condition to the normal component of the vector (or "
"tensor) valued variable `varname` and the mesh region `region`. This "
"region should be a boundary. The Dirichlet condition is prescribed with "
"penalization. The penalization coefficient is initially `coeff` and will "
"be added to the data of the model. `dataname` is the optional right hand "
"side of the Dirichlet condition. It could be constant or described on a "
"fem; scalar or vector valued, depending on the variable on which the "
"Dirichlet condition is prescribed (scalar if the variable is vector "
"valued, vector if the variable is tensor valued). `mf_mult` is an "
"optional parameter which allows to weaken the Dirichlet condition "
"specifying a multiplier space. Returns the brick index in the model."
msgstr ""

# 38fb021569a04d2e8e7ef9d2d57d16b5
#: getfem.Model.add_normal_derivative_Dirichlet_condition_with_multipliers:1 of
msgid ""
"Add a Dirichlet condition on the normal derivative of the variable "
"`varname` and on the mesh region `region` (which should be a boundary. "
"The general form is :math:`\\int \\partial_n u(x)v(x) = \\int r(x)v(x) "
"\\forall v` where :math:`r(x)` is the right hand side for the Dirichlet "
"condition (0 for homogeneous conditions) and :math:`v` is in a space of "
"multipliers defined by `mult_description`. If `mult_description` is a "
"string this is assumed to be the variable name corresponding to the "
"multiplier (which should be first declared as a multiplier variable on "
"the mesh region in the model). If it is a finite element method (mesh_fem"
" object) then a multiplier variable will be added to the model and build "
"on this finite element method (it will be restricted to the mesh region "
"`region` and eventually some conflicting dofs with some other multiplier "
"variables will be suppressed). If it is an integer, then a  multiplier "
"variable will be added to the model and build on a classical finite "
"element of degree that integer. `dataname` is an optional parameter which"
" represents the right hand side of the Dirichlet condition. If "
"`R_must_be_derivated` is set to `true` then the normal derivative of "
"`dataname` is considered. Return the brick index in the model."
msgstr ""

# b3a38193863745e89001fc36a70bafe9
#: getfem.Model.add_normal_derivative_Dirichlet_condition_with_penalization:1
#: of
msgid ""
"Add a Dirichlet condition on the normal derivative of the variable "
"`varname` and on the mesh region `region` (which should be a boundary. "
"The general form is :math:`\\int \\partial_n u(x)v(x) = \\int r(x)v(x) "
"\\forall v` where :math:`r(x)` is the right hand side for the Dirichlet "
"condition (0 for homogeneous conditions). The penalization coefficient is"
" initially `coeff` and will be added to the data of the model. It can be "
"changed with the command Model.change_penalization_coeff(). `dataname` is"
" an optional parameter which represents the right hand side of the "
"Dirichlet condition. If `R_must_be_derivated` is set to `true` then the "
"normal derivative of `dataname` is considered. Return the brick index in "
"the model."
msgstr ""

# d7ea8bd767f84b8680c991cdc19d2069
#: getfem.Model.add_normal_derivative_source_term_brick:1 of
msgid ""
"Add a normal derivative source term brick :math:`F = \\int b.\\partial_n "
"v` on the variable `varname` and the mesh region `region`."
msgstr ""

# 967354f658c24068a6c670de491cf1ee
#: getfem.Model.add_normal_derivative_source_term_brick:5 of
msgid ""
"Update the right hand side of the linear system. `dataname` represents "
"`b` and `varname` represents `v`. Return the brick index in the model."
msgstr ""

# c8b5a1bf7c4947039e745b1d8036d95d
#: getfem.Model.add_normal_source_term_brick:1 of
msgid ""
"Add a source term on the variable `varname` on a boundary `region`. This "
"region should be a boundary. The source term is represented by the data "
"`dataepxpr` which could be any regular expression of the high-level "
"generic assembly language (except for the complex version where it has to"
" be a declared data of the model). A scalar product with the outward "
"normal unit vector to the boundary is performed. The main aim of this "
"brick is to represent a Neumann condition with a vector data without "
"performing the scalar product with the normal as a pre-processing. Return"
" the brick index in the model."
msgstr ""

# 033cc091fc494a92be742c5bcc653b40
#: getfem.Model.add_penalized_contact_between_nonmatching_meshes_brick:1 of
msgid ""
"Synopsis: ind = "
"Model.add_penalized_contact_between_nonmatching_meshes_brick(self,  "
"MeshIm mim, string varname_u1, string varname_u2, string dataname_r [, "
"string dataname_coeff], int region1, int region2 [, int option [, string "
"dataname_lambda, [, string dataname_alpha [, string dataname_wt1, string "
"dataname_wt2]]]])"
msgstr ""

# 21f407d2de77417d84c2495b7f5452ff
#: getfem.Model.add_penalized_contact_between_nonmatching_meshes_brick:3 of
msgid ""
"Add a penalized contact condition with or without friction between "
"nonmatching meshes to the model. The condition is applied on the "
"variables `varname_u1` and  `varname_u2` on the boundaries corresponding "
"to `region1` and `region2`. The penalization parameter `dataname_r` "
"should be chosen large enough to prescribe approximate non-penetration "
"and friction conditions but not too large not to deteriorate too much the"
" conditionning of the tangent system. The optional parameter "
"`dataname_friction_coeff` is the friction coefficient which could be "
"constant or defined on a finite element method on the same mesh as "
"`varname_u1`. `dataname_lambda` is an optional parameter used if option "
"is 2. In that case, the penalization term is shifted by lambda (this "
"allows the use of an Uzawa algorithm on the corresponding augmented "
"Lagrangian formulation) In case of contact with friction, "
"`dataname_alpha`, `dataname_wt1` and `dataname_wt2` are optional "
"parameters to solve evolutionary friction problems."
msgstr ""

# 8a8b0ab62cd64b7eb139b282472889a9
#: getfem.Model.add_penalized_contact_with_rigid_obstacle_brick:1 of
msgid ""
"Synopsis: ind = "
"Model.add_penalized_contact_with_rigid_obstacle_brick(self,  MeshIm mim, "
"string varname_u, string dataname_obstacle, string dataname_r [, string "
"dataname_coeff], int region [, int option, string dataname_lambda, [, "
"string dataname_alpha [, string dataname_wt]]])"
msgstr ""

# 93f462e6ddc64fd9839b45aa5770e8ab
#: getfem.Model.add_penalized_contact_with_rigid_obstacle_brick:3 of
msgid ""
"Add a penalized contact with or without friction condition with a rigid "
"obstacle to the model. The condition is applied on the variable "
"`varname_u` on the boundary corresponding to `region`. The rigid obstacle"
" should be described with the data `dataname_obstacle` being a signed "
"distance to the obstacle (interpolated on a finite element method). The "
"penalization parameter `dataname_r` should be chosen large enough to "
"prescribe approximate non-penetration and friction conditions but not too"
" large not to deteriorate too much the conditionning of the tangent "
"system. `dataname_lambda` is an optional parameter used if option is 2. "
"In that case, the penalization term is shifted by lambda (this allows the"
" use of an Uzawa algorithm on the corresponding augmented Lagrangian "
"formulation)"
msgstr ""

# acdffb8daee246f9af26772a597f0a6e
#: getfem.Model.add_pointwise_constraints_with_given_multipliers:1 of
msgid ""
"Synopsis: ind = "
"Model.add_pointwise_constraints_with_given_multipliers(self, string "
"varname, string multname, string dataname_pt[, string dataname_unitv] [, "
"string dataname_val])"
msgstr ""

# ce5614c292e14578a48bc17e9699550d
#: getfem.Model.add_pointwise_constraints_with_given_multipliers:3 of
msgid ""
"Add some pointwise constraints on the variable `varname` using a given "
"multiplier `multname`. The conditions are prescribed on a set of points "
"given in the data `dataname_pt` whose dimension is the number of points "
"times the dimension of the mesh. The multiplier variable should be a "
"fixed size variable of size the number of points. If the variable "
"represents a vector field, one has to give the data `dataname_unitv` "
"which represents a vector of dimension the number of points times the "
"dimension of the vector field which should store some unit vectors. In "
"that case the prescribed constraint is the scalar product of the variable"
" at the corresponding point with the corresponding unit vector. The "
"optional data `dataname_val` is the vector of values to be prescribed at "
"the different points. This brick is specifically designed to kill rigid "
"displacement in a Neumann problem. Returns the brick index in the model."
msgstr ""

# 1f05d34b17a24824a0505e82ef71ebe5
#: getfem.Model.add_pointwise_constraints_with_multipliers:1 of
msgid ""
"Synopsis: ind = Model.add_pointwise_constraints_with_multipliers(self, "
"string varname, string dataname_pt[, string dataname_unitv] [, string "
"dataname_val])"
msgstr ""

# e4f20e46e66d4af18736655189fb8e0e
#: getfem.Model.add_pointwise_constraints_with_multipliers:3 of
msgid ""
"Add some pointwise constraints on the variable `varname` using "
"multiplier. The multiplier variable is automatically added to the model. "
"The conditions are prescribed on a set of points given in the data "
"`dataname_pt` whose dimension is the number of points times the dimension"
" of the mesh. If the variable represents a vector field, one has to give "
"the data `dataname_unitv` which represents a vector of dimension the "
"number of points times the dimension of the vector field which should "
"store some unit vectors. In that case the prescribed constraint is the "
"scalar product of the variable at the corresponding point with the "
"corresponding unit vector. The optional data `dataname_val` is the vector"
" of values to be prescribed at the different points. This brick is "
"specifically designed to kill rigid displacement in a Neumann problem. "
"Returns the brick index in the model."
msgstr ""

# 01aa43e50e1143bca4071753cdcbeff4
#: getfem.Model.add_pointwise_constraints_with_penalization:1 of
msgid ""
"Synopsis: ind = Model.add_pointwise_constraints_with_penalization(self, "
"string varname, scalar coeff, string dataname_pt[, string dataname_unitv]"
" [, string dataname_val])"
msgstr ""

# ee0e1351de9e4792bc09249c19b95e30
#: getfem.Model.add_pointwise_constraints_with_penalization:3 of
msgid ""
"Add some pointwise constraints on the variable `varname` thanks to a "
"penalization. The penalization coefficient is initially "
"`penalization_coeff` and will be added to the data of the model. The "
"conditions are prescribed on a set of points given in the data "
"`dataname_pt` whose dimension is the number of points times the dimension"
" of the mesh. If the variable represents a vector field, one has to give "
"the data `dataname_unitv` which represents a vector of dimension the "
"number of points times the dimension of the vector field which should "
"store some unit vectors. In that case the prescribed constraint is the "
"scalar product of the variable at the corresponding point with the "
"corresponding unit vector. The optional data `dataname_val` is the vector"
" of values to be prescribed at the different points. This brick is "
"specifically designed to kill rigid displacement in a Neumann problem. "
"Returns the brick index in the model."
msgstr ""

# 9cb1d0cc7e35482a9ded84bbc1f8b2f6
#: getfem.Model.add_projection_transformation:1 of
msgid ""
"Add a projection interpolate transformation called `transname` to a model"
" to be used by the generic assembly bricks. CAUTION: For the moment, the "
"derivative of the transformation is not taken into account in the model "
"solve."
msgstr ""

# 7cbd28221b4643238fcdb860bea66213
#: getfem.Model.add_raytracing_transformation:1 of
msgid ""
"Add a raytracing interpolate transformation called `transname` to a model"
" to be used by the generic assembly bricks. CAUTION: For the moment, the "
"derivative of the transformation is not taken into account in the model "
"solve."
msgstr ""

# 4336d28c760040c784f025fc51388ea3
# 4780966e655b4c51a9e18792e3cff909
#: getfem.Model.add_rigid_obstacle_to_Nitsche_large_sliding_contact_brick:1
#: getfem.Model.add_rigid_obstacle_to_large_sliding_contact_brick:1 of
msgid ""
"Adds a rigid obstacle to an existing large sliding contact with friction "
"brick. `expr` is an expression using the high-level generic assembly "
"language (where `x` is the current point n the mesh) which should be a "
"signed distance to the obstacle. `N` is the mesh dimension."
msgstr ""

# 3869812cb9764b8ea9953928dcf57ee0
#: getfem.Model.add_rigid_obstacle_to_projection_transformation:1 of
msgid ""
"Add a rigid obstacle whose geometry corresponds to the zero level-set of "
"the high-level generic assembly expression `expr` to an existing "
"projection interpolate transformation called `transname`."
msgstr ""

# 8e04dc8761424e41875e5dbaa4bea31d
#: getfem.Model.add_rigid_obstacle_to_raytracing_transformation:1 of
msgid ""
"Add a rigid obstacle whose geometry corresponds to the zero level-set of "
"the high-level generic assembly expression `expr` to an existing "
"raytracing interpolate transformation called `transname`."
msgstr ""

# 04aac6c55abe4810b6e90a303329d552
#: getfem.Model.add_slave_contact_boundary_to_biased_Nitsche_large_sliding_contact_brick:1
#: of
msgid ""
"Adds a slave contact boundary to an existing biased Nitsche's large "
"sliding contact with friction brick."
msgstr ""

# 5ba975079d674b758c9397df912f1c9e
#: getfem.Model.add_slave_contact_boundary_to_large_sliding_contact_brick:1 of
msgid ""
"Adds a slave contact boundary to an existing large sliding contact with "
"friction brick."
msgstr ""

# 82f0ad6170c74a4bb65778689ae72663
#: getfem.Model.add_slave_contact_boundary_to_projection_transformation:1 of
msgid ""
"Add a slave contact boundary with corresponding displacement variable "
"`dispname` on a specific boundary `region` to an existing projection "
"interpolate transformation called `transname`."
msgstr ""

# 131149bb59d44f99a36b00b96f9cf97e
#: getfem.Model.add_slave_contact_boundary_to_raytracing_transformation:1 of
msgid ""
"Add a slave contact boundary with corresponding displacement variable "
"`dispname` on a specific boundary `region` to an existing raytracing "
"interpolate transformation called `transname`."
msgstr ""

# df474dc59df64961bd6e80ea78b5be95
#: getfem.Model.add_small_strain_elastoplasticity_brick:1 of
msgid ""
"Synopsis: ind = Model.add_small_strain_elastoplasticity_brick(self, "
"MeshIm mim,  string lawname, string unknowns_type [, string varnames, "
"...] [, string params, ...] [, string theta = '1' [, string dt = "
"'timestep']] [, int region = -1])"
msgstr ""

# 30344995185846438697eb03fa234a39
#: getfem.Model.add_small_strain_elastoplasticity_brick:3 of
msgid ""
"Adds a small strain plasticity term to the model `M`. This is the main "
"GetFEM++ brick for small strain plasticity. `lawname` is the name of an "
"implemented plastic law, `unknowns_type` indicates the choice between a "
"discretization where the plastic multiplier is an unknown of the problem "
"or (return mapping approach) just a data of the model stored for the next"
" iteration. Remember that in both cases, a multiplier is stored anyway. "
"`varnames` is a set of variable and data names with length which may "
"depend on the plastic law (at least the displacement, the plastic "
"multiplier and the plastic strain). `params` is a list of expressions for"
" the parameters (at least elastic coefficients and the yield stress). "
"These expressions can be some data names (or even variable names) of the "
"model but can also be any scalar valid expression of the high level "
"assembly language (such as '1/2', '2+sin(X[0])', '1+Norm(v)' ...). The "
"last two parameters optionally provided in `params` are the `theta` "
"parameter of the `theta`-scheme (generalized trapezoidal rule) used for "
"the plastic strain integration and the time-step`dt`. The default value "
"for `theta` if omitted is 1, which corresponds to the classical Backward "
"Euler scheme which is first order consistent. `theta=1/2` corresponds to "
"the Crank-Nicolson scheme (trapezoidal rule) which is second order "
"consistent. Any value between 1/2 and 1 should be a valid value. The "
"default value of `dt` is 'timestep' which simply indicates the time step "
"defined in the model (by md.set_time_step(dt)). Alternatively it can be "
"any expression (data name, constant value ...). The time step can be "
"altered from one iteration to the next one. `region` is a mesh region."
msgstr ""

# e545f09a58514c3985cf5ea1c6da443d
#: getfem.Model.add_small_strain_elastoplasticity_brick:29 of
msgid "The available plasticity laws are:"
msgstr ""

# 8fcb4393568343c2a5cbe2b5496a4871
#: getfem.Model.add_small_strain_elastoplasticity_brick:31 of
msgid ""
"'Prandtl Reuss' (or 'isotropic perfect plasticity'). Isotropic elasto-"
"plasticity with no hardening. The variables are the displacement, the "
"plastic multiplier and the plastic strain. The displacement should be a "
"variable and have a corresponding data having the same name preceded by "
"'Previous\\_' corresponding to the displacement at the previous time step"
" (typically 'u' and 'Previous_u'). The plastic multiplier should also "
"have two versions (typically 'xi' and 'Previous_xi') the first one being "
"defined as data if `unknowns_type ` is 'DISPLACEMENT_ONLY' or the integer"
" value 0, or as a variable if `unknowns_type` is "
"DISPLACEMENT_AND_PLASTIC_MULTIPLIER or the integer value 1. The plastic "
"strain should represent a n x n data tensor field stored on mesh_fem or "
"(preferably) on an im_data (corresponding to `mim`). The data are the "
"first Lame coefficient, the second one (shear modulus) and the uniaxial "
"yield stress. A typical call is "
"Model.add_small_strain_elastoplasticity_brick(mim, 'Prandtl Reuss', 0, "
"'u', 'xi', 'Previous_Ep', 'lambda', 'mu', 'sigma_y', '1', 'timestep'); "
"IMPORTANT: Note that this law implements the 3D expressions. If it is "
"used in 2D, the expressions are just transposed to the 2D. For the plane "
"strain approximation, see below."
msgstr ""

# e287ba4cc4c949478f78b19c5981bf4f
#: getfem.Model.add_small_strain_elastoplasticity_brick:50 of
msgid ""
"\"plane strain Prandtl Reuss\" (or \"plane strain isotropic perfect "
"plasticity\") The same law as the previous one but adapted to the plane "
"strain approximation. Can only be used in 2D."
msgstr ""

# 5af61f3da1f9496b907a49503f1fd7ab
#: getfem.Model.add_small_strain_elastoplasticity_brick:54 of
msgid ""
"\"Prandtl Reuss linear hardening\" (or \"isotropic plasticity linear "
"hardening\"). Isotropic elasto-plasticity with linear isotropic and "
"kinematic hardening. An additional variable compared to \"Prandtl Reuss\""
" law: the accumulated plastic strain. Similarly to the plastic strain, it"
" is only stored at the end of the time step, so a simple data is required"
" (preferably on an im_data). Two additional parameters: the kinematic "
"hardening modulus and the isotropic one. 3D expressions only. A typical "
"call is Model.add_small_strain_elastoplasticity_brick(mim, 'Prandtl Reuss"
" linear hardening', 0, 'u', 'xi', 'Previous_Ep', 'Previous_alpha', "
"'lambda', 'mu', 'sigma_y', 'H_k', H_i', '1', 'timestep');"
msgstr ""

# 5f86ea94d5e64fc09af3140ee55b1dd4
#: getfem.Model.add_small_strain_elastoplasticity_brick:64 of
msgid ""
"\"plane strain Prandtl Reuss linear hardening\" (or \"plane strain "
"isotropic plasticity linear hardening\"). The same law as the previous "
"one but adapted to the plane strain approximation. Can only be used in "
"2D."
msgstr ""

# c23bf1da6b304910913462a57aa2c786
#: getfem.Model.add_small_strain_elastoplasticity_brick:69 of
msgid ""
"See GetFEM++ user documentation for further explanations on the "
"discretization of the plastic flow and on the implemented plastic laws. "
"See also GetFEM++ user documentation on time integration strategy "
"(integration of transient problems)."
msgstr ""

# 3d7d2763385744d5a41a6553887258c6
#: getfem.Model.add_small_strain_elastoplasticity_brick:74 of
msgid ""
"IMPORTANT : remember that `small_strain_elastoplasticity_next_iter` has "
"to be called at the end of each time step, before the next one (and "
"before any post-treatment : this sets the value of the plastic strain and"
" plastic multiplier)."
msgstr ""

# e62814143d804396ac735ce443457ea8
#: getfem.Model.add_source_term:1 of
msgid ""
"Adds a source term given by the assembly string `expr` which will be "
"assembled in region `region` and with the integration method `mim`. Only "
"the residual term will be taken into account. Take care that if the "
"expression contains some variables and if the expression is a potential, "
"the expression will be derivated with respect to all variables. "
"`brickname` is an optional name for the brick."
msgstr ""

# d9f9583fcd0e4d3baa629dc7b33c4cac
#: getfem.Model.add_source_term_brick:1 of
msgid ""
"Synopsis: ind = Model.add_source_term_brick(self, MeshIm mim, string "
"varname, string dataexpr[, int region[, string directdataname]])"
msgstr ""

# 81bf479cb6ac472e86767345f1495edc
#: getfem.Model.add_source_term_brick:3 of
msgid ""
"Add a source term to the model relatively to the variable `varname`. The "
"source term is represented by `dataexpr` which could be any regular "
"expression of the high-level generic assembly language (except for the "
"complex version where it has to be a declared data of the model). "
"`region` is an optional mesh region on which the term is added. An "
"additional optional data `directdataname` can be provided. The "
"corresponding data vector will be directly added to the right hand side "
"without assembly. Note that when region is a boundary, this brick allows "
"to prescribe a nonzero Neumann boundary condition. Return the brick index"
" in the model."
msgstr ""

# bfb53f89e2bd4ca5854dcdcc8fb68807
#: getfem.Model.add_source_term_generic_assembly_brick:1 of
msgid "Deprecated. Use Model.add_source_term() instead."
msgstr ""

# 9ef1aa5ade274f81934d25c9b31e6f7f
#: getfem.Model.add_theta_method_for_first_order:1 of
msgid ""
"Attach a theta method for the time discretization of the variable "
"`varname`. Valid only if there is at most first order time derivative of "
"the variable."
msgstr ""

# 5dfc72196a68426595dadd399a48b2a0
#: getfem.Model.add_variable:1 of
msgid ""
"Add a variable to the model of constant sizes. `sizes` is either a "
"integer (for a scalar or vector variable) or a vector of dimensions for a"
" tensor variable. `name` is the variable name."
msgstr ""

# 11ec8a0457a44585b06b823c8d58c1cd
#: getfem.Model.assembly:1 of
msgid ""
"Assembly of the tangent system taking into account the terms from all "
"bricks. `option`, if specified, should be 'build_all', 'build_rhs', "
"'build_matrix'. The default is to build the whole tangent linear system "
"(matrix and rhs). This function is useful to solve your problem with you "
"own solver."
msgstr ""

# 362c9bd0492c42ab92d85e0f438f7fa8
#: getfem.Model.brick_list:1 of
msgid "print to the output the list of bricks of the model."
msgstr ""

# 7eec9cfaddc54ea9b2dfa32a48daf559
#: getfem.Model.brick_term_rhs:1 of
msgid ""
"Gives the access to the part of the right hand side of a term of a "
"particular nonlinear brick. Does not account of the eventual time "
"dispatcher. An assembly of the rhs has to be done first. `ind_brick` is "
"the brick index. `ind_term` is the index of the term inside the brick "
"(default value : 0). `sym` is to access to the second right hand side of "
"for symmetric terms acting on two different variables (default is 0). "
"`ind_iter` is the iteration number when time dispatchers are used "
"(default is 0)."
msgstr ""

# 41d7ec33a65e446aa9fcfa73f6ff80c0
#: getfem.Model.change_penalization_coeff:1 of
msgid ""
"Change the penalization coefficient of a Dirichlet condition with "
"penalization brick. If the brick is not of this kind, this function has "
"an undefined behavior."
msgstr ""

# b1bb776cceb64757836570bf9c6f0978
#: getfem.Model.char:1 of
msgid "Output a (unique) string representation of the Model."
msgstr ""

# f723252c207547f3a679315944f5efca
#: getfem.Model.char:3 of
msgid ""
"This can be used to perform comparisons between two different Model "
"objects. This function is to be completed."
msgstr ""

# a7ea6c65efc14d68a6dce9cc2e40ce73
#: getfem.Model.clear:1 of
msgid "Clear the model."
msgstr ""

# 31dab63441d44968a110264c7468014a
#: getfem.Model.clear_assembly_assignment:1 of
msgid "Delete all added assembly assignments"
msgstr ""

# 47f37acce171406ba630b66f4a137fc9
#: getfem.Model.compute_Von_Mises_or_Tresca:1 of
msgid ""
"Compute on `mf_vm` the Von-Mises stress or the Tresca stress of a field "
"for nonlinear elasticity in 3D. `lawname` is the constitutive law which "
"could be 'SaintVenant Kirchhoff', 'Mooney Rivlin', 'neo Hookean' or "
"'Ciarlet Geymonat'. `dataname` is a vector of parameters for the "
"constitutive law. Its length depends on the law. It could be a short "
"vector of constant values or a vector field described on a finite element"
" method for variable coefficients. `version` should be  'Von_Mises' or "
"'Tresca' ('Von_Mises' is the default)."
msgstr ""

# 6671a39fe7f943ccbf70eaba93830d9c
#: getfem.Model.compute_elastoplasticity_Von_Mises_or_Tresca:1 of
msgid ""
"Compute on `mf_vm` the Von-Mises or the Tresca stress of a field for "
"plasticity and return it into the vector V. `datasigma` is a vector which"
" contains the stress constraints values supported by the mesh. `version` "
"should be  'Von_Mises' or 'Tresca' ('Von_Mises' is the default)."
msgstr ""

# a8cff94c17f54694948fc793b2faa100
#: getfem.Model.compute_finite_strain_elasticity_Von_Mises:1 of
msgid ""
"Compute on `mf_vm` the Von-Mises stress of a field `varname` for "
"nonlinear elasticity in 3D. `lawname` is the constitutive law which "
"should be a valid name. `params` are the parameters law. It could be a "
"short vector of constant values or may depend on data or variables of the"
" model. Uses the high-level generic assembly."
msgstr ""

# 01c2672085254567a4aced998b9bb491
#: getfem.Model.compute_finite_strain_elastoplasticity_Von_Mises:1 of
msgid ""
"Synopsis: V = "
"Model.compute_finite_strain_elastoplasticity_Von_Mises(self, MeshIm mim, "
"MeshFem mf_vm, string lawname, string unknowns_type, [, string varnames, "
"...] [, string params, ...] [, int region = -1])"
msgstr ""

# a34925a005e04c96b92e2196f063ed44
#: getfem.Model.compute_finite_strain_elastoplasticity_Von_Mises:3 of
msgid ""
"Compute on `mf_vm` the Von-Mises or the Tresca stress of a field for "
"plasticity and return it into the vector V. The first input parameters ar"
" as in the function 'finite strain elastoplasticity next iter'."
msgstr ""

# 718ac005e05c4390864c077a8c13243a
#: getfem.Model.compute_isotropic_linearized_Von_Mises_or_Tresca:1 of
msgid ""
"Compute the Von-Mises stress or the Tresca stress of a field (only valid "
"for isotropic linearized elasticity in 3D). `version` should be  "
"'Von_Mises' or 'Tresca' ('Von_Mises' is the default). Parametrized by "
"Lame coefficients."
msgstr ""

# 95914d6f6d944209a9b64450d9cc6dff
#: getfem.Model.compute_isotropic_linearized_Von_Mises_pstrain:1 of
msgid ""
"Compute the Von-Mises stress  of a displacement field for isotropic "
"linearized elasticity in 3D or in 2D with plane strain assumption. "
"Parametrized by Young modulus and Poisson ratio."
msgstr ""

# 668b59a136574c14833cfe369e376cef
#: getfem.Model.compute_isotropic_linearized_Von_Mises_pstress:1 of
msgid ""
"Compute the Von-Mises stress  of a displacement field for isotropic "
"linearized elasticity in 3D or in 2D with plane stress assumption. "
"Parametrized by Young modulus and Poisson ratio."
msgstr ""

# 7adee7a4d1f3405098e366dba94150bd
#: getfem.Model.compute_plastic_part:1 of
msgid ""
"Compute on `mf_pl` the plastic part and return it into the vector V. "
"`datasigma` is a vector which contains the stress constraints values "
"supported by the mesh."
msgstr ""

# 47a9f959f3474eb89b78dd833bb8fa16
#: getfem.Model.compute_second_Piola_Kirchhoff_tensor:1 of
msgid ""
"Compute on `mf_sigma` the second Piola Kirchhoff stress tensor of a field"
" for nonlinear elasticity in 3D. `lawname` is the constitutive law which "
"could be 'SaintVenant Kirchhoff', 'Mooney Rivlin', 'neo Hookean' or "
"'Ciarlet Geymonat'. `dataname` is a vector of parameters for the "
"constitutive law. Its length depends on the law. It could be a short "
"vector of constant values or a vector field described on a finite element"
" method for variable coefficients."
msgstr ""

# 5f0e9e635ed94293829f5b6c00ba06f8
#: getfem.Model.contact_brick_set_BN:1 of
msgid "Can be used to set the BN matrix of a basic contact/friction brick."
msgstr ""

# b27acec399bd427bb6793667f4226782
#: getfem.Model.contact_brick_set_BT:1 of
msgid "Can be used to set the BT matrix of a basic contact with friction brick."
msgstr ""

# 05510efd53e348fcaf6893b9ed41edb2
#: getfem.Model.define_variable_group:1 of
msgid ""
"Synopsis: Model.define_variable_group(self, string name[, string varname,"
" ...])"
msgstr ""

# bf85accc83c44a4dab5b7906a88cddf7
#: getfem.Model.define_variable_group:3 of
msgid ""
"Defines a group of variables for the interpolation (mainly for the "
"raytracing interpolation transformation."
msgstr ""

# bb119bcac1c64a9abc840785f1763623
#: getfem.Model.del_macro:1 of
msgid "Delete a previously defined macro for the high generic assembly language."
msgstr ""

# a8f0de56ed0347cbaeadde1cd356deb6
# 1a18c2873f024a788748679080749eea
#: getfem.Model.delete_brick:1 getfem.Model.delete_variable:1 of
msgid "Delete a variable or a data from the model."
msgstr ""

# e2b188f9f07d410b99ec7a8f4230937f
#: getfem.Model.disable_bricks:1 of
msgid ""
"Disable a brick (the brick will no longer participate to the building of "
"the tangent linear system)."
msgstr ""

# 0f83fbd16bcd4f8ba68844f7e3b3b309
#: getfem.Model.disable_variable:1 of
msgid ""
"Disable a variable for a solve (and its attached multipliers). The next "
"solve will operate only on the remaining variables. This allows to solve "
"separately different parts of a model. If there is a strong coupling of "
"the variables, a fixed point strategy can the be used."
msgstr ""

# aaad564b7df7410ab4da2bc6c87ca36a
# 284c081325fa4497acba4ebbd154a160
# 827d33d3794247a585f49553136ad3df
# 97dcabdd1aa249bab255a1a0a9e532f3
# 0c3222391f92406eadfa91cf8d812b02
# 7258bbfae30f419e9b009e18ce3e1b33
#: getfem.Model.displacement_group_name_of_Nitsche_large_sliding_contact_brick:1
#: getfem.Model.displacement_group_name_of_large_sliding_contact_brick:1
#: getfem.Model.sliding_data_group_name_of_Nitsche_large_sliding_contact_brick:1
#: getfem.Model.sliding_data_group_name_of_large_sliding_contact_brick:1
#: getfem.Model.transformation_name_of_Nitsche_large_sliding_contact_brick:1
#: getfem.Model.transformation_name_of_large_sliding_contact_brick:1 of
msgid ""
"Gives the name of the group of variables corresponding to the sliding "
"data for an existing large sliding contact brick."
msgstr ""

# f8f8ddb91a9846fb99a9bac073faf210
#: getfem.Model.display:1 of
msgid "displays a short summary for a Model object."
msgstr ""

# dbf13698fed541f0baaceb6e950ac112
#: getfem.Model.elastoplasticity_next_iter:1 of
msgid ""
"Used with the old (obsolete) elastoplasticity brick to pass from an "
"iteration to the next one. Compute and save the stress constraints sigma "
"for the next iterations. 'mim' is the integration method to use for the "
"computation. 'varname' is the main variable of the problem. "
"'previous_dep_name' represents the displacement at the previous time "
"step. 'projname' is the type of projection to use. For the moment it "
"could only be 'Von Mises' or 'VM'. 'datalambda' and 'datamu' are the Lame"
" coefficients of the material. 'datasigma' is a vector which will contain"
" the new stress constraints values."
msgstr ""

# c1ec87b53f324c22a5d20ee2a7230e0d
#: getfem.Model.enable_bricks:1 of
msgid "Enable a disabled brick."
msgstr ""

# 4a192ca53aa446e98301af0841a1bef5
#: getfem.Model.enable_variable:1 of
msgid "Enable a disabled variable (and its attached multipliers)."
msgstr ""

# 305b08d7a00e488db668883e5f1b6d9d
#: getfem.Model.finite_strain_elastoplasticity_next_iter:1 of
msgid ""
"Synopsis: Model.finite_strain_elastoplasticity_next_iter(self, MeshIm "
"mim, string lawname, string unknowns_type, [, string varnames, ...] [, "
"string params, ...] [, int region = -1])"
msgstr ""

# db468163c3d2410593c3e46c8c9e0c93
#: getfem.Model.finite_strain_elastoplasticity_next_iter:3 of
msgid ""
"Function that allows to pass from a time step to another for the finite "
"strain plastic brick. The parameters have to be exactly the same than the"
" one of `add_finite_strain_elastoplasticity_brick`, so see the "
"documentation of this function for the explanations. Basically, this "
"brick computes the plastic strain and the plastic multiplier and stores "
"them for the next step. For the Simo-Miehe law which is currently the "
"only one implemented, this function updates the state variables defined "
"in the last two entries of `varnames`, and resets the plastic multiplier "
"field given as the second entry of `varnames`."
msgstr ""

# ccc47088cfee4a0d84a6916357879050
#: getfem.Model.first_iter:1 of
msgid "To be executed before the first iteration of a time integration scheme."
msgstr ""

# c340416835ca472fabfa2b36def64d10
#: getfem.Model.from_variables:1 of
msgid ""
"Return the vector of all the degrees of freedom of the model consisting "
"of the concatenation of the variables of the model (useful to solve your "
"problem with you own solver)."
msgstr ""

# 4924cf19b2c540388c6deebd28f9e3e5
#: getfem.Model.get_time:1 of
msgid "Give the value of the data `t` corresponding to the current time."
msgstr ""

# dba2426b5df94a90bd40a16f58e5f1a3
#: getfem.Model.get_time_step:1 of
msgid "Gives the value of the time step."
msgstr ""

# e2d5967a7bc644a59733b463808ad168
#: getfem.Model.interpolation:1 of
msgid ""
"Synopsis: V = Model.interpolation(self, string expr, {MeshFem mf | "
"MeshImd mimd | vec pts,  Mesh m}[, int region[, int extrapolation[, int "
"rg_source]]])"
msgstr ""

# ed168ce832b2439b81c6f24a19302edf
#: getfem.Model.interpolation:3 of
msgid ""
"Interpolate a certain expression with respect to the mesh_fem `mf` or the"
" mesh_im_data `mimd` or the set of points `pts` on mesh `m`. The "
"expression has to be valid according to the high-level generic assembly "
"language possibly including references to the variables and data of the "
"model."
msgstr ""

# f921424e4032458eacd39496414cf6ea
#: getfem.Model.interpolation:9 of
msgid ""
"The options `extrapolation` and `rg_source` are specific to "
"interpolations with respect to a set of points `pts`."
msgstr ""

# fa5700d77a704e349b8627aa08e2d819
#: getfem.Model.interval_of_variable:1 of
msgid ""
"Gives the interval of the variable `varname` in the linear system of the "
"model."
msgstr ""

# 08c65f5d9f9245cba43564905caa5225
#: getfem.Model.is_complex:1 of
msgid "Return 0 is the model is real, 1 if it is complex."
msgstr ""

# 018dc36ad60e4aa99a5449e2cd84df18
#: getfem.Model.list_residuals:1 of
msgid ""
"print to the output the residuals corresponding to all terms included in "
"the model."
msgstr ""

# 05761b345cd2499d81a4ef4bd2423485
#: getfem.Model.local_projection:1 of
msgid ""
"Make an elementwise L2 projection of an expression with respect to the "
"mesh_fem `mf`. This mesh_fem has to be a discontinuous one. The "
"expression has to be valid according to the high-level generic assembly "
"language possibly including references to the variables and data of the "
"model."
msgstr ""

# 3546345b51144594ba23fb8021edfda4
#: getfem.Model.matrix_term:1 of
msgid "Gives the matrix term ind_term of the brick ind_brick if it exists"
msgstr ""

# dfe646162c9e4705aae6ea2d875d5294
#: getfem.Model.memsize:1 of
msgid ""
"Return a rough approximation of the amount of memory (in bytes) used by "
"the model."
msgstr ""

# 8b8179e48c314eaa98a4f7b85c6fcff5
#: getfem.Model.mesh_fem_of_variable:1 of
msgid "Gives access to the `mesh_fem` of a variable or data."
msgstr ""

# 7b71d8dc033546689885e94f9eb95ed4
#: getfem.Model.mult_varname_Dirichlet:1 of
msgid ""
"Gives the name of the multiplier variable for a Dirichlet brick. If the "
"brick is not a Dirichlet condition with multiplier brick, this function "
"has an undefined behavior"
msgstr ""

# 6c261c03e311488b863e9446450dbcce
#: getfem.Model.nbdof:1 of
msgid "Return the total number of degrees of freedom of the model."
msgstr ""

# e333df8524be4943a55c0099259ae73b
#: getfem.Model.next_iter:1 of
msgid "To be executed at the end of each iteration of a time integration scheme."
msgstr ""

# be2e70e678b04eaba70a5e52a0005b02
#: getfem.Model.perform_init_time_derivative:1 of
msgid ""
"By calling this function, indicates that the next solve will compute the "
"solution for a (very) small time step `ddt` in order to initalize the "
"data corresponding to the derivatives needed by time integration schemes "
"(mainly the initial time derivative for order one in time problems  and "
"the second order time derivative for second order in time problems). The "
"next solve will not change the value of the variables."
msgstr ""

# 984f9d773fbc4b1eb7b2049ad50b20be
#: getfem.Model.resize_variable:1 of
msgid ""
"Resize a  constant size variable of the model.  `sizes` is either a "
"integer (for a scalar or vector variable) or a vector of dimensions for a"
" tensor variable. `name` is the variable name."
msgstr ""

# e38d4ba564e74159bd1accdd3d22ed23
#: getfem.Model.rhs:1 of
msgid "Return the right hand side of the tangent problem."
msgstr ""

# c7fa7acb318d4d63b67bcde4316b6ab2
#: getfem.Model.set_element_extrapolation_correspondance:1 of
msgid ""
"Change the correspondance map of an element extrapolation interpolate "
"transformation."
msgstr ""

# 6e65d23fc6c94e21b956df8f4d4939cb
#: getfem.Model.set_private_matrix:1 of
msgid ""
"For some specific bricks having an internal sparse matrix (explicit "
"bricks: 'constraint brick' and 'explicit matrix brick'), set this matrix."
msgstr ""

# 276016659ff743f0a503277fecfcc002
#: getfem.Model.set_private_rhs:1 of
msgid ""
"For some specific bricks having an internal right hand side vector "
"(explicit bricks: 'constraint brick' and 'explicit rhs brick'), set this "
"rhs."
msgstr ""

# 3225f7ed1f2e4684b05d041d19243a5b
#: getfem.Model.set_time:1 of
msgid "Set the value of the data `t` corresponding to the current time to `t`."
msgstr ""

# 8941ec2cfd284277a314be500ff2356a
#: getfem.Model.set_time_step:1 of
msgid ""
"Set the value of the time step to `dt`. This value can be change from a "
"step to another for all one-step schemes (i.e for the moment to all "
"proposed time integration schemes)."
msgstr ""

# 104b02e30a214743b6c376127f761224
#: getfem.Model.set_variable:1 of
msgid "Set the value of a variable or data. `name` is the data name."
msgstr ""

# b77bd924c1344ebe89de106325078844
#: getfem.Model.shift_variables_for_time_integration:1 of
msgid ""
"Function used to shift the variables of a model to the data corresponding"
" of ther value on the previous time step for time integration schemes. "
"For each variable for which a time integration scheme has been declared, "
"the scheme is called to perform the shift. This function has to be called"
" between two time steps."
msgstr ""

# cf92fb3cda7846ea9c531da6ddbf2d37
#: getfem.Model.small_strain_elastoplasticity_Von_Mises:1 of
msgid ""
"Synopsis: V = Model.small_strain_elastoplasticity_Von_Mises(self, MeshIm "
"mim, MeshFem mf_vm, string lawname, string unknowns_type [, string "
"varnames, ...] [, string params, ...] [, string theta = '1' [, string dt "
"= 'timestep']] [, int region])"
msgstr ""

# 04de10dd3f5446c9ab56d53ae5f35281
#: getfem.Model.small_strain_elastoplasticity_Von_Mises:3 of
msgid ""
"This function computes the Von Mises stress field with respect to a small"
" strain elastoplasticity term, approximated on `mf_vm`, and stores the "
"result into `VM`.  All other parameters have to be exactly the same as "
"for `add_small_strain_elastoplasticity_brick`. Remember that "
"`small_strain_elastoplasticity_next_iter` has to be called before any "
"call of this function."
msgstr ""

# 8eb73edfacab46c3afc470216f89ab87
#: getfem.Model.small_strain_elastoplasticity_next_iter:1 of
msgid ""
"Synopsis: Model.small_strain_elastoplasticity_next_iter(self, MeshIm mim,"
"  string lawname, string unknowns_type [, string varnames, ...] [, string"
" params, ...] [, string theta = '1' [, string dt = 'timestep']] [, int "
"region = -1])"
msgstr ""

# 984554d5b3df43f3b3e9be614a034d70
#: getfem.Model.small_strain_elastoplasticity_next_iter:3 of
msgid ""
"Function that allows to pass from a time step to another for the small "
"strain plastic brick. The parameters have to be exactly the same than the"
" one of `add_small_strain_elastoplasticity_brick`, so see the "
"documentation of this function for the explanations. Basically, this "
"brick computes the plastic strain and the plastic multiplier and stores "
"them for the next step. Additionaly, it copies the computed displacement "
"to the data that stores the displacement of the previous time step "
"(typically 'u' to 'Previous_u'). It has to be called before any use of "
"`compute_small_strain_elastoplasticity_Von_Mises`."
msgstr ""

# 90abfa49ab634f6c8b10ffb3bf45ca85
#: getfem.Model.solve:1 of
msgid "Synopsis: (nbit, converged) = Model.solve(self[, ...])"
msgstr ""

# ca67bd44ad484b199bce7ae069473f28
#: getfem.Model.solve:3 of
msgid "Run the standard getfem solver."
msgstr ""

# 700c01cccdd24ccf9f57f0ab2cc40215
#: getfem.Model.solve:5 of
msgid ""
"Note that you should be able to use your own solver if you want (it is "
"possible to obtain the tangent matrix and its right hand side with the "
"Model.tangent_matrix() etc.)."
msgstr ""

# f5c6c76e0050471c95f708568574b51a
#: getfem.Model.solve:9 of
msgid "Various options can be specified:"
msgstr ""

# 139c5b46e7144b609a2d48f2c1ce3659
#: getfem.Model.solve:12 of
msgid "'noisy' or 'very_noisy'"
msgstr ""

# bba29e3feebc4414a7bf8f39068a223b
#: getfem.Model.solve:12 of
msgid ""
"the solver will display some information showing the progress (residual "
"values etc.)."
msgstr ""

# a3c0ba472ef2445d83250af00a7ade42
#: getfem.Model.solve:14 of
msgid "'max_iter', int NIT"
msgstr ""

# d28f9b0839f74a2fbacd7324cd645164
#: getfem.Model.solve:15 of
msgid "set the maximum iterations numbers."
msgstr ""

# 9db000356ae14dadb39864a43fc40a50
#: getfem.Model.solve:16 of
msgid "'max_res', @float RES"
msgstr ""

# 609e577aad9c48e5bc9456adc083fae2
#: getfem.Model.solve:17 of
msgid "set the target residual value."
msgstr ""

# 32cfb912b40d435294f96e7b68a265a3
#: getfem.Model.solve:19 of
msgid "'diverged_res', @float RES"
msgstr ""

# c5d86cd7d4f94b68b16014d5a57fde06
#: getfem.Model.solve:19 of
msgid ""
"set the threshold value of the residual beyond which the iterative method"
" is considered to diverge (default is 1e200)."
msgstr ""

# b3784dbd8cce4db09cd5073040f406c1
#: getfem.Model.solve:24 of
msgid "'lsolver', string SOLVER_NAME"
msgstr ""

# dbf5a03ac4a644c983c3fb2f5556d8f0
#: getfem.Model.solve:22 of
msgid ""
"select explicitely the solver used for the linear systems (the default "
"value is 'auto', which lets getfem choose itself). Possible values are "
"'superlu', 'mumps' (if supported), 'cg/ildlt', 'gmres/ilu' and "
"'gmres/ilut'."
msgstr ""

# 96309ff9b7e84f26bc26cd58e99aa022
#: getfem.Model.solve:29 of
msgid "'lsearch', string LINE_SEARCH_NAME"
msgstr ""

# cf121fbe632a4c3aa8eeb71bdbd43788
#: getfem.Model.solve:27 of
msgid ""
"select explicitely the line search method used for the linear systems "
"(the default value is 'default'). Possible values are 'simplest', "
"'systematic', 'quadratic' or 'basic'."
msgstr ""

# 302e4b41d59b4e0abcfaf74082927469
#: getfem.Model.solve:31 of
msgid "Return the number of iterations, if an iterative method is used."
msgstr ""

# c2fe6cefa1f446379e12a6abee49c74a
#: getfem.Model.solve:33 of
msgid ""
"Note that it is possible to disable some variables (see "
"Model.disable_variable() ) in order to solve the problem only with "
"respect to a subset of variables (the disabled variables are then "
"considered as data) for instance to replace the global Newton strategy "
"with a fixed point one."
msgstr ""

# dbc8fe858ca241fd80a39a4f4757c950
#: getfem.Model.tangent_matrix:1 of
msgid "Return the tangent matrix stored in the model ."
msgstr ""

# 3dc8e29ca1c24a678c4a9e606a00d307
#: getfem.Model.test_tangent_matrix:1 of
msgid ""
"Synopsis: Model.test_tangent_matrix(self[, scalar EPS[, int NB[, scalar "
"scale]]])"
msgstr ""

# f9745ad7525b4f319ac85cf7594b5b49
#: getfem.Model.test_tangent_matrix:3 of
msgid ""
"Test the consistency of the tangent matrix in some random positions and "
"random directions (useful to test newly created bricks). `EPS` is the "
"value of the small parameter for the finite difference computation of the"
" derivative is the random direction (default is 1E-6). `NN` is the number"
" of tests (default is 100). `scale` is a parameter for the random "
"position (default is 1, 0 is an acceptable value) around the current "
"position. Each dof of the random position is chosen in the range "
"[current-scale, current+scale]."
msgstr ""

# 0d1c01ea1c2947bf92b4ff348a4d9904
#: getfem.Model.test_tangent_matrix_term:1 of
msgid ""
"Synopsis: Model.test_tangent_matrix_term(self, string varname1, string "
"varname2[, scalar EPS[, int NB[, scalar scale]]])"
msgstr ""

# 647b2c0e37ae43f4aa45a5750406650a
#: getfem.Model.test_tangent_matrix_term:3 of
msgid ""
"Test the consistency of a part of the tangent matrix in some random "
"positions and random directions (useful to test newly created bricks). "
"The increment is only made on variable `varname2` and tested on the part "
"of the residual corresponding to `varname1`. This means that only the "
"term (`varname1`, `varname2`) of the tangent matrix is tested. `EPS` is "
"the value of the small parameter for the finite difference computation of"
" the derivative is the random direction (default is 1E-6). `NN` is the "
"number of tests (default is 100). `scale` is a parameter for the random "
"position (default is 1, 0 is an acceptable value) around the current "
"position. Each dof of the random position is chosen in the range "
"[current-scale, current+scale]."
msgstr ""

# c24fe32e348d4f4daf025e76e4f82c58
#: getfem.Model.to_variables:1 of
msgid ""
"Set the value of the variables of the model with the vector `V`. "
"Typically, the vector `V` results of the solve of the tangent linear "
"system (useful to solve your problem with you own solver)."
msgstr ""

# 22bebeeb15e9425d89aae09941d76917
#: getfem.Model.variable:1 of
msgid "Gives the value of a variable or data."
msgstr ""

# f81404a153674194adcc61106c85f4f7
#: getfem.Model.variable_list:1 of
msgid "print to the output the list of variables and constants of the model."
msgstr ""

# 5586f63f376444b192234c767f7e500a
#~ msgid ""
#~ "Adds a source term given by the"
#~ " assembly string `expr` which will be"
#~ " assembled in region `region` and "
#~ "with the integration method `mim`. Only"
#~ " the residual term will be taken "
#~ "into account. Take care that if "
#~ "the expression contains some variables "
#~ "and if the expression is a "
#~ "potential, the expression will be "
#~ "derivated with respect to all variables."
#~ " `brickname` is an otpional name for"
#~ " the brick."
#~ msgstr ""

