# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2004-2017 GetFEM++ project
# This file is distributed under the same license as the GetFEM++ package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: GetFEM++ 5.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-22 15:02+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

# 1d6ccde4532b4fc1861180543a137789
#: ../source/tutorial/wheel.rst:8
msgid ""
"Example of wheel in contact (Assembly between two meshes, "
"transformations, use of fixed size variables)"
msgstr ""

# a4d77229afc945f483a89b3cb182cfcb
#: ../source/tutorial/wheel.rst:10
msgid ""
"In this example of a deformable ''wheel'' enters in contact with a "
"deformable foundation. We use here python interface, translate this "
"program for another interface or in C++ is easy (see the previous "
"example). The complete program  `demo_wheel_contact.py` can be found in "
"the directory `interface/tests/python`."
msgstr ""

# 50b276fcc341424491e0b8700db04e6d
#: ../source/tutorial/wheel.rst:13
msgid "The problem setting"
msgstr ""

# 24d08848a7c5488199c69df1f108bd4e
#: ../source/tutorial/wheel.rst:15
msgid ""
"Let :math:`\\Omega^1 \\subset \\R^2` be the reference configuration of a "
"2D wheel and :math:`\\Omega^2 \\subset \\R^2` the reference configuration"
" of a deformable foundation. We consider small deformation of these two "
"bodies (linearized elasticity) and the contact between them. We also "
"consider that the rim of the wheel is rigid and apply a vertical force on"
" the wheel."
msgstr ""

# 80d3049467164c53bec797a834602cb4
#: ../source/tutorial/wheel.rst:19
msgid "Building the program"
msgstr ""

# 0d270cbe86c541d1ba8f0e279ae89f94
#: ../source/tutorial/wheel.rst:22
msgid "Let us begin by loading Getfem and fixing the parameters of the problem"
msgstr ""

# a0501e90cfff4e04bb3c07fd275773ee
#: ../source/tutorial/wheel.rst:43
msgid "Mesh generation"
msgstr ""

# e7d57069479f4e5785f5de19e95171d4
#: ../source/tutorial/wheel.rst:45
msgid ""
"We consider that the radius of the wheel is 15cm and the one of the rim "
"8cm and that the wheel lies on a deformable foundation of thickness 10cm."
" We generate the mesh of the wheel using the experimental mesher of |gf|."
" Concerning the mesh of the foundation, we build a structured mesh (see "
"the documentation of the Mesh object in the python interface)."
msgstr ""

# d00553a7a7e0441386f60b3b9ef566b4
#: ../source/tutorial/wheel.rst:58
msgid "The result is the following"
msgstr ""

# b31e454b5e4d4c149a9e872932069bfc
#: ../source/tutorial/wheel.rst:66
msgid "Boundary selection"
msgstr ""

# 39acbad2466647a5a389cbb406e83dfe
#: ../source/tutorial/wheel.rst:68
msgid ""
"We have to select the different parts of the boundary where we will set "
"some boundary conditions, namely the boundary of the rim (in order to "
"apply a force and the fact that the rim is rigid), the contact boundary "
"of the wheel and the bottom boundary of the foundation that we will "
"assume clamped."
msgstr ""

# ed3b8970ce3b430484678eac45b6e062
#: ../source/tutorial/wheel.rst:83
msgid ""
"Note that the command `mesh1.outer_faces_with_direction([0., -1.], "
"n.pi/4)` allows to select all the faces having a unit outward normal "
"having an angle less or equal to `n.pi/4` with the vector `[0., -1.]`. "
"The command `mesh1.region_subtract(CONTACT_BOUND, HOLE_BOUND)` allow to "
"delete the faces corresponding to the rim in the contact boundary."
msgstr ""

# ec9c23a6ee3e429c883460d27930be45
#: ../source/tutorial/wheel.rst:86
msgid "Definition of finite elements methods and integration method"
msgstr ""

# c6a81b55145d42a181d88698391f891a
#: ../source/tutorial/wheel.rst:88
msgid ""
"We define `mfu1`, `mfu2` two finite element methods which will "
"approximate the displacements in the wheel and the foundation "
"respectively. `mflambda` is  finite element method to approximate a "
"multiplier to take into account the rigidity of the rim, `mflambda_C` is "
"to approximate the contact multiplier (contact pressure) and `mfvm1`, "
"`mfvm2` will be used to interpolate the Von Mises stresses of the wheel "
"and the foundation for post-processing. `mim1`, `mim2` are two "
"integration methods on the  wheel and the foundation."
msgstr ""

# d882d23b08734cd9bf46d4a2a91977b4
#: ../source/tutorial/wheel.rst:110
msgid "Model definition"
msgstr ""

# a7603dcf788c46ca9f10296ec26bf226
#: ../source/tutorial/wheel.rst:112
msgid ""
"We use a real model and declare the two variables which will represent "
"the displacements:"
msgstr ""

# 26df2fc8d3484f3198ebef416a1ab121
#: ../source/tutorial/wheel.rst:121
msgid "Linearized elasticity bricks"
msgstr ""

# 7385e876a0c049e5b5cfec96a6f900d2
#: ../source/tutorial/wheel.rst:123
msgid ""
"We add the |Lame| coefficients as data of the model and add a linearized "
"elasticity brick for the wheel and the foundation:"
msgstr ""

# 02796ad0ec1b4899b6138080e5cd568b
#: ../source/tutorial/wheel.rst:133
msgid "Clamped condition at the bottom of the foundation"
msgstr ""

# 6ddc764935874d478f9bc5d02b701508
#: ../source/tutorial/wheel.rst:135
msgid ""
"We prescribed the displacement at  bottom face of the foundation to "
"vanish, for instance with a multiplier with the add of the following "
"brick:"
msgstr ""

# 87481a3ffa6a4469a7a80e00a56491a6
#: ../source/tutorial/wheel.rst:142
msgid "Contact condition (use of interpolate transformations)"
msgstr ""

# 25a8d0a65938494ebe6344089a51c7a0
#: ../source/tutorial/wheel.rst:144
msgid ""
"Now, let us see how to prescribed the contact condition between the two "
"structures. It is possible to use predefined bricks (see  :ref:`ud-model-"
"contact-friction` for small deformation/small sliding contact and :ref"
":`ud-model-contact-friction-large` for large deformation/large sliding "
"contact). However, we will see here how to directly prescribe a contact "
"condition using an augmented Lagrangian formulation and the interpolate "
"transformations."
msgstr ""

# c4543f806514490b9a0bcadb996988aa
#: ../source/tutorial/wheel.rst:146
msgid ""
"For small deformation contact, the correspondence between points of one "
"contact surface to the other have to be described on the reference "
"configuration and is not evolving, which is of course simpler but is an "
"approximation."
msgstr ""

# 66407eacbaba48c8a854ce6da35de8c9
#: ../source/tutorial/wheel.rst:148
msgid ""
"We consider that the contact boundary of the wheel is the slave one and "
"we have to describe the transformation from the contact boundary of the "
"wheel to the contact boundary of the foundation. This is quite simple "
"here, since the contact boundary of the foundation corresponds to a "
"vanishing vertical coordinate. So we define the transformation"
msgstr ""

# f78ec8ffe639428095f21e61367b61c2
#: ../source/tutorial/wheel.rst:154
msgid ""
"where :math:`X` is the vector of coordinates of the point. We add this "
"transformation to the model with the command"
msgstr ""

# 120bf88cfc0b4d58819e3d3c307c6a3f
#: ../source/tutorial/wheel.rst:160
msgid ""
"As a consequence, it will be possible to use this transformation, from "
"the mesh of the wheel to the mesh of the foundation, into weak form "
"language expressions. Notes that this is here a very simple constant "
"expression. More complex expressions depending on the data or even the "
"variables of the model can be used. If the expression of a transformation"
" depends on the variable of the model, the tangent linear system will "
"automatically takes into account this dependence (see :ref:`ud-gasm-high-"
"transf` for more details. Note also that transformation corresponding to "
"a large sliding contact and automatically searching for the "
"correspondence between contact boundaries exist in |gf| (see :ref:`ud-"
"model-contact-friction-large-hlgav`)."
msgstr ""

# e63f8bdbbc93425fb8fa31524fabad62
#: ../source/tutorial/wheel.rst:162
msgid ""
"Using the defined transformation, we can write an integral contact "
"condition using an augmented Lagrangian formulation (see :ref:`ud-model-"
"contact-friction` for more details). The corresponding term (to be added "
"to the rest of the weak formulation) reads:"
msgstr ""

# 4980eddbfb3048b49eaad91ccf891973
#: ../source/tutorial/wheel.rst:169
msgid ""
"where :math:`\\Gamma_c` is the slave contact boundary, :math:`\\lambda_N`"
" is the contact multiplier (contact pressure), :math:`h_T` is the radius "
"of the element, :math:`\\Pi` is the transformation, `n` is the outward "
"normal vector to the master contact boundary (here :math:`n = (0,1)`), "
":math:`\\gamma_0` is an augmentation parameter, "
":math:`(\\cdot)_-:I\\hspace{-0.2em}R\\rightarrow I\\hspace{-0.2em}R_+` is"
" the negative part and :math:`\\delta_{\\lambda_N}, \\delta_{u^1}, "
"\\delta_{u^2}` are the test  functions corresponding to "
":math:`\\lambda_N, u^1, u^2`, respectively."
msgstr ""

# 2557e7ecfa5646dab66a7f8353cd5019
#: ../source/tutorial/wheel.rst:171
msgid "Using the weak form language, the contact condition can be added by:"
msgstr ""

# cd2fee0a30b54ac98fb74df315864dac
#: ../source/tutorial/wheel.rst:184
msgid "Prescribing the rigidity of the rim and the vertical force"
msgstr ""

# f437a0b0858c4556b0159acce668af6a
#: ../source/tutorial/wheel.rst:186
msgid ""
"We have now to prescribe the rigidity of the rim. This is a non-standard "
"condition, since we do not know a priori what will be the vertical "
"displacement of the rim. We can use an additional unknown for that "
"vertical displacement. We add an additional fixed size variable `alpha_D`"
" (which mean that it does not a finite element field) of size 1 with"
msgstr ""

# 0e118c92945f412eaf97fc37b559f8f0
#: ../source/tutorial/wheel.rst:192
msgid "We need a multiplier to prescribe the displacement on the rim boundary:"
msgstr ""

# fc256f31d9704fc0b3d8b93f18bccfc2
#: ../source/tutorial/wheel.rst:198
msgid ""
"This multiplier represents the boundary stress that is necessary to "
"prescribe the vertical displacement to be :math`(0, -\\alpha_D)`. The "
"constraint we want to apply on this multiplier is that its integral over "
"the rim boundary is the vertical force we want to apply. The "
"corresponding weak formulation term to be added to the rest of the weak "
"formulation reads"
msgstr ""

# e00d5d802d5f49cea315dcc404214146
#: ../source/tutorial/wheel.rst:204
msgid ""
"where :math:`\\Gamma_D` is the rim boundary, :math:`F` is the applied "
"density of force."
msgstr ""

# 1ec4e2b71d054a7896af690399c70278
#: ../source/tutorial/wheel.rst:206
msgid "This could be added to the model with the weak form language:"
msgstr ""

# d10daf7e7eae42dfb729c842a47f788f
#: ../source/tutorial/wheel.rst:215
msgid "For more robustness, a small penalization on :math:`alpha_D` can be added"
msgstr ""

# 122d2aed12454fe1a81b0e7c2f6dc408
#: ../source/tutorial/wheel.rst:222
msgid ""
"Note that the fixed size variable `alpha_D` is linked to each points of "
"the rim boundary. This means that the line of the tangent matrix "
"corresponding to `alpha_D` may have a lot of nonzero components. This is "
"why such a use of fixed size variable have to be done with care."
msgstr ""

# 65f0cd3725ff43c4bed95cd98210d8aa
#: ../source/tutorial/wheel.rst:225
msgid "Model solve"
msgstr ""

# 6b109bda21d84c3787833c563fdd00aa
#: ../source/tutorial/wheel.rst:227
msgid "We can now solve our problem with:"
msgstr ""

# b41fd4a118e943f69b72518c412d0e36
#: ../source/tutorial/wheel.rst:233
msgid ""
"Note that in some configuration, it is preferable to use a more basic "
"line search than the default one:"
msgstr ""

# a2bd25adbd0c4262b876384ea44f96e6
#: ../source/tutorial/wheel.rst:241
msgid "Export the solution"
msgstr ""

# fd107bb6af1946828c0e171da8d21d8f
#: ../source/tutorial/wheel.rst:243
msgid "Now the code to export the solution with the VonMiss stress:"
msgstr ""

# 342407845bbb4e98935380f2d813593a
#: ../source/tutorial/wheel.rst:270
msgid "Plot of the solution."
msgstr ""

