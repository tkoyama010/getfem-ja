# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2004-2017 GetFEM++ project
# This file is distributed under the same license as the GetFEM++ package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: GetFEM++ 5.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-22 15:02+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

# 8b61e784badc4a05893b05e20be03163
#: ../source/gmm/inside.rst:11
msgid "Deeper inside |gmm|"
msgstr ""

# 2d1d1dc5da5146cbaf29d763310e2e01
#: ../source/gmm/inside.rst:15
msgid "The linalg_traits structure"
msgstr ""

# 0942bcaf3fb54cfe934d88c1822e1aa0
#: ../source/gmm/inside.rst:17
msgid ""
"The major principle of |gmm| is that each vector and matrix type has a "
"corresponding structure (which is never instantiated) named "
"``linalg_traits`` containing all informations on it. For instance, the "
"component ``linalg_type`` of this structure is set to ``abstract_vector``"
" or ``abstract_matrix`` if the corresponding type represent a vector or a"
" matrix. If ``V`` is an interfaced type of vector and ``M`` an interface "
"type of matrix, it is possible to access to this component with::"
msgstr ""

# 5b3a3ba5bcd84d00bc6307d63d8f8a6c
#: ../source/gmm/inside.rst:22
msgid ""
"The types ``abstract_vector`` and ``abstract_matrix`` are defined in "
"``gmm/gmm_def.h``. They are void type allowing to specialize generic "
"algorithms."
msgstr ""

# 7be31967e2c842d586747297932540c9
#: ../source/gmm/inside.rst:24
msgid "For a vector type, the following informations are available::"
msgstr ""

# a86d6f5652474d529519ef5ba0c61c92
#: ../source/gmm/inside.rst:64
msgid "and for a matrix type::"
msgstr ""

# 6206bb8926644344a5eed2f694b4348f
#: ../source/gmm/inside.rst:115
msgid ""
"This is this structure you have to fill in to interface a new vector or "
"matrix type. You can see some examples in ``gmm/gmm_interface.h`` . Most "
"of the generic algorithms are in ``gmm/gmm_blas.h`` ."
msgstr ""

# eaf15d403a374aceb23fbcd8f71a24ff
#: ../source/gmm/inside.rst:119
msgid "How to iterate on the components of a vector"
msgstr ""

# bd7aedbf44ec46a6b5fb0a70508f11f0
#: ../source/gmm/inside.rst:121
msgid ""
"Here is an example which accumulate the components of a vector. It is "
"assumed that ``V`` is a vector type and ``v`` an instantiated vector::"
msgstr ""

# a1bacb007e5647fabe04d466e1fb46df
#: ../source/gmm/inside.rst:134
msgid "This piece of code will work with every kind of interfaced vector."
msgstr ""

# 7f5093ea4be7458b8e42eb16cbf511ab
#: ../source/gmm/inside.rst:136
msgid ""
"For sparse or skyline vectors, it is possible to obtain the index of the "
"components pointed by the iterator with ``it.index()``. Here is the "
"example of the scalar product of two sparse or skyline vectors, assuming "
"``V1`` and ``V2`` are two vector types and ``v1``, ``v2`` two "
"corresponding instantiated vectors::"
msgstr ""

# 3dda2e142bb44805a0e96019b1062b5c
#: ../source/gmm/inside.rst:157
msgid ""
"This algorithm use the fact that indices are increasing in a sparse "
"vector. This code will not work for dense vectors because dense vector "
"iterators do not have the method ``it.index()``."
msgstr ""

# e277cd738076484da05947e0c21f5af7
#: ../source/gmm/inside.rst:160
msgid "How to iterate on a matrix"
msgstr ""

# 480449159ccb4fc0be3da1ee7efe413e
#: ../source/gmm/inside.rst:162
msgid ""
"You can iterate on the rows of a matrix if it is not a column major "
"matrix and on the columns of a matrix if it is not a row major matrix "
"(the type ``gmm::dense_matrix<T>`` has is sub orientation type as "
"col_and_rox, so you can iterate on both rows and columns)."
msgstr ""

# 1fa83fdb74d24d4a87ccb4289476564a
#: ../source/gmm/inside.rst:164
msgid "If you need not to be optimal, you can use a basic loop like that::"
msgstr ""

# bd42aa15c58941be94785a7e8d0554fa
#: ../source/gmm/inside.rst:174
msgid "But you can also use iterators, like that::"
msgstr ""

# 0de69b2abc4c43669e1e1304060c183e
#: ../source/gmm/inside.rst:190
msgid "How to make your algorithm working on all type of matrices"
msgstr ""

# 1aae72df778d492cb00721eeff31a79e
#: ../source/gmm/inside.rst:192
msgid ""
"For this, you will generally have to specialize it. For instance, let us "
"take a look at the code for ``gmm::nnz`` which count the number of stored"
" components (in fact, the real ``gmm::nnz`` algorithm is specialized in "
"most of the cases so that it does not count the components one by one)::"
msgstr ""

# edc9a34ffd76490cbbb7b153d3c676f1
#: ../source/gmm/inside.rst:226
msgid ""
"The first function dispatch on the second or the third function "
"respectively if the parameter is a vector or a matrix. The third function"
" dispatch again on the fourth and the fifth function respectively if the "
"matrix is row_major or column major. Of course, as the function are "
"declared ``inline``, at least the two dispatcher functions will not be "
"implemented. Which means that this construction is not costly."
msgstr ""

