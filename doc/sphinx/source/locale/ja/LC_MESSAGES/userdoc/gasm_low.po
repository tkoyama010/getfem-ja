# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2004-2017 GetFEM++ project
# This file is distributed under the same license as the GetFEM++ package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: GetFEM++ 5.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-22 15:02+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

# 05d38800154c46cc908a70f897fe99ac
#: ../source/userdoc/gasm_low.rst:12
msgid "Compute arbitrary terms - low-level generic assembly procedures"
msgstr "任意の用語を計算する - 低レベルの一般的なアセンブリ手順\n"

# e10468c926574c5881402d24f7e8a859
#: ../source/userdoc/gasm_low.rst:14
msgid ""
"This section present the first version of generic assembly procedure which "
"has been implemented in |gf|. It allows to easily make the assembly of "
"arbitrary matrices in the linear case. In the nonlinear case, some special "
"\"non_linear_term\" object have to be implemented, which could be a bit "
"tricky and obliges to use very low-level internal tools of |gf|. The high-"
"level generic assembly has been developped to circumvent these difficulties "
"(see :ref:`ud-gasm-high`)."
msgstr ""
"このセクションでは、| gf "
"|で実装された汎用アセンブリプロシージャの最初のバージョンを示します。それは、線形の場合に任意の行列の集合を容易に作ることを可能にする。非線形の場合、特殊な"
" \"non_linear_term\"オブジェクトを実装する必要があります。これはややこしいかもしれませんし、| gf "
"|という非常に低レベルの内部ツールを使用する必要があります。高レベルジェネリックアセンブリは、これらの困難を回避するために開発されました（ref： "
"`ud-gasm-high`参照）。\n"

# 25d0d3c983714e668a0fb92d0dd95309
#: ../source/userdoc/gasm_low.rst:16
msgid ""
"As it can be seen in the file :file:`getfem/getfem_assembling.h`, all the "
"previous assembly procedures use a |gf_gasm| object and provide it an "
"adequate description of what must be done. For example, the assembly of a "
"volumic source term for a scalar FEM is done with the following excerpt of "
"code::"
msgstr ""
"ファイル：file： `getfem / getfem_assembling.h`で見ることができるように、以前のアセンブリプロシージャはすべて| "
"gf_gasm "
"|どのようにしなければならないかについての適切な記述を提供する。例えば、スカラーFEMのためのボリューム源用語のアセンブリは、コードの以下の抜粋を用いて行われる。\n"

# 1c00be1af1a84a1d98a0f660c8d219b8
#: ../source/userdoc/gasm_low.rst:31
msgid ""
"The first instructions declare the object, and set the data that it will "
"use: a |mim| object which holds the integration methods, two |mf| objects, "
"the input data ``F``, and the destination vector ``B``."
msgstr ""
"最初の命令はオブジェクトを宣言し、使用するデータを設定します：a | mim |統合メソッドを保持するオブジェクト、2つの| mf "
"|オブジェクト、入力データ「F」、および宛先ベクトル「B」を含む。\n"

# fc736824d6c64ee0b5054346126642ff
#: ../source/userdoc/gasm_low.rst:35
msgid ""
"The input data is the vector :math:`F`, defined on ``mfdata``. One wants to "
"evaluate :math:`\\sum_{j} f_j (\\int_\\Omega \\phi^i \\psi^j)`. The "
"instruction must be seen as something that will be executed for each convex "
"``cv`` of the mesh. The terms ``#1`` and ``#2`` refer to the first |mf| and "
"the second one (i.e. ``mf`` and ``mfdata``).  The instruction "
"``Z=data(#2);`` means that for each convex, the \"tensor\" ``Z`` will "
"receive the values of the first data argument provided with ``push_data``, "
"at indexes corresponding to the degrees of freedom attached to the convex of"
" the second (``#2``) |mf| (here, ``Z = F[mfdata.ind_dof_of_element(cv)]``."
msgstr ""
"入力データは、ベクトル：math： `F`で、` `mfdata``で定義されます。 1つは評価することです：数学： `\\ sum_ {j} "
"f_j（\\ int_ \\ Omega \\ phi ^ i \\ psi ^ j）`。命令は、メッシュの凸状の `` "
"cv``ごとに実行されるものとみなされなければなりません。用語「＃1」および「＃2」は、最初の| mf | 2つ目は `` mf``と `` "
"mfdata``です。 `` Z = data（＃2）; ``は、それぞれの凸部について、 `` "
"push_data``で与えられた最初のデータ引数の値を、 `` push_data``に対応するインデックスで受け取ることを意味します。 "
"2番目の（＃2）の凸部に付けられた自由度| mf | （ここでは `` Z = F [mfdata.ind_dof_of_element（cv）] "
"``となります。\n"

# cfdc64582799405792c88d5af3335ac1
#: ../source/userdoc/gasm_low.rst:45
msgid ""
"The part ``V(#1)+=...`` means that the result of the next expression will be"
" accumulated into the output vector (provided with ``push_vec``). Here "
"again, ``#1`` means that we will write the result at indexes corresponding "
"to the degrees of freedom of the current convex with respect to the first "
"(``#1``) |mf|."
msgstr ""
"`` V（＃1）+ = ... ``という部分は、次の式の結果が出力ベクトルに蓄積されることを意味します（ `` "
"push_vec``で提供されます）。ここでもまた、「＃1」は、最初の（「＃1」）| mf "
"|に関して、現在の凸の自由度に対応するインデックスに結果を書き込むことを意味します。\n"

# 3cb09d5ad22f4c04af73b5e39458bf7e
#: ../source/userdoc/gasm_low.rst:50
msgid ""
"The right hand side ``comp(Base(#1).Base(#2))(:,j).Z(j)`` contains two "
"operations. The first one is a computation of a tensor on the convex: "
"``comp(Base(#1).Base(#2))`` is evaluated as a 2-dimensions tensor, "
":math:`\\int\\phi^i \\psi^j`, for all degrees of freedom :math:`i` of ``mf``"
" and :math:`j` of ``mfdata`` attached to the current convex. The next part "
"is a reduction operation, ``C(:,j).Z(j)``: each named index (here :math:`j`)"
" is summed, i.e. the result is :math:`\\sum_j c_{i,j} z_j`."
msgstr ""
"右側の `` comp（Base（＃1）.Base（＃2））（:, j）.Z（j） "
"``には2つの操作が含まれています。最初のものは、凸面のテンソルの計算です： `` comp（Base（＃1）.Base（＃2）） "
"``は2次元のテンソルとして評価されます：math： `\\ int \\ phi ^ i \\ psi ^ "
"j`をすべての自由度について計算します：math： `` mf``と：現在の凸面に付けられた `` mfdata``の `` math： "
"`j``。次の部分はリダクション演算で、 `` C（：、j）.Z（j） ``です：それぞれの指数（ここではmath： `j`）を合計します。 {i、j}"
" z_j`である。\n"

# 06eee08ff0f34caba45e7c8604195467
#: ../source/userdoc/gasm_low.rst:58
msgid ""
"The integration method used inside ``comp(Base(#1).Base(#2))`` is taken from"
" ``mim``. If you need to use integration methods from another |mim| object, "
"you can specify it as the first argument of ``comp``, for example "
"``comp(\\%2, Base(#1).Grad(#2))`` will use the second |mim| object (New in "
"getfem++-2.0)."
msgstr ""
"`` comp（Base（＃1）.Base（＃2）） ``の内部で使用される統合方法は `` mim``からとられています。別の| mim "
"|から統合メソッドを使用する必要がある場合は、例えば、 `` comp（\\％2、Base（＃1）.Grad（＃2）） ``のように `` "
"comp``の最初の引数として指定することができます。オブジェクト（getfem ++  -  2.0の新機能）。\n"

# a0314a1793b3428fb6dddfc142c9dab5
#: ../source/userdoc/gasm_low.rst:63
msgid ""
"An other example is the assembly of the stiffness matrix for a vector "
"Laplacian::"
msgstr "他の例は、ベクトルLaplacian ::\n"

# a700155d5ea647c69ffccdae20d46299
#: ../source/userdoc/gasm_low.rst:75
msgid ""
"Now the output is written in a sparse matrix, inserted with "
"``assem.push_mat(SM)``. The ``$1`` in ``M$1(#1,#1)`` just indicates that we "
"refer to the first matrix \"pushed\" (it is optional, but if the assembly "
"builds two matrices, the second one must be referred this way). The ``sym`` "
"function ensure that the result is symmetric (if this is not done, some "
"round-off errors may cancel the symmetricity, and the assembly will be a "
"little bit slower). Next, the ``comp`` part evaluates a 7D tensor,"
msgstr ""
"出力は、 `` assem.push_mat（SM） ``で挿入された疎行列に書き出されます。 `` $ 1（＃1、＃1） ``の `` $ "
"1``は最初の行列を \"push\"していることを示しています（オプションですが、アセンブリが2つの行列を構築するならば、このように言及した）。 ``"
" sym``関数は、結果が対称であることを保証します（これが行われないと、いくつかの丸め誤差が対称性を取り消し、アセンブリが少し遅くなります）。次に、 "
"`` comp``部分は7Dテンソルを評価し、\n"

# 0049993f9ffd4a0b94bbd598fc6bc6e4
#: ../source/userdoc/gasm_low.rst:87
msgid ""
"where :math:`\\varphi^i_j` is a :math:`jth` component of the :math:`ith` "
"base function of ``mf`` and :math:`\\psi^p` is a (scalar) base function of "
"the second |mf|. Since we want to assemble"
msgstr ""
"ここで、math： `\\ varphi ^ i_j`は` `mf``のmath：` iith`の基底関数のmath： `jth`成分で、math：` "
"\\ psi ^ p`は（スカラー） 2番目の| mf |の基本関数アセンブルしたいので\n"

# bd96ef53b4704003bd239ed004d3bf9f
#: ../source/userdoc/gasm_low.rst:97
msgid "the reduction is:"
msgstr "削減は次のとおりです。\n"

# 4fe8092c89274e67b410b08097990d21
#: ../source/userdoc/gasm_low.rst:105
msgid ""
"In the ``comp`` function, ``vGrad`` was used instead of ``Grad`` since we "
"said that we were assembling a *vector* Laplacian: that is why each "
"``vGrad`` part has three dimensions (dof number, component number, and "
"derivative number). For a scalar Laplacian, we could have used "
"``comp(Grad(#1).Grad(#1).Base(#2))(:,k,:,k,p).a(p)``. But the vector form "
"has the advantage to work in both vector and scalar case."
msgstr ""
"`` comp``関数で `` Grad``の代わりに `` vGrad``が使われました。なぜなら、私たちは* vector * "
"Laplacianをアセンブルしていると言っていたからです。そのため、それぞれの `` "
"vGrad``部分は3次元dof番号、コンポーネント番号、および派生番号）。スカララプラシアンの場合、 `` "
"comp（Grad（＃1）.Grad（＃1）.Base（＃2））（:, k、：、k、p）.a（p） "
"``を使うことができました。しかし、ベクトル形式は、ベクトルとスカラーの両方の場合に機能する利点があります。\n"

# 0a78e805e03446c29e8dc05aa5f0bd14
#: ../source/userdoc/gasm_low.rst:112
msgid ""
"The last instruction, ``assem.assembly()``, does evaluate the expression on "
"each convex. For an assembly over a boundary just call "
"``assem.assembly(rg)``, where ``rg`` is a |gf_mr| object.  ``rg`` might also"
" be a number, in that case the mesh region taken into account is "
"``mim.linked_mesh().region(rg)``."
msgstr ""
"最後の命令である `` assem.assembly（） ``は、各凸型の式を評価します。境界を越えてアセンブリを呼び出すには、 `` "
"assem.assembly（rg） ``を呼び出します。ここで `` rg``は| gf_mr |オブジェクト。 `` "
"rg``も数値であるかもしれません。その場合メッシュ領域は `` mim.linked_mesh（）。region（rg） ``です。\n"

# 6387c4c83b6743e0bccb476ad6bec49d
#: ../source/userdoc/gasm_low.rst:117
msgid ""
"The third example shows how to compute the :math:`L^2` norm of a scalar or "
"vector field on a mesh boundary::"
msgstr "3番目の例は、メッシュ境界上のスカラーまたはベクトルフィールドの：math： `L ^ 2`ノルムを計算する方法を示しています::\n"

# afc8734d1605472cb1a79e8bbcbc2419
#: ../source/userdoc/gasm_low.rst:129
msgid ""
"This one is easy to read. When ``assembly`` returns, ``v[0]`` will contain"
msgstr "これは読みやすいです。 `` assembly``が返ってくるとき、 `` v [0] ``は\n"

# 27bc9ecad1b14e018a59bedb416ecd88
#: ../source/userdoc/gasm_low.rst:135
msgid ""
"The fourth and last example shows an (sub-optimal) assembly of the linear "
"elasticity problem with a complete Hooke tensor::"
msgstr "4番目と最後の例は、完全なHookeテンソルによる線形弾性問題の（準最適な）アセンブリを示しています::\n"

# be03157285c045d69e4d4dd3d31c64af
#: ../source/userdoc/gasm_low.rst:143
msgid "The original equations are:"
msgstr "元の方程式は次のとおりです。\n"

# 4145839b57cc454093c1e2946d771e86
#: ../source/userdoc/gasm_low.rst:151
msgid ""
"where :math:`h` is the Hooke tensor, and :math:`:` means the scalar product "
"between matrices. Since we assume it is not constant, :math:`h` is given on "
"the second |mf|: :math:`h_{ijkl}(x)=\\sum_p h_{ijkl}^p \\psi^p`. Hence the "
"first line declares that the first data \"pushed\" is indeed a five-"
"dimensions tensor, the first fourth ones being all equal to the target "
"dimension of the first |mf|, and the last one being equal to the number of "
"degrees of freedom of the second |mf|. The ``comp`` part still computes the "
"same 7D tensor than for the vector Laplacian case. From this tensor, one "
"evaluates "
":math:`\\varepsilon(\\varphi^i)_{jk}\\varepsilon(\\phi^l)_{mn}\\psi^p` via "
"permutations, and finally the expression is reduced against the hook tensor."
msgstr ""
"math： `h`はHookeテンソル、そして：math：`： `は行列間のスカラ積を意味します。定数ではないと仮定しているので、第2の| mf | "
":: math： `h_ {ijkl}（x）= \\ sum_p h_ {ijkl} ^ p \\ psi ^ p`に数学：` "
"h`が与えられます。したがって、最初の行は、最初のデータが実際に5次元のテンソルであることを宣言します。最初の4番目のものはすべて最初の| mf "
"|のターゲット次元に等しく、最後のものは次の次元数に等しくなります。第2の自由| mf |。 `` "
"comp``部分はベクトルラプラシアンの場合と同じ7Dテンソルを計算します。このテンソルから、順列を使って数学： `\\ varepsilon（\\ "
"varphi ^ i）_ {jk} \\ varepsilon（\\ phi ^ l）_ {mn} \\ psi ^ "
"p`を評価し、最後に表現はフックテンソル。\n"

# b567c66251c342a883c3ab26884f4438
#: ../source/userdoc/gasm_low.rst:164
msgid "available operations inside the ``comp`` command"
msgstr "`` comp``コマンドの中で利用可能な操作\n"

# 4a11120cbb754ee887ccdc6457ec9a5f
#: ../source/userdoc/gasm_low.rst:166
msgid ""
"``Base(#i)``: evaluate the value of the base functions of the *ith* |mf|"
msgstr "`` Base（#i） ``：* ith * | mf |の基本関数の値を評価する。\n"

# af368ea347d24eaba9c713b68db88089
#: ../source/userdoc/gasm_low.rst:168
msgid ""
"``Grad(#i)``: evaluate the value of the gradient of the base functions of "
"the *ith* |mf|"
msgstr "`` Grad（#i） ``：* ith * | mf |の基本関数の勾配の値を評価します。\n"

# aa7b414087be4733a3824cec98271a5a
#: ../source/userdoc/gasm_low.rst:171
msgid ""
"``Hess(#i)``: evaluate the value of the Hessian of the base functions of the"
" *ith* |mf|"
msgstr "`` Hess（#i） ``：* ith * | mf |の基本関数のヘッセ行列の値を評価する。\n"

# 8f27d7214a0046ea9fbd09fc231218dd
#: ../source/userdoc/gasm_low.rst:174
msgid ""
"``Normal()``: evaluate the unit normal (should not be used for volumic "
"integrations !)"
msgstr "`` Normal（） ``：単位法線を評価します（ボリューム積分には使用しないでください）。\n"

# 08f0f56ee9064e5580bced7286792ddf
#: ../source/userdoc/gasm_low.rst:177
msgid ""
"``NonLin$x(#mf1,... #mfn)``: evaluate the *xth* non-linear term (inserted "
"with ``push_nonlinear_term(pnonlinear_elem_term)``) using the listed |mf| "
"objects."
msgstr ""
"`` NonLin $ x（＃mf1、... #mfn） ``： `` "
"push_nonlinear_term（pnonlinear_elem_term） ``で挿入された* xth *非線形項を、リストされた| mf "
"|オブジェクト。\n"

# c13c4620d9f44d1e96aa7cd08eedc8dd
#: ../source/userdoc/gasm_low.rst:181
msgid ""
"``GradGT()``, ``GradGTInv()``: evaluate the gradient (and its inverse) of "
"the geometric transformation of the current convex."
msgstr "`` GradGT（） ``、 `` GradGTInv（） ``：現在の凸部の幾何学的変換の勾配（およびその逆数）を評価します。\n"

# d390b423646341e89c238bf32c7411f7
#: ../source/userdoc/gasm_low.rst:186
msgid ""
"you may reference any data object inside the ``comp`` command, and perform "
"reductions inside the ``comp()``. This feature is mostly interesting for "
"speeding up assembly of nonlinear terms (see the file "
":file:`getfem/getfem_nonlinear_elasticity.h` for an example of use)."
msgstr ""
"あなたは `` comp``コマンドの中の任意のデータオブジェクトを参照し、 `` comp（） "
"``の中で縮小を実行することができます。この機能は、非線形項の組み立てを高速化するために大いに興味深い（ファイル：file： `getfem / "
"getfem_nonlinear_elasticity.h`の使用例を参照）。\n"

# f6e681cf028d4c6389a1c8cec45a59f6
#: ../source/userdoc/gasm_low.rst:193
msgid "others operations"
msgstr "他の操作\n"

# 54caeca1625f405eb907a72747f777bf
#: ../source/userdoc/gasm_low.rst:195
msgid ""
"Slices may be mixed with reduction operations ``t(:,4,i,i)`` takes a slice "
"at index 4 of the second dimension, and reduces the diagonal of dimension 3 "
"and 4. *Please note that index numbers for slices start at 1 and not 0 !!*"
msgstr ""
"スライスは縮小演算と混在することがあります。 `` t（：、4、i、i） "
"``は第2次元のインデックス4でスライスをとり、次元3と4の対角を縮小します。*スライスのインデックス番号1ではなく0で始まる!! *\n"

# 313ab559c12d446ca006b965d1a85d3d
#: ../source/userdoc/gasm_low.rst:199
msgid ""
"``mdim(#2)`` is evaluated as the mesh dimension associated to the second "
"|mf|, while ``qdim(#2)`` is the target dimension of the |mf|."
msgstr ""
"`` mdim（＃2） ``は第2の| mf |に関連するメッシュ次元として評価され、 `` qdim（＃2） `'は| mf |の目標次元です。\n"

# f6742804d9be4a5b9f8b1d29899916f3
#: ../source/userdoc/gasm_low.rst:202
msgid ""
"The diagonal of a tensor can be obtained with ``t{:,:,3,3}`` (which is "
"strictly equivalent to ``t{1,2,3,3}``: the colon is just here to improve the"
" readability). This is the same operator than for permutation operations. "
"Note that ``t{:,:,1,1}`` or ``t{:,:,4,4}`` are not valid operations."
msgstr ""
"テンソルの対角は、 `` {{、}、3,3} ``（厳密には `` {1,2,3,3} "
"`と同等です）で得ることができます。読みやすさを向上させる）。これは、並べ替え操作と同じ演算子です。 `` {：、：、1,1} ``や `` "
"{：、：、4,4} ``は有効な操作ではないことに注意してください。\n"

# ba3399b0f9aa4f16873d80d8c7eefebd
#: ../source/userdoc/gasm_low.rst:207
msgid ""
"The ``print`` command can be used to see the tensor: ``\"print "
"comp(Base(#1));\"`` will print the integrals of the base functions for each "
"convex."
msgstr ""
"`` print``コマンドは、テンソルを見るために使うことができます： `` `print comp（Base（＃1））;` "
"``は各凸部の基底関数の積分を出力します。\n"

# 185319c358cd43479ed27783037ad3fb
#: ../source/userdoc/gasm_low.rst:210
msgid ""
"If there is more than one data array, output array or output sparse matrix, "
"one can use ``data$2``, ``data$3, ``V$2``, ``M$2``,..."
msgstr ""
"2つ以上のデータ配列、出力配列または出力スパース行列がある場合、 `` data $ 2``、 `` data $ 3``、 `V $ 2``、` `M"
" $ 2``などを使用できます。\n"

# 3d1fa54f753a46a899134c2f6272d4ab
#: ../source/userdoc/gasm_low.rst:7
msgid "asm"
msgstr "asm\n"

# 3d1fa54f753a46a899134c2f6272d4ab
#: ../source/userdoc/gasm_low.rst:7
msgid "generic assembly"
msgstr "ジェネリックアセンブリ\n"
