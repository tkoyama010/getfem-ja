# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2004-2017 GetFEM++ project
# This file is distributed under the same license as the GetFEM++ package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: GetFEM++ 5.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-22 15:02+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

# a551147aabac4a44a9404636c1b7d5d0
#: ../source/userdoc/model_contact_friction_large_sliding.rst:12
msgid "Large sliding/large deformation contact with friction bricks"
msgstr ""

# 43e8a10294154df09972cddeb4f0906d
#: ../source/userdoc/model_contact_friction_large_sliding.rst:14
msgid ""
"The basic tools to deal with large sliding/large deformation contact of "
"deformable structures are accessible in the weak form language. Some "
"interpolate transformations (see :ref:`ud-gasm-high-transf`) are defined "
"to perform the contact detection and allow to integrate from a contacct "
"bondary to the opposite contact boundary. Some other useful tools such as"
" the unit normal vector in the real configuration and projections to take"
" into account contact with Coulomb friction are also defined as operators"
" in the weak form language."
msgstr ""

# 02b9ec9324b9445a9db4e0f734b5fe34
#: ../source/userdoc/model_contact_friction_large_sliding.rst:16
msgid ""
"Of course, the computational cost of large sliding/large deformation "
"contact algorithms is greatly higher than small sliding-small deformation"
" ones."
msgstr ""

# dda28d28e2fa40e5baed0564d2046c98
#: ../source/userdoc/model_contact_friction_large_sliding.rst:21
msgid "Raytracing interpolate transformation"
msgstr ""

# d7fb506920ca47cb953690a964f1bb15
#: ../source/userdoc/model_contact_friction_large_sliding.rst:23
msgid ""
"In order to incorporate the contact detection in the high-level generic "
"assembly, a specific interpolate transformation has been defined (see "
":ref:`ud-gasm-high-transf` for more explanations on interpolate "
"tranformations). It is based on a raytracing contact detection has "
"described in [KO-RE2014]_ and uses the criteria described below. The "
"interpolate transformation stores the different potential contact "
"surfaces. On most of methods, potential contact surface are classified "
"into two categories: master and slave surface (see  :ref:`figure<ud-fig-"
"masterslave>`)."
msgstr ""

# b3bd7777770c4ac2b5a60f58f1421809
#: ../source/userdoc/model_contact_friction_large_sliding.rst:31
msgid ""
"The slave surface is the \"contactor\" and the master one the \"target\"."
" Rigid obstacle are also considered. They are always master surfaces.  "
"The basic rule is that the contact is considered between a slave surface "
"and a master one. However, the multi-contact frame object and the |gf| "
"bricks allow multi-contact situations, including contact between two "
"master surfaces, self-contact of a master surface and an arbitrary number"
" of slave and master surfaces."
msgstr ""

# d1de858e681840eb950e749744951648
#: ../source/userdoc/model_contact_friction_large_sliding.rst:33
msgid ""
"Basically, in order to detect the contact pairs, Gauss points or f.e.m. "
"nodes of slave surfaces are projected on master surfaces (see  "
":ref:`figure<ud-fig-masterslave>`). If self-contact is considered, Gauss "
"points or f.e.m. nodes of master surface are also projected on master "
"surfaces."
msgstr ""

# cee1e9f9dbf0462e9a1b8b5ca3fe9c38
#: ../source/userdoc/model_contact_friction_large_sliding.rst:36
msgid "The addition of a raytracing transformation to a model::"
msgstr ""

# f726ba6595194c80ad300dbcabbb5451
#: ../source/userdoc/model_contact_friction_large_sliding.rst:41
msgid ""
"where ``transname`` is a name given to the transformation which allows to"
" refer to it in the weak form language and ``d`` is the release distance "
"(see above)."
msgstr ""

# 91bfe8a7def543b9b198cf684fa8fedc
#: ../source/userdoc/model_contact_friction_large_sliding.rst:43
msgid ""
"The raytracing transformation is added without any slave or master "
"contact boundary. The following functions allows to add some boundaries "
"to the transformation::"
msgstr ""

# 751b85236bab4f4bb91399ac4394edad
#: ../source/userdoc/model_contact_friction_large_sliding.rst:53
msgid ""
"where ``dispname`` is the variable name which represent the displacement "
"on that contact boundary. The difference between master and slave contact"
" boundary is that the contact detection is to be performed starting from "
"a slave or master boundary toward a master boundary. The contact "
"detection is not performed toward a slave boundary. Consequently, only "
"the influence boxes of the elements of the master surfaces are computed "
"and stored."
msgstr ""

# 41efe987e96c4a55ae6d524e70f4de90
#: ../source/userdoc/model_contact_friction_large_sliding.rst:56
msgid ""
"It is also possible to add a rigid obstacle (considered as a master "
"surface) thanks to the function::"
msgstr ""

# 1d0f5b708c7d4a92990e5f719c1d9b4a
#: ../source/userdoc/model_contact_friction_large_sliding.rst:62
msgid ""
"where ``expr`` is the expression of a signed distance to the obstacle "
"using the syntax of the weak form language (``X`` being the current "
"position, ``X(0)``, ``X(1)`` ... the corresponding components). For "
"instance an expression ``X(0) + 5`` will correspond to a flat obstacle "
"lying on the right of the position ``-5`` of the first coordinate. Be "
"aware that the expression have to be close to a signed distance, which in"
" particular means that the gradient norm have to be close to 1."
msgstr ""

# 27388bc003e04eef8211f357e1d4adee
#: ../source/userdoc/model_contact_friction_large_sliding.rst:64
msgid ""
"In order to distinguish between non-contact situations and the occurence "
"of a contact with another deformable body or with a rigid obstacle, the "
"transformation returns an integer identifiant which can be used by the "
"`Interpolate_filter` command of the weak form language (see :ref:`ud-"
"gasm-high-transf`). The different values:"
msgstr ""

# 4eb77021be4e464cafcbd5a235a52b17
#: ../source/userdoc/model_contact_friction_large_sliding.rst:66
msgid "0 : no contact found on this Gauss point"
msgstr ""

# 203e80fee96142e0b0b9db6a9b70cc5d
#: ../source/userdoc/model_contact_friction_large_sliding.rst:68
msgid "1 : contact occurs on this Gauss point with a deformable body"
msgstr ""

# 05ef14732d24443da9339821a9e27afb
#: ../source/userdoc/model_contact_friction_large_sliding.rst:70
msgid "2 : contact occurs on this Gauss point with a rigid obstacle."
msgstr ""

# c80622fdb5194f01a796b793509af448
#: ../source/userdoc/model_contact_friction_large_sliding.rst:72
msgid ""
"such that it is possible to differentiate the treatment of these three "
"cases using::"
msgstr ""

# ff174fbb5dd347c3bbfb458869e6faa1
#: ../source/userdoc/model_contact_friction_large_sliding.rst:78
msgid ""
"in the weak form language, where ``expr1``, ``expr2`` and ``expr3`` "
"correspond to the different terms to be computed. The matlab interface "
"demo program :file:`/interface/tests/matlab/demo_large_sliding_contact.m`"
" presents an example of use."
msgstr ""

# a02141be8a0c41b0a08894e6e5485ccf
#: ../source/userdoc/model_contact_friction_large_sliding.rst:80
msgid ""
"Note that the transformation could also be directly used with a "
"`ga_workspace` object if model object are not used. See "
":file:`getfem/getfem_contact_and_friction_common.h` for more details. "
"Note also that in the framework of the model object, a interfaced use of "
"this transformation is allowed by the model bricks described below."
msgstr ""

# df8f3503957f45069d4c72b51cf10330
#: ../source/userdoc/model_contact_friction_large_sliding.rst:84
msgid "The contact pair detection algorithm"
msgstr ""

# 5165150bfd444ae6bec3023b726f6066
#: ../source/userdoc/model_contact_friction_large_sliding.rst:86
msgid ""
"A contact pair is formed by a point of a slave (or master in case of "
"self-contact) surface and a projected point on the nearest master surface"
" (or rigid obstacle). The Algorithm used is summerized in :ref:`figure"
"<ud-fig-algodetect>`"
msgstr ""

# 590619ac429d45c0b18f8c452c1a8383
#: ../source/userdoc/model_contact_friction_large_sliding.rst:95
msgid ""
"It is impossible to distinguish without fail between valid and invalid "
"contact situations without a global topological criterion (such as in "
"[Pantz2008]_), a fortiori for self-contact detection. However, this kind "
"of criterion can be very costly to implement. Thus, one generally "
"implements some simple heuristic criteria which cannot cover all the "
"possible cases. We present such a set of criteria here. They are of "
"course perfectible and subject to change. First, in :ref:`figure<ud-fig-"
"invalidcontact>` one can see a certain number of situations of valid or "
"invalid contact that criteria have to distinguish."
msgstr ""

# 3853fe3f10bc4798ac720feb34a86d53
#: ../source/userdoc/model_contact_friction_large_sliding.rst:109
msgid "Some details on the algorithm:"
msgstr ""

# 214cd2a0a27548118d18b620788ea05c
#: ../source/userdoc/model_contact_friction_large_sliding.rst:111
msgid ""
"**Computation of influence boxes.** The influence box of an element is "
"just an offset to its bounding box at a distance equal to the release "
"distance. If this strategy is used, the release distance should not be "
"too large compared to the element size. Otherwise, a point would "
"correspond to a a large number of influence box which can considerably "
"slow down the search of contact pairs. The influence boxes are stored in "
"a region tree object in order to find the boxes containing a point with "
"an algorithm having a mean complexity in :math:`O(log(N))`."
msgstr ""

# aa4e56baa1d4460b99663c36e8499465
#: ../source/userdoc/model_contact_friction_large_sliding.rst:120
msgid ""
"**What is a potential contact pair.** A potential contact pair is a pair "
"slave point - master element face which will be investigated. The "
"projection of the slave point on the master surface will be done and "
"criteria will be applied."
msgstr ""

# a0e645ea788047208596153a09b368c3
#: ../source/userdoc/model_contact_friction_large_sliding.rst:125
msgid ""
"**Projection algorithm.** The projection of the slave point onto a master"
" element face is done by a parametrization of the surface on the "
"reference element via the geometric transformation and the displacement "
"field. During the projection, no constraint is applied to remain inside "
"the element face, which means that the element face is prolongated "
"analytically. The projection is performed by minimizing the distance "
"between the slave point and the projected one using the parametrization "
"and Newton's and/or BFGS algorithms. If ``raytrace`` is set to true, then"
" no projection is computed. Instead a ray tracing from the point x in the"
" direction of the unit normal vector at x to find y. This means the "
"reverse of the usual situation (x will be the projection of y)."
msgstr ""

# 864ddd67cee440e08461e60f1ffa2813
#: ../source/userdoc/model_contact_friction_large_sliding.rst:137
msgid "The list of criteria:"
msgstr ""

# 2cc7795cc0934383b14d15364d557243
#: ../source/userdoc/model_contact_friction_large_sliding.rst:139
msgid ""
"**Criterion 1: the unit normal cone/vector should be compatible, and the "
"two points do not share the same element.** Two unit normal vector are "
"compatible if their scalar product are non-positive. In case of f.e.m. "
"node contact, since a fem node is shared generally by several elements, a"
" normal cone constituted of the unit normal vectors of each element is "
"considered. Two normal cones are compatible if at least one pair of unit "
"normal vector have their scalar product non-positive. In order to "
"simplify the computation, a normal cone is reduced to a mean normal "
"vector if the solid angle of the normal cone is less than ``cut_angle`` a"
" parameter of the multi-contact frame object. This criterion allows to "
"treat cases (B) and (K1)."
msgstr ""

# a64a21cd1f364e5889361b2413ef6919
#: ../source/userdoc/model_contact_friction_large_sliding.rst:151
msgid ""
"**Criterion 2: the contact pair is eliminated when the search of the "
"projection/raytrace point do not converge.** When Newton's algorithms "
"(and BFGS one for projection) used to compute the projection/raytrace of "
"the slave point on the master element surface fails to converge, the pair"
" is not considered. A warning is generated."
msgstr ""

# 363d34dd691f415ca6f915a4a0a67ef0
#: ../source/userdoc/model_contact_friction_large_sliding.rst:157
msgid ""
"**Criterion 3 : the projected point should be inside the element.** The "
"slave point is projected on the surface of the master element without the"
" constraint to remain inside the face (which means that the face is "
"prolongated). If the orthogonal projection is outside the face, the pair "
"is not considered. This is the present state, however, to treat case (J3)"
" an aditional treatment will have to be considered (projection on the "
"face with the constraint to remain inside it and test of the normal cone "
"at this point) This criterion allows to treat cases (F2), (K2), (M1) and "
"(M2)."
msgstr ""

# 5a9240012e454322ae7f134c1d7eab99
#: ../source/userdoc/model_contact_friction_large_sliding.rst:168
msgid ""
"**Criterion 4 : the release distance is applied.** If the distance "
"between the slave point and its projection on the master surface is "
"greater than the release distance, the contact pair is not considered. "
"This can treat cases (C), (E), (F1), (G), (H) if the release distance is "
"adapted and the deformation not too important."
msgstr ""

# 68a1608e6197458cabbed44a8d2f6816
#: ../source/userdoc/model_contact_friction_large_sliding.rst:174
msgid ""
"**Criterion 5 : comparison with rigid obstacles.** If the signed distance"
" between the slave point and its projection on the master surface is "
"greater than the one with a rigid obstacle (considering that the release "
"distance is also first applied to rigid obstacle) then the contact pair "
"is not considered."
msgstr ""

# 98055deff44b4d61a097f2a7b5d668b8
#: ../source/userdoc/model_contact_friction_large_sliding.rst:180
msgid ""
"**Criterion 6 : for self-contact only : apply a test on unit normals in "
"reference configuration.** In case of self contact, a contact pair is "
"eliminated when the slave point and the master element belong to the same"
" mesh and if the slave point is behind the master surface (with respect "
"to its unit outward normal vector) and not four times farther than the "
"release distance. This can treat cases (A), (C), (D), (H)."
msgstr ""

# 77fdccd859024f35a027d70b71c5b605
#: ../source/userdoc/model_contact_friction_large_sliding.rst:188
msgid ""
"**Criterion 7 : smallest signed distance on contact pairs.** Between the "
"retained contact pairs (or rigid obstacle) the one corresponding to the "
"smallest signed distance is retained."
msgstr ""

# 1ce2ca41ac504ebe8b19b325ae351bd0
#: ../source/userdoc/model_contact_friction_large_sliding.rst:196
msgid "Nodal contact brick with projection"
msgstr ""

# a0c7221378f4473caaff0a1650cfc9df
#: ../source/userdoc/model_contact_friction_large_sliding.rst:198
msgid ""
"Notations: :math:`\\Omega \\subset \\Reel^d` denotes the reference "
"configuration of a deformable body, possibly constituted by several "
"unconnected parts (see  :ref:`figure<ud-fig-masterslave>`). "
":math:`\\Omega_t` is the deformed configuration and :math:`\\varphi^h: "
"\\Omega \\rightarrow \\Omega_t` is the approximated deformation on a "
"finite element space :math:`V^h`. The displacement  :math:`u^h: \\Omega "
"\\rightarrow \\Reel^d` is defined by :math:`\\varphi^h(X) = X + u^h(X)`. "
"A generic point of the reference configuration :math:`\\Omega` is denoted"
" by :math:`X` while the corresponding point of the deformed configuration"
" is denoted by :math:`x = \\varphi^h(X)`. :math:`\\Gamma^S` denotes a "
"slave boundary of :math:`\\Omega` and :math:`\\Gamma^M` a master one. The"
" corresponding boundaries on the deformed configuration are "
":math:`\\Gamma_t^S` and :math:`\\Gamma_t^M`, respectively. The outward "
"unit normal vector to the boundary (in the deformed configuration) at a "
"point :math:`x = \\varphi^h(X)` of that boundary is denoted by "
":math:`n_x`. Finally, the notation :math:`\\delta A[B]` denotes the "
"directional derivative of the quantity :math:`A` with respect to the "
"deformation and in the direction :math:`B`. Similarly, The notation "
":math:`\\delta^2 A[B,C]` is the second derivative in the directions  "
":math:`B` and :math:`C`."
msgstr ""

# 8eedb1f228df43b58373b91b3f3ab8bc
#: ../source/userdoc/model_contact_friction_large_sliding.rst:202
msgid ""
"Let :math:`J(\\varphi^h)` be the potential energy of the system, without "
"taking into account contact and friction contributions. Typically, it "
"includes elastic and external load potential energy. Let :math:`X_i` for"
"  :math:`i \\in I_{\\text{nodes}}` the set of finite element nodes on the"
" slave boundary in the reference configuration. Let :math:`X_i` for  "
":math:`i \\in I_{\\text{def}}` be the contact nodes in potential contact "
"with the master surface of a deformable body. Let  :math:`X_i` for  "
":math:`i \\in I_{\\text{rig}}` be the contact nodes in potential contact "
"with a rigid obstacle."
msgstr ""

# e0f344847dda4ff6a368dc7b032c3a50
#: ../source/userdoc/model_contact_friction_large_sliding.rst:204
msgid ""
"We denote by :math:`x_i = \\varphi^h(X_i)` the corresponding node on the "
"deformed configuration and :math:`y_i` the projection on the master "
"surface (or rigid obstacle) on the deformed configuration. Let "
":math:`Y_i` the point on the master surface verifying :math:`y_i = "
"\\varphi^h(Y_i)`. This allows to define the normal gap as"
msgstr ""

# 7667c974d2c44b27b0c06d3ad7eb06af
#: ../source/userdoc/model_contact_friction_large_sliding.rst:210
msgid ""
"where :math:`n_y` is the outward unit normal vector of the master surface"
" at :math:`y`."
msgstr ""

# 595edb47c6674ced8129f987fd0ed201
#: ../source/userdoc/model_contact_friction_large_sliding.rst:212
msgid ""
"Considering only stationnary rigid obstacles and applying the principle "
"of Alart-Curnier augmented Lagrangian [AL-CU1991]_, the problem with "
"nodal contact with friction condition can be expressed as follows in an "
"unsymmetric version (see [renard2013]_ for the linear elasticity case)"
msgstr ""

# 6c9baf8632aa4d05836057c307de65f5
#: ../source/userdoc/model_contact_friction_large_sliding.rst:223
msgid "where :math:`W_T, \\alpha, P_{n_y, {\\mathscr F}}` ... + tangent system"
msgstr ""

# 3c6c975735de4ad4994738a97ff00992
#: ../source/userdoc/model_contact_friction_large_sliding.rst:227
msgid "Sorry, for the moment the brick is not working."
msgstr ""

# ec604a6960f343f7804c9b8782b60e7e
#: ../source/userdoc/model_contact_friction_large_sliding.rst:232
msgid "Tools of the high-level generic assembly for contact with friction"
msgstr ""

# 3310893f0e51403da0c84f5b72141cb1
#: ../source/userdoc/model_contact_friction_large_sliding.rst:234
msgid ""
"The following nonlinear operators are defined in the weak form language "
"(see :ref:`ud-gasm-high`):"
msgstr ""

# db8f860e311549c7aad98eb45d304aeb
#: ../source/userdoc/model_contact_friction_large_sliding.rst:236
msgid ""
"``Transformed_unit_vector(Grad_u, n)`` where ``Grad_u`` is the gradient "
"of a displacement field and ``n`` a unit vector in the reference "
"configuration. This nonlinear operator corresponds to"
msgstr ""

# 0bda60dc3abe47bbb5178e4faf631b92
#: ../source/userdoc/model_contact_friction_large_sliding.rst:244
msgid "with the following partial derivatives"
msgstr ""

# c4dda5e9dc9c47a9b484d3fb86a615bf
#: ../source/userdoc/model_contact_friction_large_sliding.rst:252
msgid ""
"``Coulomb_friction_coupled_projection(lambda, n, Vs, g, f, r)`` where "
"``lambda`` is the contact force, ``n`` is a unit normal vector, ``Vs`` is"
" the sliding velocity, ``g`` is the gap, ``f`` the friction coefficient "
"and ``r`` a positive augmentation parameter. The expression of the "
"operator is"
msgstr ""

# 85ee52ebc39c435ea6659a65bfe04d8c
#: ../source/userdoc/model_contact_friction_large_sliding.rst:263
msgid ""
"where :math:`(\\cdot)_-` is the negative part (:math:`(x)_- = (-x)_+`) "
"and :math:`f_1, f_2, f_3` are the three components of the friction "
"coefficient. Note that the components :math:`f_2, f_3` are optional. If a"
" scalar fiction coefficient is given (only :math:`f_1`) then this "
"corresponds to the classical Coulomb friction law. If a vector of two "
"components is given  (only :math:`f_1, f_2`) then this corresponds to a "
"Coulomb friction with a given threshold. Finally, if a vector of three "
"components is given, the friction law correspongs to the expression of "
":math:`\\tau` given above."
msgstr ""

# 4d255723d0a745db964c920f89d069a6
#: ../source/userdoc/model_contact_friction_large_sliding.rst:265
msgid ""
"The expression :math:`P_{B(n,\\tau)}(q)` refers to the orthogonal "
"projection (this is link to the return mapping algorithm) on the "
"tangential ball (with respect to :math:`n` of radius :math:`\\tau`."
msgstr ""

# 3e8e6b69d6954703b973f0f4c6778397
#: ../source/userdoc/model_contact_friction_large_sliding.rst:267
msgid ""
"The derivatives can be expressed as follows with :math:`T_n = (I - n "
"\\otimes n)` and :math:`q_{_T} = T_n q`:"
msgstr ""

# a146804bd7204d93a273f383f3c480fd
#: ../source/userdoc/model_contact_friction_large_sliding.rst:330
msgid "Integral contact brick with raytrace"
msgstr ""

# 5a82ece8b07343ddb75f1d9a19f389ad
#: ../source/userdoc/model_contact_friction_large_sliding.rst:333
msgid "Add of the brick::"
msgstr ""

# f8bee2f55e224377a9f9b6096d8f3948
#: ../source/userdoc/model_contact_friction_large_sliding.rst:341
msgid ""
"This brick allows to deal with a multi-contact situation. It adds to the "
"model a raytracing interpolate transformation as described in a previous "
"section whose name can be obtained by the command::"
msgstr ""

# d7995f30e3ca4c9eb1d68cbf63bc816b
#: ../source/userdoc/model_contact_friction_large_sliding.rst:346
msgid ""
"Once the brick is added to the model, the master and slave contact "
"boundaries have to be added with the following function::"
msgstr ""

# fcb09ebff289460ba2660b1aa9d1b70c
#: ../source/userdoc/model_contact_friction_large_sliding.rst:354
msgid ""
"where ``region`` should be a valid mesh region number representing a "
"boundary, ``is_master`` should be set to ``true`` if the contact "
"detection is to be done on that contact boundary, ``is_slave`` should be "
"set to ``true`` if the integration of contact terms is to be done on that"
" boundary. Note that a contact boundary is allowed to be both master and "
"slave, in particular to allow self-contact detection. ``u`` is the "
"displacement variable. If ``is_slave`` is set to true, ``lambda`` should "
"describe a multiplier variable with degrees of freedom on the contact "
"boundary (typically added to the model with the "
"``md.add_filtered_fem_variable(...) method). Pure master contact boundary"
" do not need the definition of a multiplier. Additionally, ``w`` is for "
"the evolutionnary case and represents the displacement at the previous "
"time step."
msgstr ""

# 24f78629e6bd4f7180069e99a1b201c3
#: ../source/userdoc/model_contact_friction_large_sliding.rst:356
msgid "A rigid obstacle can be added to the brick with::"
msgstr ""

# 29f4d6292ad54349bccfd3c10678ab8d
#: ../source/userdoc/model_contact_friction_large_sliding.rst:361
msgid ""
"where `expr` is an expression using the weak form language (with `X` is "
"the current position) which should be a signed distance to the obstacle. "
"`N` is the mesh dimension."
msgstr ""

# d77836dc349e4841845838783736856c
#: ../source/userdoc/model_contact_friction_large_sliding.rst:7
msgid "models"
msgstr ""

# d77836dc349e4841845838783736856c
#: ../source/userdoc/model_contact_friction_large_sliding.rst:7
msgid "model bricks"
msgstr ""

