# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2004-2017 GetFEM++ project
# This file is distributed under the same license as the GetFEM++ package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: GetFEM++ 5.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-07-07 10:04+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

# e6979b4f15694180a367fc43c98bd19c
#: ../source/matlab/cmdref_gf_model_set.rst:8
msgid "gf_model_set"
msgstr ""

# 32d8196701924715a234eb0451250330
#: ../source/matlab/cmdref_gf_model_set.rst:10
msgid "**Synopsis**"
msgstr ""

# 985f5719526a4221ab4a06dd93f968f6
#: ../source/matlab/cmdref_gf_model_set.rst:140
msgid "**Description :**"
msgstr ""

# 20f0ec741eb84a1a83e8de506834871e
#: ../source/matlab/cmdref_gf_model_set.rst:143
msgid "Modifies a model object."
msgstr ""

# 7e906700e46b4734a9dd95e30041bd3b
#: ../source/matlab/cmdref_gf_model_set.rst:146
msgid "**Command list :**"
msgstr ""

# cb2a0b81a964425da5dde899ed569391
#: ../source/matlab/cmdref_gf_model_set.rst:150
msgid "``gf_model_set(model M, 'clear')``"
msgstr ""

# a0b8fda1921146809eede1f520a36b0e
#: ../source/matlab/cmdref_gf_model_set.rst:152
msgid "Clear the model."
msgstr ""

# f734177388c64cfe9ce0d5390b76b5f2
#: ../source/matlab/cmdref_gf_model_set.rst:155
msgid "``gf_model_set(model M, 'add fem variable', string name, mesh_fem mf)``"
msgstr ""

# bbe60ccc578b4569942560bda2864f41
#: ../source/matlab/cmdref_gf_model_set.rst:157
msgid ""
"Add a variable to the model linked to a mesh_fem. `name` is the variable "
"name."
msgstr ""

# d0c8aa762c4e4026b6dcd9b131db144d
#: ../source/matlab/cmdref_gf_model_set.rst:161
msgid ""
"``gf_model_set(model M, 'add filtered fem variable', string name, "
"mesh_fem mf, int region)``"
msgstr ""

# ff4999c8d710425996471367d2d545cd
#: ../source/matlab/cmdref_gf_model_set.rst:163
msgid ""
"Add a variable to the model linked to a mesh_fem. The variable is "
"filtered in the sense that only the dof on the region are considered. "
"`name` is the variable name."
msgstr ""

# dc8c827e1d3042c6bd68726ddec0b6dc
#: ../source/matlab/cmdref_gf_model_set.rst:168
msgid "``gf_model_set(model M, 'add variable', string name, sizes)``"
msgstr ""

# 66b2d9013b754b6b8ffeea60539ab55d
#: ../source/matlab/cmdref_gf_model_set.rst:170
msgid ""
"Add a variable to the model of constant sizes. `sizes` is either a "
"integer (for a scalar or vector variable) or a vector of dimensions for a"
" tensor variable. `name` is the variable name."
msgstr ""

# ecabe9b3aaf94f9fada8b04e57db88a1
#: ../source/matlab/cmdref_gf_model_set.rst:175
msgid "``gf_model_set(model M, 'delete variable', string name)``"
msgstr ""

# db5dc774734441d0a245e498f7701d81
# 64f6adde932b4775a404f22b51ffa380
#: ../source/matlab/cmdref_gf_model_set.rst:177
#: ../source/matlab/cmdref_gf_model_set.rst:267
msgid "Delete a variable or a data from the model."
msgstr ""

# 416b1971410e4786be1994549b80faff
#: ../source/matlab/cmdref_gf_model_set.rst:180
msgid "``gf_model_set(model M, 'resize variable', string name, sizes)``"
msgstr ""

# cb732b7b4dec4f1b8c7b741f6957f08a
#: ../source/matlab/cmdref_gf_model_set.rst:182
msgid ""
"Resize a  constant size variable of the model.  `sizes` is either a "
"integer (for a scalar or vector variable) or a vector of dimensions for a"
" tensor variable. `name` is the variable name."
msgstr ""

# cdb1a83906044df6b6a2ea386847ad95
#: ../source/matlab/cmdref_gf_model_set.rst:187
msgid ""
"``gf_model_set(model M, 'add multiplier', string name, mesh_fem mf, "
"string primalname[, mesh_im mim, int region])``"
msgstr ""

# d622c6ad475e4a4a8743dda5e58f0705
#: ../source/matlab/cmdref_gf_model_set.rst:189
msgid ""
"Add a particular variable linked to a fem being a multiplier with respect"
" to a primal variable. The dof will be filtered with the "
"``gmm::range_basis`` function applied on the terms of the model which "
"link the multiplier and the primal variable. This in order to retain only"
" linearly independent constraints on the primal variable. Optimized for "
"boundary multipliers."
msgstr ""

# 5a905cd03ae6467aac618f4bb05bd449
#: ../source/matlab/cmdref_gf_model_set.rst:197
msgid "``gf_model_set(model M, 'add im data', string name, mesh_imd mimd)``"
msgstr ""

# 7d220f341698450d8e245915b65130e0
#: ../source/matlab/cmdref_gf_model_set.rst:199
msgid "Add a data set to the model linked to a mesh_imd. `name` is the data name."
msgstr ""

# e1bb0551531748cd87df18e655a0892a
#: ../source/matlab/cmdref_gf_model_set.rst:203
msgid ""
"``gf_model_set(model M, 'add fem data', string name, mesh_fem mf[, "
"sizes])``"
msgstr ""

# 799bee6dd83c4a589cab2924a8cc1fcb
#: ../source/matlab/cmdref_gf_model_set.rst:205
msgid ""
"Add a data to the model linked to a mesh_fem. `name` is the data name, "
"`sizes` an optional parameter which is either an integer  or a vector of "
"suplementary dimensions with respect to `mf`."
msgstr ""

# c30f6bc965124bb78543afbe5e41c25b
#: ../source/matlab/cmdref_gf_model_set.rst:210
msgid ""
"``gf_model_set(model M, 'add initialized fem data', string name, mesh_fem"
" mf, vec V[, sizes])``"
msgstr ""

# 51be2f16e3df4d84901c2d484d69a91c
#: ../source/matlab/cmdref_gf_model_set.rst:212
msgid ""
"Add a data to the model linked to a mesh_fem. `name` is the data name. "
"The data is initiakized with `V`. The data can be a scalar or vector "
"field. `sizes` an optional parameter which is either an integer or a "
"vector of suplementary dimensions with respect to `mf`."
msgstr ""

# 23aa1b9aa250453ab104e194f5567000
#: ../source/matlab/cmdref_gf_model_set.rst:218
msgid "``gf_model_set(model M, 'add data', string name, int size)``"
msgstr ""

# d0531f8c05d041a6aee173dc6927e6ad
#: ../source/matlab/cmdref_gf_model_set.rst:220
msgid ""
"Add a fixed size data to the model.  `sizes` is either a integer (for a "
"scalar or vector data) or a vector of dimensions for a tensor data. "
"`name` is the data name."
msgstr ""

# 026fbc36c44b4687b5d2ef77c1a737a3
#: ../source/matlab/cmdref_gf_model_set.rst:225
msgid "``gf_model_set(model M, 'add macro', string name, string expr)``"
msgstr ""

# e52b9a6156654b519472a56f9fa97572
#: ../source/matlab/cmdref_gf_model_set.rst:227
msgid ""
"Define a new macro for the high generic assembly language. The name "
"include the parameters. For instance name='sp(a,b)', expr='a.b' is a "
"valid definition. Macro without parameter can also be defined. For "
"instance name='x1', expr='X[1]' is valid. Teh form name='grad(u)', "
"expr='Grad_u' is also allowed but in that case, the parameter 'u' will "
"only be allowed to be a variable name when using the macro. Note that "
"macros can be directly defined inside the assembly strings with the "
"keyword 'Def'."
msgstr ""

# 415f2d73ba7e400091627f0459cb34b2
#: ../source/matlab/cmdref_gf_model_set.rst:238
msgid "``gf_model_set(model M, 'del macro', string name)``"
msgstr ""

# dd251aa0344b4b12a006a9d87ded1752
#: ../source/matlab/cmdref_gf_model_set.rst:240
msgid "Delete a previously defined macro for the high generic assembly language."
msgstr ""

# 74e207a7b8b940ddac6a6e7517c4a1f7
#: ../source/matlab/cmdref_gf_model_set.rst:244
msgid ""
"``gf_model_set(model M, 'add initialized data', string name, vec V[, "
"sizes])``"
msgstr ""

# c4495f2dc51f4d49979ff40adce67acc
#: ../source/matlab/cmdref_gf_model_set.rst:246
msgid ""
"Add an initialized fixed size data to the model. `sizes` an optional "
"parameter which is either an integer  or a vector dimensions that "
"describes the format of the data. By default, the data is considered to b"
" a vector field. `name` is the data name and `V` is the value of the "
"data."
msgstr ""

# e53f4af20ac34b3fbb8b6fc2e3d6dbdc
#: ../source/matlab/cmdref_gf_model_set.rst:253
msgid "``gf_model_set(model M, 'variable', string name, vec V)``"
msgstr ""

# a0b3ea61a39740ebbdf7cf280b570cbb
#: ../source/matlab/cmdref_gf_model_set.rst:255
msgid "Set the value of a variable or data. `name` is the data name."
msgstr ""

# 9fa25144930842b08270425469217a6f
#: ../source/matlab/cmdref_gf_model_set.rst:258
msgid "``gf_model_set(model M, 'to variables', vec V)``"
msgstr ""

# 839b7949e4cd407bb34e209f258cdea8
#: ../source/matlab/cmdref_gf_model_set.rst:260
msgid ""
"Set the value of the variables of the model with the vector `V`. "
"Typically, the vector `V` results of the solve of the tangent linear "
"system (useful to solve your problem with you own solver)."
msgstr ""

# e6a12c1d9d3f44d58b907cdc638b773b
#: ../source/matlab/cmdref_gf_model_set.rst:265
msgid "``gf_model_set(model M, 'delete brick', int ind_brick)``"
msgstr ""

# d8deebbbee6442dcbcf5050eb7cb917b
#: ../source/matlab/cmdref_gf_model_set.rst:270
msgid ""
"``gf_model_set(model M, 'define variable group', string name[, string "
"varname, ...])``"
msgstr ""

# 8a6fe38318c141e3a5bc05c2fd383b5c
#: ../source/matlab/cmdref_gf_model_set.rst:272
msgid ""
"Defines a group of variables for the interpolation (mainly for the "
"raytracing interpolation transformation."
msgstr ""

# fa79b10644d44fc1b6cbf6709b23f46e
#: ../source/matlab/cmdref_gf_model_set.rst:276
msgid ""
"``gf_model_set(model M, 'add elementary rotated RT0 projection', string "
"transname)``"
msgstr ""

# 795a719666b44dd7a6352aa4bca4cdd3
#: ../source/matlab/cmdref_gf_model_set.rst:278
msgid "Experimental method ..."
msgstr ""

# b73b47517d7e4d438710a878e55aa08a
#: ../source/matlab/cmdref_gf_model_set.rst:281
msgid ""
"``gf_model_set(model M, 'add interpolate transformation from expression',"
" string transname, mesh source_mesh, mesh target_mesh, string expr)``"
msgstr ""

# 622ef3f518ef4971829f0eb340a84f23
#: ../source/matlab/cmdref_gf_model_set.rst:283
msgid ""
"Add a transformation to the model from mesh `source_mesh` to mesh "
"`target_mesh` given by the expression `expr` which corresponds to a high-"
"level generic assembly expression which may contains some variable of the"
" model. CAUTION: the derivative of the transformation with used variable "
"is taken into account in the computation of the tangen system. However, "
"order two derivative is not implemented, so such tranformation is not "
"allowed in the definition of a potential."
msgstr ""

# 2789610471bf402b8916c9bbe5feaaa0
#: ../source/matlab/cmdref_gf_model_set.rst:293
msgid ""
"``gf_model_set(model M, 'add element extrapolation transformation', "
"string transname, mesh source_mesh, mat elt_corr)``"
msgstr ""

# bc9550512e12407bbe1145c2ae8baad6
#: ../source/matlab/cmdref_gf_model_set.rst:295
msgid ""
"Add a special interpolation transformation which represents the identity "
"transformation but allows to evaluate the expression on another element "
"than the current element by polynomial extrapolation. It is used for "
"stabilization term in fictitious domain applications. the array elt_cor "
"should be a two entry array whose first line contains the elements "
"concerned by the transformation and the second line the respective "
"elements on which the extrapolation has to be made. If an element is not "
"listed in elt_cor the evaluation is just made on the current element."
msgstr ""

# 16e9ca1f05f847a4b81034e0fc2d974d
#: ../source/matlab/cmdref_gf_model_set.rst:306
msgid ""
"``gf_model_set(model M, 'add standard secondary domain', string name, "
"mesh_im mim, int region = -1)``"
msgstr ""

# daee293c5f914ff394dc9c00635a92e7
#: ../source/matlab/cmdref_gf_model_set.rst:308
msgid ""
"Add a secondary domain to the model which can be used in a weak-form "
"language expression for integration on the product of two domains. `name`"
" is the name of the secondary domain, `mim` is an integration method on "
"this domain and `region` the region on which the integration is to be "
"performed."
msgstr ""

# 17c49eb951e64063a0114e91701188e4
#: ../source/matlab/cmdref_gf_model_set.rst:313
msgid ""
"``gf_model_set(model M, 'set element extrapolation correspondance', "
"string transname, mat elt_corr)``"
msgstr ""

# bed443c0194c4fcfbff8f0354897fd83
#: ../source/matlab/cmdref_gf_model_set.rst:315
msgid ""
"Change the correspondance map of an element extrapolation interpolate "
"transformation."
msgstr ""

# 90c7126f02ff4274be5bf679519875f2
#: ../source/matlab/cmdref_gf_model_set.rst:319
msgid ""
"``gf_model_set(model M, 'add raytracing transformation', string "
"transname, scalar release_distance)``"
msgstr ""

# ae3a06de934e440d8bce0d69f6e5069f
#: ../source/matlab/cmdref_gf_model_set.rst:321
msgid ""
"Add a raytracing interpolate transformation called `transname` to a model"
" to be used by the generic assembly bricks. CAUTION: For the moment, the "
"derivative of the transformation is not taken into account in the model "
"solve."
msgstr ""

# 66bd8a4ef7e442c08d728ed5e2d4526b
#: ../source/matlab/cmdref_gf_model_set.rst:327
msgid ""
"``gf_model_set(model M, 'add master contact boundary to raytracing "
"transformation', string transname, mesh m, string dispname, int region)``"
msgstr ""

# 1031aa0bc50c4de7b612a6faefa87895
#: ../source/matlab/cmdref_gf_model_set.rst:329
msgid ""
"Add a master contact boundary with corresponding displacement variable "
"`dispname` on a specific boundary `region` to an existing raytracing "
"interpolate transformation called `transname`."
msgstr ""

# f6b8b781a0234933bb27b034127813b5
#: ../source/matlab/cmdref_gf_model_set.rst:334
msgid ""
"``gf_model_set(model M, 'add slave contact boundary to raytracing "
"transformation', string transname, mesh m, string dispname, int region)``"
msgstr ""

# 70be355f509546709e65e03f26b8fc94
#: ../source/matlab/cmdref_gf_model_set.rst:336
msgid ""
"Add a slave contact boundary with corresponding displacement variable "
"`dispname` on a specific boundary `region` to an existing raytracing "
"interpolate transformation called `transname`."
msgstr ""

# b89fbdd81d89441cb33f5139a63ccde5
#: ../source/matlab/cmdref_gf_model_set.rst:341
msgid ""
"``gf_model_set(model M, 'add rigid obstacle to raytracing "
"transformation', string transname, string expr, int N)``"
msgstr ""

# 68ec104a9a8b43e08702fde18df9c061
#: ../source/matlab/cmdref_gf_model_set.rst:343
msgid ""
"Add a rigid obstacle whose geometry corresponds to the zero level-set of "
"the high-level generic assembly expression `expr` to an existing "
"raytracing interpolate transformation called `transname`."
msgstr ""

# f2aa78e94c0440dab3d33c47de4414d0
#: ../source/matlab/cmdref_gf_model_set.rst:349
msgid ""
"``gf_model_set(model M, 'add projection transformation', string "
"transname, scalar release_distance)``"
msgstr ""

# 6343e7b40bbe4501a807a23df94316c3
#: ../source/matlab/cmdref_gf_model_set.rst:351
msgid ""
"Add a projection interpolate transformation called `transname` to a model"
" to be used by the generic assembly bricks. CAUTION: For the moment, the "
"derivative of the transformation is not taken into account in the model "
"solve."
msgstr ""

# 570da7a38df34501ac1bba970da505b4
#: ../source/matlab/cmdref_gf_model_set.rst:357
msgid ""
"``gf_model_set(model M, 'add master contact boundary to projection "
"transformation', string transname, mesh m, string dispname, int region)``"
msgstr ""

# 17d6bffe27264accaffa05d94efece1f
#: ../source/matlab/cmdref_gf_model_set.rst:359
msgid ""
"Add a master contact boundary with corresponding displacement variable "
"`dispname` on a specific boundary `region` to an existing projection "
"interpolate transformation called `transname`."
msgstr ""

# 74b2ce5a7af3447690572eaff56cc136
#: ../source/matlab/cmdref_gf_model_set.rst:364
msgid ""
"``gf_model_set(model M, 'add slave contact boundary to projection "
"transformation', string transname, mesh m, string dispname, int region)``"
msgstr ""

# 09c83bc32e5447b5acb06f85f86bf689
#: ../source/matlab/cmdref_gf_model_set.rst:366
msgid ""
"Add a slave contact boundary with corresponding displacement variable "
"`dispname` on a specific boundary `region` to an existing projection "
"interpolate transformation called `transname`."
msgstr ""

# d1e11f24fc144d8f94fad5456bdc8ffc
#: ../source/matlab/cmdref_gf_model_set.rst:371
msgid ""
"``gf_model_set(model M, 'add rigid obstacle to projection "
"transformation', string transname, string expr, int N)``"
msgstr ""

# 3108e824872c486ea6ffa5790f3e9349
#: ../source/matlab/cmdref_gf_model_set.rst:373
msgid ""
"Add a rigid obstacle whose geometry corresponds to the zero level-set of "
"the high-level generic assembly expression `expr` to an existing "
"projection interpolate transformation called `transname`."
msgstr ""

# 3c09f0c917ab463eafa00b555a376a72
#: ../source/matlab/cmdref_gf_model_set.rst:379
msgid ""
"``ind = gf_model_set(model M, 'add linear term', mesh_im mim, string "
"expression[, int region[, int is_symmetric[, int is_coercive]]])``"
msgstr ""

# e5d28088af34408abe9bc5112c38b2f9
#: ../source/matlab/cmdref_gf_model_set.rst:381
msgid ""
"Adds a matrix term given by the assembly string `expr` which will be "
"assembled in region `region` and with the integration method `mim`. Only "
"the matrix term will be taken into account, assuming that it is linear. "
"The advantage of declaring a term linear instead of nonlinear is that it "
"will be assembled only once and no assembly is necessary for the "
"residual. Take care that if the expression contains some variables and if"
" the expression is a potential or of first order (i.e. describe the weak "
"form, not the derivative of the weak form), the expression will be "
"derivated with respect to all variables. You can specify if the term is "
"symmetric, coercive or not. If you are not sure, the better is to declare"
" the term not symmetric and not coercive. But some solvers (conjugate "
"gradient for instance) are not allowed for non-coercive problems. "
"`brickname` is an otpional name for the brick."
msgstr ""

# df5ee539911342108a90639efccbb3c4
#: ../source/matlab/cmdref_gf_model_set.rst:399
msgid ""
"``ind = gf_model_set(model M, 'add linear twodomain term', mesh_im mim, "
"string expression, int region, string secondary_domain[, int "
"is_symmetric[, int is_coercive]])``"
msgstr ""

# d3c8f3667959496f8ebd9ea844619ec8
#: ../source/matlab/cmdref_gf_model_set.rst:401
msgid ""
"Adds a linear term given by a weak form language expression like "
"gf_model_set(model M, 'add linear term') but for an integration on a "
"direct product of two domains, a first specfied by ``mim`` and ``region``"
" and a second one by ``secondary_domain`` which has to be declared first "
"into the model."
msgstr ""

# 5700c0063b264078915d1f05e1ca2678
#: ../source/matlab/cmdref_gf_model_set.rst:408
msgid ""
"``ind = gf_model_set(model M, 'add linear generic assembly brick', "
"mesh_im mim, string expression[, int region[, int is_symmetric[, int "
"is_coercive]]])``"
msgstr ""

# b3f5f2d11f624123b090c61ec67adcab
#: ../source/matlab/cmdref_gf_model_set.rst:410
msgid "Deprecated. Use gf_model_set(model M, 'add linear term') instead."
msgstr ""

# ebed84acd2ab4b2a8e6545cc804966a5
#: ../source/matlab/cmdref_gf_model_set.rst:413
msgid ""
"``ind = gf_model_set(model M, 'add nonlinear term', mesh_im mim, string "
"expression[, int region[, int is_symmetric[, int is_coercive]]])``"
msgstr ""

# 4cf94ec4e9c148d28e9f6027200c82ee
#: ../source/matlab/cmdref_gf_model_set.rst:415
msgid ""
"Adds a nonlinear term given by the assembly string `expr` which will be "
"assembled in region `region` and with the integration method `mim`. The "
"expression can describe a potential or a weak form. Second order terms "
"(i.e. containing second order test functions, Test2) are not allowed. You"
" can specify if the term is symmetric, coercive or not. If you are not "
"sure, the better is to declare the term not symmetric and not coercive. "
"But some solvers (conjugate gradient for instance) are not allowed for "
"non-coercive problems. `brickname` is an otpional name for the brick."
msgstr ""

# 2ff5fb2cfaf24de8a9b028ba387ae0f2
#: ../source/matlab/cmdref_gf_model_set.rst:427
msgid ""
"``ind = gf_model_set(model M, 'add nonlinear twodomain term', mesh_im "
"mim, string expression, int region, string secondary_domain[, int "
"is_symmetric[, int is_coercive]])``"
msgstr ""

# 8f0abb973f984ef5a7b46af00ed2771a
#: ../source/matlab/cmdref_gf_model_set.rst:429
msgid ""
"Adds a nonlinear term given by a weak form language expression like "
"gf_model_set(model M, 'add nonlinear term') but for an integration on a "
"direct product of two domains, a first specfied by ``mim`` and ``region``"
" and a second one by ``secondary_domain`` which has to be declared first "
"into the model."
msgstr ""

# adb60a09846b4c2580a42c49e3c7a9f9
#: ../source/matlab/cmdref_gf_model_set.rst:436
msgid ""
"``ind = gf_model_set(model M, 'add nonlinear generic assembly brick', "
"mesh_im mim, string expression[, int region[, int is_symmetric[, int "
"is_coercive]]])``"
msgstr ""

# 267abf75bf134948a5980423ff98fd3c
#: ../source/matlab/cmdref_gf_model_set.rst:438
msgid "Deprecated. Use gf_model_set(model M, 'add nonlinear term') instead."
msgstr ""

# effdad66ace143ef8b51cfe06235cffc
#: ../source/matlab/cmdref_gf_model_set.rst:441
msgid ""
"``ind = gf_model_set(model M, 'add source term', mesh_im mim, string "
"expression[, int region])``"
msgstr ""

# 6ea8cae972014c448b0fff8747912660
#: ../source/matlab/cmdref_gf_model_set.rst:443
msgid ""
"Adds a source term given by the assembly string `expr` which will be "
"assembled in region `region` and with the integration method `mim`. Only "
"the residual term will be taken into account. Take care that if the "
"expression contains some variables and if the expression is a potential, "
"the expression will be derivated with respect to all variables. "
"`brickname` is an optional name for the brick."
msgstr ""

# 2a63fb41c9864aba96b8e28fde26afef
#: ../source/matlab/cmdref_gf_model_set.rst:452
msgid ""
"``ind = gf_model_set(model M, 'add twodomain source term', mesh_im mim, "
"string expression, int region, string secondary_domain)``"
msgstr ""

# 940643a78a7841e99cf85fc60cbd8495
#: ../source/matlab/cmdref_gf_model_set.rst:454
msgid ""
"Adds a source term given by a weak form language expression like "
"gf_model_set(model M, 'add source term') but for an integration on a "
"direct product of two domains, a first specfied by ``mim`` and ``region``"
" and a second one by ``secondary_domain`` which has to be declared first "
"into the model."
msgstr ""

# 715f4b1b48494575878bafa1c686e28f
#: ../source/matlab/cmdref_gf_model_set.rst:461
msgid ""
"``ind = gf_model_set(model M, 'add source term generic assembly brick', "
"mesh_im mim, string expression[, int region])``"
msgstr ""

# da150e7245974a328d4d6b79a7e42c75
#: ../source/matlab/cmdref_gf_model_set.rst:463
msgid "Deprecated. Use gf_model_set(model M, 'add source term') instead."
msgstr ""

# a7d403e34e2640afbf4a5373f5e2dce0
#: ../source/matlab/cmdref_gf_model_set.rst:466
msgid ""
"``gf_model_set(model M, 'add assembly assignment', string dataname, "
"string expression[, int region[, int order[, int before]]])``"
msgstr ""

# 11f3bda93494432391a1af33714b92e5
#: ../source/matlab/cmdref_gf_model_set.rst:468
msgid ""
"Adds expression `expr` to be evaluated at assembly time and being "
"assigned to the data `dataname` which has to be of im_data type. This "
"allows for instance to store a sub-expression of an assembly computation "
"to be used on an other assembly. It can be used for instance to store the"
" plastic strain in plasticity models. `order` represents the order of "
"assembly where this assignement has to be done (potential(0), weak "
"form(1) or tangent system(2) or at each order(-1)). The default value is "
"1. If before = 1, the the assignement is perfromed before the computation"
" of the other assembly terms, such that the data can be used in the "
"remaining of the assembly as an intermediary result (be careful that it "
"is still considered as a data, no derivation of the expression is "
"performed for the tangent system). If before = 0 (default), the "
"assignement is done after the assembly terms."
msgstr ""

# 5c15aa931a9f421f899babc9a7918e38
#: ../source/matlab/cmdref_gf_model_set.rst:485
msgid "``gf_model_set(model M, 'clear assembly assignment')``"
msgstr ""

# 29a087f1855646dfb87da00d14b54b87
#: ../source/matlab/cmdref_gf_model_set.rst:487
msgid "Delete all added assembly assignments"
msgstr ""

# 66e98fc8dba24a2a8ec2522898ace1dd
#: ../source/matlab/cmdref_gf_model_set.rst:491
msgid ""
"``ind = gf_model_set(model M, 'add Laplacian brick', mesh_im mim, string "
"varname[, int region])``"
msgstr ""

# 8b151a4b7a124c13942041e5814b5800
#: ../source/matlab/cmdref_gf_model_set.rst:493
msgid ""
"Add a Laplacian term to the model relatively to the variable `varname` "
"(in fact with a minus : :math:`-\\text{div}(\\nabla u)`). If this is a "
"vector valued variable, the Laplacian term is added componentwise. "
"`region` is an optional mesh region on which the term is added. If it is "
"not specified, it is added on the whole mesh. Return the brick index in "
"the model."
msgstr ""

# 745fcc19ac5247d7b32150ff6ad630e6
#: ../source/matlab/cmdref_gf_model_set.rst:501
msgid ""
"``ind = gf_model_set(model M, 'add generic elliptic brick', mesh_im mim, "
"string varname, string dataname[, int region])``"
msgstr ""

# 1c918de486e34f22b2e508d8a0bd87b5
#: ../source/matlab/cmdref_gf_model_set.rst:503
msgid ""
"Add a generic elliptic term to the model relatively to the variable "
"`varname`. The shape of the elliptic term depends both on the variable "
"and the data. This corresponds to a term :math:`-\\text{div}(a\\nabla u)`"
" where :math:`a` is the data and :math:`u` the variable. The data can be "
"a scalar, a matrix or an order four tensor. The variable can be vector "
"valued or not. If the data is a scalar or a matrix and the variable is "
"vector valued then the term is added componentwise. An order four tensor "
"data is allowed for vector valued variable only. The data can be constant"
" or describbed on a fem. Of course, when the data is a tensor describe on"
" a finite element method (a tensor field) the data can be a huge vector. "
"The components of the matrix/tensor have to be stored with the fortran "
"order (columnwise) in the data vector (compatibility with blas). The "
"symmetry of the given matrix/tensor is not verified (but assumed). If "
"this is a vector valued variable, the elliptic term is added "
"componentwise. `region` is an optional mesh region on which the term is "
"added. If it is not specified, it is added on the whole mesh. Note that "
"for the real version which uses the high-level generic assembly language,"
" `dataname` can be any regular expression of the high-level generic "
"assembly language (like \"1\", \"sin(X(1))\" or \"Norm(u)\" for instance)"
" even depending on model variables. Return the brick index in the model."
msgstr ""

# 6e8444ae1ea84f9a88905cbaebdc14f8
#: ../source/matlab/cmdref_gf_model_set.rst:529
msgid ""
"``ind = gf_model_set(model M, 'add source term brick', mesh_im mim, "
"string varname, string dataexpr[, int region[, string directdataname]])``"
msgstr ""

# 3b795c9caeb5481089360c78013b9d93
#: ../source/matlab/cmdref_gf_model_set.rst:531
msgid ""
"Add a source term to the model relatively to the variable `varname`. The "
"source term is represented by `dataexpr` which could be any regular "
"expression of the high-level generic assembly language (except for the "
"complex version where it has to be a declared data of the model). "
"`region` is an optional mesh region on which the term is added. An "
"additional optional data `directdataname` can be provided. The "
"corresponding data vector will be directly added to the right hand side "
"without assembly. Note that when region is a boundary, this brick allows "
"to prescribe a nonzero Neumann boundary condition. Return the brick index"
" in the model."
msgstr ""

# 51f9dcc0d8864a6f8299fe88b42a4d1e
#: ../source/matlab/cmdref_gf_model_set.rst:544
msgid ""
"``ind = gf_model_set(model M, 'add normal source term brick', mesh_im "
"mim, string varname, string dataname, int region)``"
msgstr ""

# 9b04af6e88d34948a9f48f5d47272591
#: ../source/matlab/cmdref_gf_model_set.rst:546
msgid ""
"Add a source term on the variable `varname` on a boundary `region`. This "
"region should be a boundary. The source term is represented by the data "
"`dataepxpr` which could be any regular expression of the high-level "
"generic assembly language (except for the complex version where it has to"
" be a declared data of the model). A scalar product with the outward "
"normal unit vector to the boundary is performed. The main aim of this "
"brick is to represent a Neumann condition with a vector data without "
"performing the scalar product with the normal as a pre-processing. Return"
" the brick index in the model."
msgstr ""

# eba120683b794963b8f6a3d146a5480f
#: ../source/matlab/cmdref_gf_model_set.rst:558
msgid ""
"``ind = gf_model_set(model M, 'add Dirichlet condition with "
"simplification', string varname, int region[, string dataname])``"
msgstr ""

# 2d8fb10462dc44f89c2afc9a8115097c
#: ../source/matlab/cmdref_gf_model_set.rst:560
msgid ""
"Adds a (simple) Dirichlet condition on the variable `varname` and the "
"mesh region `region`. The Dirichlet condition is prescribed by a simple "
"post-treatment of the final linear system (tangent system for nonlinear "
"problems) consisting of modifying the lines corresponding to the degree "
"of freedom of the variable on `region` (0 outside the diagonal, 1 on the "
"diagonal of the matrix and the expected value on the right hand side). "
"The symmetry of the linear system is kept if all other bricks are "
"symmetric. This brick is to be reserved for simple Dirichlet conditions "
"(only dof declared on the correspodning boundary are prescribed). The "
"application of this brick on reduced dof may be problematic. Intrinsic "
"vectorial finite element method are not supported. `dataname` is the "
"optional right hand side of  the Dirichlet condition. It could be "
"constant (but in that case, it can only be applied to Lagrange f.e.m.) or"
" (important) described on the same finite element method as `varname`. "
"Returns the brick index in the model."
msgstr ""

# 4d2de13010974016af2290a27ed919fe
#: ../source/matlab/cmdref_gf_model_set.rst:580
msgid ""
"``ind = gf_model_set(model M, 'add Dirichlet condition with multipliers',"
" mesh_im mim, string varname, mult_description, int region[, string "
"dataname])``"
msgstr ""

# 443805e44f6149d6bbb120792fceface
#: ../source/matlab/cmdref_gf_model_set.rst:582
msgid ""
"Add a Dirichlet condition on the variable `varname` and the mesh region "
"`region`. This region should be a boundary. The Dirichlet condition is "
"prescribed with a multiplier variable described by `mult_description`. If"
" `mult_description` is a string this is assumed to be the variable name "
"corresponding to the multiplier (which should be first declared as a "
"multiplier variable on the mesh region in the model). If it is a finite "
"element method (mesh_fem object) then a multiplier variable will be added"
" to the model and build on this finite element method (it will be "
"restricted to the mesh region `region` and eventually some conflicting "
"dofs with some other multiplier variables will be suppressed). If it is "
"an integer, then a  multiplier variable will be added to the model and "
"build on a classical finite element of degree that integer. `dataname` is"
" the optional right hand side of  the Dirichlet condition. It could be "
"constant or described on a fem; scalar or vector valued, depending on the"
" variable on which the Dirichlet condition is prescribed. Return the "
"brick index in the model."
msgstr ""

# 9c95c21ab6d14378a611cd9e2ae67411
#: ../source/matlab/cmdref_gf_model_set.rst:600
msgid ""
"``ind = gf_model_set(model M, 'add Dirichlet condition with Nitsche "
"method', mesh_im mim, string varname, string Neumannterm, string "
"datagamma0, int region[, scalar theta][, string dataname])``"
msgstr ""

# 17f98316a4d94d0c975411be0d6baa98
#: ../source/matlab/cmdref_gf_model_set.rst:602
msgid ""
"Add a Dirichlet condition on the variable `varname` and the mesh region "
"`region`. This region should be a boundary. `Neumannterm` is the "
"expression of the Neumann term (obtained by the Green formula) described "
"as an expression of the high-level generic assembly language. This term "
"can be obtained by gf_model_get(model M, 'Neumann term', varname, region)"
" once all volumic bricks have been added to the model. The Dirichlet "
"condition is prescribed with Nitsche's method. `datag` is the optional "
"right hand side of the Dirichlet condition. `datagamma0` is the Nitsche's"
" method parameter. `theta` is a scalar value which can be positive or "
"negative. `theta = 1` corresponds to the standard symmetric method which "
"is conditionnaly coercive for  `gamma0` small. `theta = -1` corresponds "
"to the skew-symmetric method which is inconditionnaly coercive. `theta = "
"0` (default) is the simplest method for which the second derivative of "
"the Neumann term is not necessary even for nonlinear problems. Return the"
" brick index in the model."
msgstr ""

# b9337211980e40fcac63d9edc9b41da6
#: ../source/matlab/cmdref_gf_model_set.rst:621
msgid ""
"``ind = gf_model_set(model M, 'add Dirichlet condition with "
"penalization', mesh_im mim, string varname, scalar coeff, int region[, "
"string dataname, mesh_fem mf_mult])``"
msgstr ""

# c237f9be4e3a4bab967d40ed915acb7f
#: ../source/matlab/cmdref_gf_model_set.rst:623
msgid ""
"Add a Dirichlet condition on the variable `varname` and the mesh region "
"`region`. This region should be a boundary. The Dirichlet condition is "
"prescribed with penalization. The penalization coefficient is initially "
"`coeff` and will be added to the data of the model. `dataname` is the "
"optional right hand side of the Dirichlet condition. It could be constant"
" or described on a fem; scalar or vector valued, depending on the "
"variable on which the Dirichlet condition is prescribed. `mf_mult` is an "
"optional parameter which allows to weaken the Dirichlet condition "
"specifying a multiplier space. Return the brick index in the model."
msgstr ""

# 4840a9cb9cab4fb4961934e6d79adb64
#: ../source/matlab/cmdref_gf_model_set.rst:635
msgid ""
"``ind = gf_model_set(model M, 'add normal Dirichlet condition with "
"multipliers', mesh_im mim, string varname, mult_description, int region[,"
" string dataname])``"
msgstr ""

# 4cbf536a31be4ac3b73bbfa957f3c416
#: ../source/matlab/cmdref_gf_model_set.rst:637
msgid ""
"Add a Dirichlet condition to the normal component of the vector (or "
"tensor) valued variable `varname` and the mesh region `region`. This "
"region should be a boundary. The Dirichlet condition is prescribed with a"
" multiplier variable described by `mult_description`. If "
"`mult_description` is a string this is assumed to be the variable name "
"corresponding to the multiplier (which should be first declared as a "
"multiplier variable on the mesh region in the model). If it is a finite "
"element method (mesh_fem object) then a multiplier variable will be added"
" to the model and build on this finite element method (it will be "
"restricted to the mesh region `region` and eventually some conflicting "
"dofs with some other multiplier variables will be suppressed). If it is "
"an integer, then a  multiplier variable will be added to the model and "
"build on a classical finite element of degree that integer. `dataname` is"
" the optional right hand side of  the Dirichlet condition. It could be "
"constant or described on a fem; scalar or vector valued, depending on the"
" variable on which the Dirichlet condition is prescribed (scalar if the "
"variable is vector valued, vector if the variable is tensor valued). "
"Returns the brick index in the model."
msgstr ""

# 42185f4e9ba94ad2a574e89d8ec97d20
#: ../source/matlab/cmdref_gf_model_set.rst:658
msgid ""
"``ind = gf_model_set(model M, 'add normal Dirichlet condition with "
"penalization', mesh_im mim, string varname, scalar coeff, int region[, "
"string dataname, mesh_fem mf_mult])``"
msgstr ""

# 8458d7c591944b00b5b2b47fddb44881
#: ../source/matlab/cmdref_gf_model_set.rst:660
msgid ""
"Add a Dirichlet condition to the normal component of the vector (or "
"tensor) valued variable `varname` and the mesh region `region`. This "
"region should be a boundary. The Dirichlet condition is prescribed with "
"penalization. The penalization coefficient is initially `coeff` and will "
"be added to the data of the model. `dataname` is the optional right hand "
"side of the Dirichlet condition. It could be constant or described on a "
"fem; scalar or vector valued, depending on the variable on which the "
"Dirichlet condition is prescribed (scalar if the variable is vector "
"valued, vector if the variable is tensor valued). `mf_mult` is an "
"optional parameter which allows to weaken the Dirichlet condition "
"specifying a multiplier space. Returns the brick index in the model."
msgstr ""

# 96ea7febf8054c2b84115d61d17bdc74
#: ../source/matlab/cmdref_gf_model_set.rst:675
msgid ""
"``ind = gf_model_set(model M, 'add normal Dirichlet condition with "
"Nitsche method', mesh_im mim, string varname, string Neumannterm, string "
"gamma0name, int region[, scalar theta][, string dataname])``"
msgstr ""

# 5af37a3830024530b684e5b1e7a8be36
#: ../source/matlab/cmdref_gf_model_set.rst:677
msgid ""
"Add a Dirichlet condition to the normal component of the vector (or "
"tensor) valued variable `varname` and the mesh region `region`. This "
"region should be a boundary. `Neumannterm` is the expression of the "
"Neumann term (obtained by the Green formula) described as an expression "
"of the high-level generic assembly language. This term can be obtained by"
" gf_model_get(model M, 'Neumann term', varname, region) once all volumic "
"bricks have been added to the model. The Dirichlet condition is "
"prescribed with Nitsche's method. `dataname` is the optional right hand "
"side of the Dirichlet condition. It could be constant or described on a "
"fem. `gamma0name` is the Nitsche's method parameter. `theta` is a scalar "
"value which can be positive or negative. `theta = 1` corresponds to the "
"standard symmetric method which is conditionnaly coercive for  `gamma0` "
"small. `theta = -1` corresponds to the skew-symmetric method which is "
"inconditionnaly coercive. `theta = 0` is the simplest method for which "
"the second derivative of the Neumann term is not necessary even for "
"nonlinear problems. Returns the brick index in the model. (This brick is "
"not fully tested)"
msgstr ""

# 3a0a695e5f474e439e805cbbb01b3fb4
#: ../source/matlab/cmdref_gf_model_set.rst:700
msgid ""
"``ind = gf_model_set(model M, 'add generalized Dirichlet condition with "
"multipliers', mesh_im mim, string varname, mult_description, int region, "
"string dataname, string Hname)``"
msgstr ""

# d8f7ff2d469048dd95d2ce66ba076b29
#: ../source/matlab/cmdref_gf_model_set.rst:702
msgid ""
"Add a Dirichlet condition on the variable `varname` and the mesh region "
"`region`.  This version is for vector field. It prescribes a condition "
":math:`Hu = r` where `H` is a matrix field. The region should be a "
"boundary. The Dirichlet condition is prescribed with a multiplier "
"variable described by `mult_description`. If `mult_description` is a "
"string this is assumed to be the variable name corresponding to the "
"multiplier (which should be first declared as a multiplier variable on "
"the mesh region in the model). If it is a finite element method (mesh_fem"
" object) then a multiplier variable will be added to the model and build "
"on this finite element method (it will be restricted to the mesh region "
"`region` and eventually some conflicting dofs with some other multiplier "
"variables will be suppressed). If it is an integer, then a  multiplier "
"variable will be added to the model and build on a classical finite "
"element of degree that integer. `dataname` is the right hand side of  the"
" Dirichlet condition. It could be constant or described on a fem; scalar "
"or vector valued, depending on the variable on which the Dirichlet "
"condition is prescribed. `Hname` is the data corresponding to the matrix "
"field `H`. Returns the brick index in the model."
msgstr ""

# de5c93025c9d4b7dbd8e0d9b1f9ab780
#: ../source/matlab/cmdref_gf_model_set.rst:724
msgid ""
"``ind = gf_model_set(model M, 'add generalized Dirichlet condition with "
"penalization', mesh_im mim, string varname, scalar coeff, int region, "
"string dataname, string Hname[, mesh_fem mf_mult])``"
msgstr ""

# 7ba2a0efdd0d4881b80c4d1a501d4c45
#: ../source/matlab/cmdref_gf_model_set.rst:726
msgid ""
"Add a Dirichlet condition on the variable `varname` and the mesh region "
"`region`. This version is for vector field. It prescribes a condition "
":math:`Hu = r` where `H` is a matrix field. The region should be a "
"boundary. The Dirichlet condition is prescribed with penalization. The "
"penalization coefficient is intially `coeff` and will be added to the "
"data of the model. `dataname` is the right hand side of the Dirichlet "
"condition. It could be constant or described on a fem; scalar or vector "
"valued, depending on the variable on which the Dirichlet condition is "
"prescribed. `Hname` is the data corresponding to the matrix field `H`. It"
" has to be a constant matrix or described on a scalar fem. `mf_mult` is "
"an optional parameter which allows to weaken the Dirichlet condition "
"specifying a multiplier space. Return the brick index in the model."
msgstr ""

# 20d9371d2bd94d23ae79f9f1cd1a11d0
#: ../source/matlab/cmdref_gf_model_set.rst:744
msgid ""
"``ind = gf_model_set(model M, 'add generalized Dirichlet condition with "
"Nitsche method', mesh_im mim, string varname, string Neumannterm, string "
"gamma0name, int region[, scalar theta], string dataname, string Hname)``"
msgstr ""

# 9cf29b6df47942b082c2ff32701cf656
#: ../source/matlab/cmdref_gf_model_set.rst:746
msgid ""
"Add a Dirichlet condition on the variable `varname` and the mesh region "
"`region`. This version is for vector field. It prescribes a condition @f$"
" Hu = r @f$ where `H` is a matrix field. CAUTION : the matrix H should "
"have all eigenvalues equal to 1 or 0. The region should be a boundary.   "
"`Neumannterm` is the expression of the Neumann term (obtained by the "
"Green formula) described as an expression of the high-level generic "
"assembly language. This term can be obtained by gf_model_get(model M, "
"'Neumann term', varname, region) once all volumic bricks have been added "
"to the model.  The Dirichlet condition is prescribed with Nitsche's "
"method. `dataname` is the optional right hand side of the Dirichlet "
"condition. It could be constant or described on a fem. `gamma0name` is "
"the Nitsche's method parameter. `theta` is a scalar value which can be "
"positive or negative. `theta = 1` corresponds to the standard symmetric "
"method which is conditionnaly coercive for  `gamma0` small. `theta = -1` "
"corresponds to the skew-symmetric method which is inconditionnaly "
"coercive. `theta = 0` is the simplest method for which the second "
"derivative of the Neumann term is not necessary even for nonlinear "
"problems. `Hname` is the data corresponding to the matrix field `H`. It "
"has to be a constant matrix or described on a scalar fem. Returns the "
"brick index in the model. (This brick is not fully tested)"
msgstr ""

# 360c3fbed826417a9e8f922f318c1e83
#: ../source/matlab/cmdref_gf_model_set.rst:773
msgid ""
"``ind = gf_model_set(model M, 'add pointwise constraints with "
"multipliers', string varname, string dataname_pt[, string dataname_unitv]"
" [, string dataname_val])``"
msgstr ""

# 18a208387d044e69a0a725a6b8d78424
#: ../source/matlab/cmdref_gf_model_set.rst:775
msgid ""
"Add some pointwise constraints on the variable `varname` using "
"multiplier. The multiplier variable is automatically added to the model. "
"The conditions are prescribed on a set of points given in the data "
"`dataname_pt` whose dimension is the number of points times the dimension"
" of the mesh. If the variable represents a vector field, one has to give "
"the data `dataname_unitv` which represents a vector of dimension the "
"number of points times the dimension of the vector field which should "
"store some unit vectors. In that case the prescribed constraint is the "
"scalar product of the variable at the corresponding point with the "
"corresponding unit vector. The optional data `dataname_val` is the vector"
" of values to be prescribed at the different points. This brick is "
"specifically designed to kill rigid displacement in a Neumann problem. "
"Returns the brick index in the model."
msgstr ""

# 2c53146a3401487aacc0c3ba7d32c7b0
#: ../source/matlab/cmdref_gf_model_set.rst:793
msgid ""
"``ind = gf_model_set(model M, 'add pointwise constraints with given "
"multipliers', string varname, string multname, string dataname_pt[, "
"string dataname_unitv] [, string dataname_val])``"
msgstr ""

# d2f957ea813b4358a77e857df157d077
#: ../source/matlab/cmdref_gf_model_set.rst:795
msgid ""
"Add some pointwise constraints on the variable `varname` using a given "
"multiplier `multname`. The conditions are prescribed on a set of points "
"given in the data `dataname_pt` whose dimension is the number of points "
"times the dimension of the mesh. The multiplier variable should be a "
"fixed size variable of size the number of points. If the variable "
"represents a vector field, one has to give the data `dataname_unitv` "
"which represents a vector of dimension the number of points times the "
"dimension of the vector field which should store some unit vectors. In "
"that case the prescribed constraint is the scalar product of the variable"
" at the corresponding point with the corresponding unit vector. The "
"optional data `dataname_val` is the vector of values to be prescribed at "
"the different points. This brick is specifically designed to kill rigid "
"displacement in a Neumann problem. Returns the brick index in the model."
msgstr ""

# b873e39b688c45448a9efb6e9486f85a
#: ../source/matlab/cmdref_gf_model_set.rst:815
msgid ""
"``ind = gf_model_set(model M, 'add pointwise constraints with "
"penalization', string varname, scalar coeff, string dataname_pt[, string "
"dataname_unitv] [, string dataname_val])``"
msgstr ""

# db35755084cf489e952c3711c924e1de
#: ../source/matlab/cmdref_gf_model_set.rst:817
msgid ""
"Add some pointwise constraints on the variable `varname` thanks to a "
"penalization. The penalization coefficient is initially "
"`penalization_coeff` and will be added to the data of the model. The "
"conditions are prescribed on a set of points given in the data "
"`dataname_pt` whose dimension is the number of points times the dimension"
" of the mesh. If the variable represents a vector field, one has to give "
"the data `dataname_unitv` which represents a vector of dimension the "
"number of points times the dimension of the vector field which should "
"store some unit vectors. In that case the prescribed constraint is the "
"scalar product of the variable at the corresponding point with the "
"corresponding unit vector. The optional data `dataname_val` is the vector"
" of values to be prescribed at the different points. This brick is "
"specifically designed to kill rigid displacement in a Neumann problem. "
"Returns the brick index in the model."
msgstr ""

# b382fdac3cea4da7b4b5933c248ce2d3
#: ../source/matlab/cmdref_gf_model_set.rst:836
msgid ""
"``gf_model_set(model M, 'change penalization coeff', int ind_brick, "
"scalar coeff)``"
msgstr ""

# 16456d6463aa42ca93c21a387e74ee7b
#: ../source/matlab/cmdref_gf_model_set.rst:838
msgid ""
"Change the penalization coefficient of a Dirichlet condition with "
"penalization brick. If the brick is not of this kind, this function has "
"an undefined behavior."
msgstr ""

# 24e0cd5bf00b4c1cbec5d3c049a07e8b
#: ../source/matlab/cmdref_gf_model_set.rst:843
msgid ""
"``ind = gf_model_set(model M, 'add Helmholtz brick', mesh_im mim, string "
"varname, string dataexpr[, int region])``"
msgstr ""

# d20736377799484b8c5351f5b3bc9155
#: ../source/matlab/cmdref_gf_model_set.rst:845
msgid ""
"Add a Helmholtz term to the model relatively to the variable `varname`. "
"`dataexpr` is the wave number. `region` is an optional mesh region on "
"which the term is added. If it is not specified, it is added on the whole"
" mesh. Return the brick index in the model."
msgstr ""

# 6f8ebdd2b0af406485a3874438fa4854
#: ../source/matlab/cmdref_gf_model_set.rst:851
msgid ""
"``ind = gf_model_set(model M, 'add Fourier Robin brick', mesh_im mim, "
"string varname, string dataexpr, int region)``"
msgstr ""

# 5161dff6d4a34647918537ef657450ca
#: ../source/matlab/cmdref_gf_model_set.rst:853
msgid ""
"Add a Fourier-Robin term to the model relatively to the variable "
"`varname`. This corresponds to a weak term of the form :math:`\\int "
"(qu).v`. `dataexpr` is the parameter :math:`q` of the Fourier-Robin "
"condition.  It can be an arbitrary valid expression of the high-level "
"generic assembly language (except for the complex version for which it "
"should be a data of the model). `region` is the mesh region on which the "
"term is added. Return the brick index in the model."
msgstr ""

# 462e95b624d9499e86058a6b482e1f22
#: ../source/matlab/cmdref_gf_model_set.rst:862
msgid ""
"``ind = gf_model_set(model M, 'add constraint with multipliers', string "
"varname, string multname, spmat B, {vec L | string dataname})``"
msgstr ""

# c14dff500bdf4e14b006f1131b17271e
#: ../source/matlab/cmdref_gf_model_set.rst:864
msgid ""
"Add an additional explicit constraint on the variable `varname` thank to "
"a multiplier `multname` peviously added to the model (should be a fixed "
"size variable). The constraint is :math:`BU=L` with `B` being a "
"rectangular sparse matrix. It is possible to change the constraint at any"
" time with the methods gf_model_set(model M, 'set private matrix') and "
"gf_model_set(model M, 'set private rhs'). If `dataname` is specified "
"instead of `L`, the vector `L` is defined in the model as data with the "
"given name. Return the brick index in the model."
msgstr ""

# bcd51ea15f934036abb041c144d93237
#: ../source/matlab/cmdref_gf_model_set.rst:874
msgid ""
"``ind = gf_model_set(model M, 'add constraint with penalization', string "
"varname, scalar coeff, spmat B, {vec L | string dataname})``"
msgstr ""

# 66ad5ddad657490f828adb6561ada779
#: ../source/matlab/cmdref_gf_model_set.rst:876
msgid ""
"Add an additional explicit penalized constraint on the variable "
"`varname`. The constraint is :math`BU=L` with `B` being a rectangular "
"sparse matrix. Be aware that `B` should not contain a palin row, "
"otherwise the whole tangent matrix will be plain. It is possible to "
"change the constraint at any time with the methods gf_model_set(model M, "
"'set private matrix') and gf_model_set(model M, 'set private rhs'). The "
"method gf_model_set(model M, 'change penalization coeff') can be used. If"
" `dataname` is specified instead of `L`, the vector `L` is defined in the"
" model as data with the given name. Return the brick index in the model."
msgstr ""

# 95b7ff7e79f14bfca251e133737d75be
#: ../source/matlab/cmdref_gf_model_set.rst:889
msgid ""
"``ind = gf_model_set(model M, 'add explicit matrix', string varname1, "
"string varname2, spmat B[, int issymmetric[, int iscoercive]])``"
msgstr ""

# f7c52ed054ed4b48ae104cf1eb553feb
#: ../source/matlab/cmdref_gf_model_set.rst:891
msgid ""
"Add a brick representing an explicit matrix to be added to the tangent "
"linear system relatively to the variables `varname1` and `varname2`. The "
"given matrix should have has many rows as the dimension of `varname1` and"
" as many columns as the dimension of `varname2`. If the two variables are"
" different and if `issymmetric` is set to 1 then the transpose of the "
"matrix is also added to the tangent system (default is 0). Set "
"`iscoercive` to 1 if the term does not affect the coercivity of the "
"tangent system (default is 0). The matrix can be changed by the command "
"gf_model_set(model M, 'set private matrix'). Return the brick index in "
"the model."
msgstr ""

# 00fb878cdc5c450b9773acdc5b33474c
#: ../source/matlab/cmdref_gf_model_set.rst:903
msgid "``ind = gf_model_set(model M, 'add explicit rhs', string varname, vec L)``"
msgstr ""

# 45275ec154e54d9fa4472e6623691bd5
#: ../source/matlab/cmdref_gf_model_set.rst:905
msgid ""
"Add a brick representing an explicit right hand side to be added to the "
"right hand side of the tangent linear system relatively to the variable "
"`varname`. The given rhs should have the same size than the dimension of "
"`varname`. The rhs can be changed by the command gf_model_set(model M, "
"'set private rhs'). If `dataname` is specified instead of `L`, the vector"
" `L` is defined in the model as data with the given name. Return the "
"brick index in the model."
msgstr ""

# 165f0636d7b94208a2a3ae108d4c85c3
#: ../source/matlab/cmdref_gf_model_set.rst:914
msgid "``gf_model_set(model M, 'set private matrix', int indbrick, spmat B)``"
msgstr ""

# 49715d8444624e00a4b9e4d6ece5c030
#: ../source/matlab/cmdref_gf_model_set.rst:916
msgid ""
"For some specific bricks having an internal sparse matrix (explicit "
"bricks: 'constraint brick' and 'explicit matrix brick'), set this matrix."
msgstr ""

# aa37396dbf924a52b71aabb4d7176ae9
#: ../source/matlab/cmdref_gf_model_set.rst:921
msgid "``gf_model_set(model M, 'set private rhs', int indbrick, vec B)``"
msgstr ""

# 5fad187ec4d447febb304d85d420daa5
#: ../source/matlab/cmdref_gf_model_set.rst:923
msgid ""
"For some specific bricks having an internal right hand side vector "
"(explicit bricks: 'constraint brick' and 'explicit rhs brick'), set this "
"rhs."
msgstr ""

# fba487dc296c4943844a0acfc76b556c
#: ../source/matlab/cmdref_gf_model_set.rst:928
msgid ""
"``ind = gf_model_set(model M, 'add isotropic linearized elasticity "
"brick', mesh_im mim, string varname, string dataname_lambda, string "
"dataname_mu[, int region])``"
msgstr ""

# 3a6de793276f4cb1bbe7f5b090fd31e0
#: ../source/matlab/cmdref_gf_model_set.rst:930
msgid ""
"Add an isotropic linearized elasticity term to the model relatively to "
"the variable `varname`. `dataname_lambda` and `dataname_mu` should "
"contain the Lame coefficients. `region` is an optional mesh region on "
"which the term is added. If it is not specified, it is added on the whole"
" mesh. Return the brick index in the model."
msgstr ""

# 2115107fae584516b897cf3b822ca0eb
#: ../source/matlab/cmdref_gf_model_set.rst:937
msgid ""
"``ind = gf_model_set(model M, 'add isotropic linearized elasticity brick "
"pstrain', mesh_im mim, string varname, string data_E, string data_nu[, "
"int region])``"
msgstr ""

# b77d67dc0eff4bd890b5e6dffe9afd22
#: ../source/matlab/cmdref_gf_model_set.rst:939
msgid ""
"Add an isotropic linearized elasticity term to the model relatively to "
"the variable `varname`. `data_E` and `data_nu` should contain the Young "
"modulus and Poisson ratio, respectively. `region` is an optional mesh "
"region on which the term is added. If it is not specified, it is added on"
" the whole mesh. On two-dimensional meshes, the term will correpsond to a"
" plain strain approximation. On three-dimensional meshes, it will "
"correspond to the standard model. Return the brick index in the model."
msgstr ""

# df10c912c5234dbc9dec1774e21f18bb
#: ../source/matlab/cmdref_gf_model_set.rst:951
msgid ""
"``ind = gf_model_set(model M, 'add isotropic linearized elasticity brick "
"pstress', mesh_im mim, string varname, string data_E, string data_nu[, "
"int region])``"
msgstr ""

# b3895f28a0984288b02d96fbb9c70d2a
#: ../source/matlab/cmdref_gf_model_set.rst:953
msgid ""
"Add an isotropic linearized elasticity term to the model relatively to "
"the variable `varname`. `data_E` and `data_nu` should contain the Young "
"modulus and Poisson ratio, respectively. `region` is an optional mesh "
"region on which the term is added. If it is not specified, it is added on"
" the whole mesh. On two-dimensional meshes, the term will correpsond to a"
" plain stress approximation. On three-dimensional meshes, it will "
"correspond to the standard model. Return the brick index in the model."
msgstr ""

# 10abf9dacf3f4665b27afa93fc7d0295
#: ../source/matlab/cmdref_gf_model_set.rst:965
msgid ""
"``ind = gf_model_set(model M, 'add linear incompressibility brick', "
"mesh_im mim, string varname, string multname_pressure[, int region[, "
"string dataexpr_coeff]])``"
msgstr ""

# 6e04ca5df96047fb8b99d81ba3523db1
#: ../source/matlab/cmdref_gf_model_set.rst:967
msgid ""
"Add a linear incompressibility condition on `variable`. "
"`multname_pressure` is a variable which represent the pressure. Be aware "
"that an inf-sup condition between the finite element method describing "
"the pressure and the primal variable has to be satisfied. `region` is an "
"optional mesh region on which the term is added. If it is not specified, "
"it is added on the whole mesh. `dataexpr_coeff` is an optional "
"penalization coefficient for nearly incompressible elasticity for "
"instance. In this case, it is the inverse of the Lame coefficient "
":math:`\\lambda`. Return the brick index in the model."
msgstr ""

# 2fc9e20936f54a32a97d48b240893080
#: ../source/matlab/cmdref_gf_model_set.rst:978
msgid ""
"``ind = gf_model_set(model M, 'add nonlinear elasticity brick', mesh_im "
"mim, string varname, string constitutive_law, string dataname[, int "
"region])``"
msgstr ""

# e8d4dfb1d5ca41c69fd78d4dc7871d23
#: ../source/matlab/cmdref_gf_model_set.rst:980
msgid ""
"Add a nonlinear elasticity term to the model relatively to the variable "
"`varname` (deprecated brick, use add_finite_strain_elaticity instead). "
"`lawname` is the constitutive law which could be 'SaintVenant Kirchhoff',"
" 'Mooney Rivlin', 'neo Hookean', 'Ciarlet Geymonat' or 'generalized Blatz"
" Ko'. 'Mooney Rivlin' and 'neo Hookean' law names can be preceded with "
"the word 'compressible' or 'incompressible' to force using the "
"corresponding version. The compressible version of these laws requires "
"one additional material coefficient. By default, the incompressible "
"version of 'Mooney Rivlin' law and the compressible one of the 'neo "
"Hookean' law are considered. In general, 'neo Hookean' is a special case "
"of the 'Mooney Rivlin' law that requires one coefficient less. IMPORTANT "
": if the variable is defined on a 2D mesh, the plane strain approximation"
" is automatically used. `dataname` is a vector of parameters for the "
"constitutive law. Its length depends on the law. It could be a short "
"vector of constant values or a vector field described on a finite element"
" method for variable coefficients. `region` is an optional mesh region on"
" which the term is added. If it is not specified, it is added on the "
"whole mesh. This brick use the low-level generic assembly. Returns the "
"brick index in the model."
msgstr ""

# fbb6980b135e4680bc2dabc2d4b77c29
#: ../source/matlab/cmdref_gf_model_set.rst:1003
msgid ""
"``ind = gf_model_set(model M, 'add finite strain elasticity brick', "
"mesh_im mim, string constitutive_law, string varname, string params[, int"
" region])``"
msgstr ""

# 2f87e778059d489c9e266d84a2fdbe11
#: ../source/matlab/cmdref_gf_model_set.rst:1005
msgid ""
"Add a nonlinear elasticity term to the model relatively to the variable "
"`varname`. `lawname` is the constitutive law which could be 'SaintVenant "
"Kirchhoff', 'Mooney Rivlin', 'Neo Hookean', 'Ciarlet Geymonat' or "
"'Generalized Blatz Ko'. 'Mooney Rivlin' and 'Neo Hookean' law names have "
"to be preceeded with the word 'Compressible' or 'Incompressible' to force"
" using the corresponding version. The compressible version of these laws "
"requires one additional material coefficient."
msgstr ""

# c27b8a1df5e948e3b74c1ee8cdf82efe
#: ../source/matlab/cmdref_gf_model_set.rst:1015
msgid ""
"IMPORTANT : if the variable is defined on a 2D mesh, the plane strain "
"approximation is automatically used. `params` is a vector of parameters "
"for the constitutive law. Its length depends on the law. It could be a "
"short vector of constant values or a vector field described on a finite "
"element method for variable coefficients. `region` is an optional mesh "
"region on which the term is added. If it is not specified, it is added on"
" the whole mesh. This brick use the high-level generic assembly. Returns "
"the brick index in the model."
msgstr ""

# 0409cbbd220f49c2bb21251b319f242a
#: ../source/matlab/cmdref_gf_model_set.rst:1026
msgid ""
"``ind = gf_model_set(model M, 'add small strain elastoplasticity brick', "
"mesh_im mim,  string lawname, string unknowns_type [, string varnames, "
"...] [, string params, ...] [, string theta = '1' [, string dt = "
"'timestep']] [, int region = -1])``"
msgstr ""

# 98ba5853fe47474bae4585936d23494f
#: ../source/matlab/cmdref_gf_model_set.rst:1028
msgid ""
"Adds a small strain plasticity term to the model `M`. This is the main "
"GetFEM++ brick for small strain plasticity. `lawname` is the name of an "
"implemented plastic law, `unknowns_type` indicates the choice between a "
"discretization where the plastic multiplier is an unknown of the problem "
"or (return mapping approach) just a data of the model stored for the next"
" iteration. Remember that in both cases, a multiplier is stored anyway. "
"`varnames` is a set of variable and data names with length which may "
"depend on the plastic law (at least the displacement, the plastic "
"multiplier and the plastic strain). `params` is a list of expressions for"
" the parameters (at least elastic coefficients and the yield stress). "
"These expressions can be some data names (or even variable names) of the "
"model but can also be any scalar valid expression of the high level "
"assembly language (such as '1/2', '2+sin(X[0])', '1+Norm(v)' ...). The "
"last two parameters optionally provided in `params` are the `theta` "
"parameter of the `theta`-scheme (generalized trapezoidal rule) used for "
"the plastic strain integration and the time-step`dt`. The default value "
"for `theta` if omitted is 1, which corresponds to the classical Backward "
"Euler scheme which is first order consistent. `theta=1/2` corresponds to "
"the Crank-Nicolson scheme (trapezoidal rule) which is second order "
"consistent. Any value between 1/2 and 1 should be a valid value. The "
"default value of `dt` is 'timestep' which simply indicates the time step "
"defined in the model (by md.set_time_step(dt)). Alternatively it can be "
"any expression (data name, constant value ...). The time step can be "
"altered from one iteration to the next one. `region` is a mesh region."
msgstr ""

# 478997ba6f594eed9d731f13dee7f3d0
#: ../source/matlab/cmdref_gf_model_set.rst:1054
msgid "The available plasticity laws are:"
msgstr ""

# f902e61fa9274674a286a7cec81af89e
#: ../source/matlab/cmdref_gf_model_set.rst:1056
msgid ""
"'Prandtl Reuss' (or 'isotropic perfect plasticity'). Isotropic elasto-"
"plasticity with no hardening. The variables are the displacement, the "
"plastic multiplier and the plastic strain. The displacement should be a "
"variable and have a corresponding data having the same name preceded by "
"'Previous\\_' corresponding to the displacement at the previous time step"
" (typically 'u' and 'Previous_u'). The plastic multiplier should also "
"have two versions (typically 'xi' and 'Previous_xi') the first one being "
"defined as data if `unknowns_type ` is 'DISPLACEMENT_ONLY' or the integer"
" value 0, or as a variable if `unknowns_type` is "
"DISPLACEMENT_AND_PLASTIC_MULTIPLIER or the integer value 1. The plastic "
"strain should represent a n x n data tensor field stored on mesh_fem or "
"(preferably) on an im_data (corresponding to `mim`). The data are the "
"first Lame coefficient, the second one (shear modulus) and the uniaxial "
"yield stress. A typical call is gf_model_get(model M, 'add small strain "
"elastoplasticity brick', mim, 'Prandtl Reuss', 0, 'u', 'xi', "
"'Previous_Ep', 'lambda', 'mu', 'sigma_y', '1', 'timestep'); IMPORTANT: "
"Note that this law implements the 3D expressions. If it is used in 2D, "
"the expressions are just transposed to the 2D. For the plane strain "
"approximation, see below."
msgstr ""

# dd255cb10a8b4876880b5b5d5299ab2f
#: ../source/matlab/cmdref_gf_model_set.rst:1075
msgid ""
"\"plane strain Prandtl Reuss\" (or \"plane strain isotropic perfect "
"plasticity\") The same law as the previous one but adapted to the plane "
"strain approximation. Can only be used in 2D."
msgstr ""

# 407520bd9c0e4643bd16c44af26e48a6
#: ../source/matlab/cmdref_gf_model_set.rst:1079
msgid ""
"\"Prandtl Reuss linear hardening\" (or \"isotropic plasticity linear "
"hardening\"). Isotropic elasto-plasticity with linear isotropic and "
"kinematic hardening. An additional variable compared to \"Prandtl Reuss\""
" law: the accumulated plastic strain. Similarly to the plastic strain, it"
" is only stored at the end of the time step, so a simple data is required"
" (preferably on an im_data). Two additional parameters: the kinematic "
"hardening modulus and the isotropic one. 3D expressions only. A typical "
"call is gf_model_get(model M, 'add small strain elastoplasticity brick', "
"mim, 'Prandtl Reuss linear hardening', 0, 'u', 'xi', 'Previous_Ep', "
"'Previous_alpha', 'lambda', 'mu', 'sigma_y', 'H_k', H_i', '1', "
"'timestep');"
msgstr ""

# c4bfb10422124324b2a14407a7c2fccb
#: ../source/matlab/cmdref_gf_model_set.rst:1089
msgid ""
"\"plane strain Prandtl Reuss linear hardening\" (or \"plane strain "
"isotropic plasticity linear hardening\"). The same law as the previous "
"one but adapted to the plane strain approximation. Can only be used in "
"2D."
msgstr ""

# 02fa23490ece4857a468b5db7305d5eb
#: ../source/matlab/cmdref_gf_model_set.rst:1094
msgid ""
"See GetFEM++ user documentation for further explanations on the "
"discretization of the plastic flow and on the implemented plastic laws. "
"See also GetFEM++ user documentation on time integration strategy "
"(integration of transient problems)."
msgstr ""

# 5798f2b2e77c49c7b7bd7e5e3653c2c7
#: ../source/matlab/cmdref_gf_model_set.rst:1099
msgid ""
"IMPORTANT : remember that `small_strain_elastoplasticity_next_iter` has "
"to be called at the end of each time step, before the next one (and "
"before any post-treatment : this sets the value of the plastic strain and"
" plastic multiplier)."
msgstr ""

# a9ba79fa4cf74f1bb5c8b9e05077ec30
#: ../source/matlab/cmdref_gf_model_set.rst:1106
msgid ""
"``ind = gf_model_set(model M, 'add elastoplasticity brick', mesh_im mim "
",string projname, string varname, string previous_dep_name, string "
"datalambda, string datamu, string datathreshold, string datasigma[, int "
"region])``"
msgstr ""

# b59e1e3a7f4a4f708f95260a1af7463b
#: ../source/matlab/cmdref_gf_model_set.rst:1108
msgid ""
"Old (obsolete) brick which do not use the high level generic assembly. "
"Add a nonlinear elastoplastic term to the model relatively to the "
"variable `varname`, in small deformations, for an isotropic material and "
"for a quasistatic model. `projname` is the type of projection that used: "
"only the Von Mises projection is available with 'VM' or 'Von Mises'. "
"`datasigma` is the variable representing the constraints on the material."
" `previous_dep_name` represents the displacement at the previous time "
"step. Moreover, the finite element method on which `varname` is described"
" is an K ordered mesh_fem, the `datasigma` one have to be at least an K-1"
" ordered mesh_fem. `datalambda` and `datamu` are the Lame coefficients of"
" the studied material. `datathreshold` is the plasticity threshold of the"
" material. The three last variables could be constants or described on "
"the same finite element method. `region` is an optional mesh region on "
"which the term is added. If it is not specified, it is added on the whole"
" mesh. Return the brick index in the model."
msgstr ""

# a56f4127cbcc44f9b92458d46ff94fed
#: ../source/matlab/cmdref_gf_model_set.rst:1129
msgid ""
"``ind = gf_model_set(model M, 'add finite strain elastoplasticity brick',"
" mesh_im mim , string lawname, string unknowns_type [, string varnames, "
"...] [, string params, ...] [, int region = -1])``"
msgstr ""

# 29180cfcba8c44ef9aea9fd6da5487e9
#: ../source/matlab/cmdref_gf_model_set.rst:1131
msgid ""
"Add a finite strain elastoplasticity brick to the model. For the moment "
"there is only one supported law defined through `lawname` as "
"\"Simo_Miehe\". This law supports to possibilities of unknown variables "
"to solve for defined by means of `unknowns_type` set to either "
"'DISPLACEMENT_AND_PLASTIC_MULTIPLIER' (integer value 1) or "
"'DISPLACEMENT_AND_PLASTIC_MULTIPLIER_AND_PRESSURE' (integer value 3). The"
"  \"Simo_Miehe\" law expects as `varnames` a set of the following names "
"that have to be defined as variables in the model:"
msgstr ""

# 057a96e6169443fbbb89d82d5de167a6
#: ../source/matlab/cmdref_gf_model_set.rst:1141
msgid "the displacement variable which has to be defined as an unknown,"
msgstr ""

# b7b6f94aff6d4f488fbd1760d960c91a
#: ../source/matlab/cmdref_gf_model_set.rst:1142
msgid "the plastic multiplier which has also defined as an unknown,"
msgstr ""

# 97a0819b729245c89358be06f43638a9
#: ../source/matlab/cmdref_gf_model_set.rst:1143
msgid ""
"optionally the pressure variable for a mixed displacement-pressure "
"formulation for 'DISPLACEMENT_AND_PLASTIC_MULTIPLIER_AND_PRESSURE' as "
"`unknowns_type`,"
msgstr ""

# cc9fa53600b7466f96e7bae8c867583b
#: ../source/matlab/cmdref_gf_model_set.rst:1146
msgid ""
"the name of a (scalar) fem_data or im_data field that holds the plastic "
"strain at the previous time step, and"
msgstr ""

# 655d59da52214b6fbeea14b60618a93b
#: ../source/matlab/cmdref_gf_model_set.rst:1148
msgid ""
"the name of a fem_data or im_data field that holds all non-repeated "
"components of the inverse of the plastic right Cauchy-Green tensor at the"
" previous time step (it has to be a 4 element vector for plane strain 2D "
"problems and a 6 element vector for 3D problems)."
msgstr ""

# 2f2118a6ff88417b8ebb116fa7887970
#: ../source/matlab/cmdref_gf_model_set.rst:1154
msgid ""
"The  \"Simo_Miehe\" law also expects as `params` a set of the following "
"three parameters:"
msgstr ""

# cc563ba700fa4ac7a55fc1d2dcbf75f5
#: ../source/matlab/cmdref_gf_model_set.rst:1157
msgid "an expression for the initial bulk modulus K,"
msgstr ""

# 513cefd42a9b4bfab6ccd16259a1da71
#: ../source/matlab/cmdref_gf_model_set.rst:1158
msgid "an expression for the initial shear modulus G,"
msgstr ""

# 02684027ef9840828a97d1001f69460a
#: ../source/matlab/cmdref_gf_model_set.rst:1159
msgid ""
"the name of a user predefined function that decribes the yield limit as a"
" function of the hardening variable (both the yield limit and the "
"hardening variable values are assumed to be Frobenius norms of "
"appropriate stress and strain tensors, respectively)."
msgstr ""

# da7d6896f4d743cc8a68277fa9678aba
#: ../source/matlab/cmdref_gf_model_set.rst:1165
msgid ""
"As usual, `region` is an optional mesh region on which the term is added."
" If it is not specified, it is added on the whole mesh. Return the brick "
"index in the model."
msgstr ""

# 7bc506513f2c4e56931232a199f3b6d0
#: ../source/matlab/cmdref_gf_model_set.rst:1170
msgid ""
"``ind = gf_model_set(model M, 'add nonlinear incompressibility brick', "
"mesh_im mim, string varname, string multname_pressure[, int region])``"
msgstr ""

# 1c045effa58347d392064fb9b78d9afc
#: ../source/matlab/cmdref_gf_model_set.rst:1172
msgid ""
"Add a nonlinear incompressibility condition on `variable` (for large "
"strain elasticity). `multname_pressure` is a variable which represent the"
" pressure. Be aware that an inf-sup condition between the finite element "
"method describing the pressure and the primal variable has to be "
"satisfied. `region` is an optional mesh region on which the term is "
"added. If it is not specified, it is added on the whole mesh. Return the "
"brick index in the model."
msgstr ""

# bd8e4d89784e4f49935a75930250dd69
#: ../source/matlab/cmdref_gf_model_set.rst:1181
msgid ""
"``ind = gf_model_set(model M, 'add finite strain incompressibility "
"brick', mesh_im mim, string varname, string multname_pressure[, int "
"region])``"
msgstr ""

# e47f232280094f9ba70b72d7f851f9c8
#: ../source/matlab/cmdref_gf_model_set.rst:1183
msgid ""
"Add a finite strain incompressibility condition on `variable` (for large "
"strain elasticity). `multname_pressure` is a variable which represent the"
" pressure. Be aware that an inf-sup condition between the finite element "
"method describing the pressure and the primal variable has to be "
"satisfied. `region` is an optional mesh region on which the term is "
"added. If it is not specified, it is added on the whole mesh. Return the "
"brick index in the model. This brick is equivalent to the ``nonlinear "
"incompressibility brick`` but uses the high-level generic assembly adding"
" the term ``p*(1-Det(Id(meshdim)+Grad_u))`` if ``p`` is the multiplier "
"and ``u`` the variable which represent the displacement."
msgstr ""

# 79363e8ce1e24a95af92ecd7ca6ddffa
#: ../source/matlab/cmdref_gf_model_set.rst:1196
msgid ""
"``ind = gf_model_set(model M, 'add bilaplacian brick', mesh_im mim, "
"string varname, string dataname [, int region])``"
msgstr ""

# cdb00717c5c64818a94d8645b53aa6d0
#: ../source/matlab/cmdref_gf_model_set.rst:1198
msgid ""
"Add a bilaplacian brick on the variable `varname` and on the mesh region "
"`region`. This represent a term :math:`\\Delta(D \\Delta u)`. where "
":math:`D(x)` is a coefficient determined by `dataname` which could be "
"constant or described on a f.e.m. The corresponding weak form is "
":math:`\\int D(x)\\Delta u(x) \\Delta v(x) dx`. Return the brick index in"
" the model."
msgstr ""

# ec752dc1822d4871ac351ce477dbd37c
#: ../source/matlab/cmdref_gf_model_set.rst:1207
msgid ""
"``ind = gf_model_set(model M, 'add Kirchhoff-Love plate brick', mesh_im "
"mim, string varname, string dataname_D, string dataname_nu [, int "
"region])``"
msgstr ""

# 1015a10315764385ad5e67824a1f25c8
#: ../source/matlab/cmdref_gf_model_set.rst:1209
msgid ""
"Add a bilaplacian brick on the variable `varname` and on the mesh region "
"`region`. This represent a term :math:`\\Delta(D \\Delta u)` where "
":math:`D(x)` is a the flexion modulus determined by `dataname_D`. The "
"term is integrated by part following a Kirchhoff-Love plate model with "
"`dataname_nu` the poisson ratio. Return the brick index in the model."
msgstr ""

# e4846627500c400ab20f980215707a70
#: ../source/matlab/cmdref_gf_model_set.rst:1218
msgid ""
"``ind = gf_model_set(model M, 'add normal derivative source term brick', "
"mesh_im mim, string varname, string dataname, int region)``"
msgstr ""

# d8b2c17ce8314891ac3f412fb912ff5e
#: ../source/matlab/cmdref_gf_model_set.rst:1220
msgid ""
"Add a normal derivative source term brick :math:`F = \\int b.\\partial_n "
"v` on the variable `varname` and the mesh region `region`."
msgstr ""

# 4021803615c84a0da82da148a5684937
#: ../source/matlab/cmdref_gf_model_set.rst:1224
msgid ""
"Update the right hand side of the linear system. `dataname` represents "
"`b` and `varname` represents `v`. Return the brick index in the model."
msgstr ""

# f3ad402673c3453bad4166ed20a1db55
#: ../source/matlab/cmdref_gf_model_set.rst:1229
msgid ""
"``ind = gf_model_set(model M, 'add Kirchhoff-Love Neumann term brick', "
"mesh_im mim, string varname, string dataname_M, string dataname_divM, int"
" region)``"
msgstr ""

# e2b47cabdc184a9ea6836cf474b40b16
#: ../source/matlab/cmdref_gf_model_set.rst:1231
msgid ""
"Add a Neumann term brick for Kirchhoff-Love model on the variable "
"`varname` and the mesh region `region`. `dataname_M` represents the "
"bending moment tensor and  `dataname_divM` its divergence. Return the "
"brick index in the model."
msgstr ""

# a518df68d99342ccba6e23f636118144
#: ../source/matlab/cmdref_gf_model_set.rst:1238
msgid ""
"``ind = gf_model_set(model M, 'add normal derivative Dirichlet condition "
"with multipliers', mesh_im mim, string varname, mult_description, int "
"region [, string dataname, int R_must_be_derivated])``"
msgstr ""

# abac18b2f2a945d78629a398c7e6425d
#: ../source/matlab/cmdref_gf_model_set.rst:1240
msgid ""
"Add a Dirichlet condition on the normal derivative of the variable "
"`varname` and on the mesh region `region` (which should be a boundary. "
"The general form is :math:`\\int \\partial_n u(x)v(x) = \\int r(x)v(x) "
"\\forall v` where :math:`r(x)` is the right hand side for the Dirichlet "
"condition (0 for homogeneous conditions) and :math:`v` is in a space of "
"multipliers defined by `mult_description`. If `mult_description` is a "
"string this is assumed to be the variable name corresponding to the "
"multiplier (which should be first declared as a multiplier variable on "
"the mesh region in the model). If it is a finite element method (mesh_fem"
" object) then a multiplier variable will be added to the model and build "
"on this finite element method (it will be restricted to the mesh region "
"`region` and eventually some conflicting dofs with some other multiplier "
"variables will be suppressed). If it is an integer, then a  multiplier "
"variable will be added to the model and build on a classical finite "
"element of degree that integer. `dataname` is an optional parameter which"
" represents the right hand side of the Dirichlet condition. If "
"`R_must_be_derivated` is set to `true` then the normal derivative of "
"`dataname` is considered. Return the brick index in the model."
msgstr ""

# 8224344b8c9d42ef90f4cf36a7f4f404
#: ../source/matlab/cmdref_gf_model_set.rst:1264
msgid ""
"``ind = gf_model_set(model M, 'add normal derivative Dirichlet condition "
"with penalization', mesh_im mim, string varname, scalar coeff, int region"
" [, string dataname, int R_must_be_derivated])``"
msgstr ""

# 3331b1873db040df9dc1b00446bb7004
#: ../source/matlab/cmdref_gf_model_set.rst:1266
msgid ""
"Add a Dirichlet condition on the normal derivative of the variable "
"`varname` and on the mesh region `region` (which should be a boundary. "
"The general form is :math:`\\int \\partial_n u(x)v(x) = \\int r(x)v(x) "
"\\forall v` where :math:`r(x)` is the right hand side for the Dirichlet "
"condition (0 for homogeneous conditions). The penalization coefficient is"
" initially `coeff` and will be added to the data of the model. It can be "
"changed with the command gf_model_set(model M, 'change penalization "
"coeff'). `dataname` is an optional parameter which represents the right "
"hand side of the Dirichlet condition. If `R_must_be_derivated` is set to "
"`true` then the normal derivative of `dataname` is considered. Return the"
" brick index in the model."
msgstr ""

# 5806ec84a33a40efb260b5595b1507c8
#: ../source/matlab/cmdref_gf_model_set.rst:1283
msgid ""
"``ind = gf_model_set(model M, 'add Mindlin Reissner plate brick', mesh_im"
" mim, mesh_im mim_reduced, string varname_u3, string varname_theta , "
"string param_E, string param_nu, string param_epsilon, string param_kappa"
" [,int variant [, int region]])``"
msgstr ""

# ec007200bb334b02b7cb73a9c935d3f8
#: ../source/matlab/cmdref_gf_model_set.rst:1285
msgid ""
"Add a term corresponding to the classical Reissner-Mindlin plate model "
"for which `varname_u3` is the transverse displacement, `varname_theta` "
"the rotation of fibers normal to the midplane, 'param_E' the Young "
"Modulus, `param_nu` the poisson ratio, `param_epsilon` the plate "
"thickness, `param_kappa` the shear correction factor. Note that since "
"this brick uses the high level generic assembly language, the parameter "
"can be regular expression of this language. There are three variants. "
"`variant = 0` corresponds to the an unreduced formulation and in that "
"case only the integration method `mim` is used. Practically this variant "
"is not usable since it is subject to a strong locking phenomenon. "
"`variant = 1` corresponds to a reduced integration where `mim` is used "
"for the rotation term and `mim_reduced` for the transverse shear term. "
"`variant = 2` (default) corresponds to the projection onto a rotated RT0 "
"element of the transverse shear term. For the moment, this is adapted to "
"quadrilateral only (because it is not sufficient to remove the locking "
"phenomenon on triangle elements). Note also that if you use high order "
"elements, the projection on RT0 will reduce the order of the "
"approximation. Returns the brick index in the model."
msgstr ""

# 5a0106439c5546529becacfd1689837a
#: ../source/matlab/cmdref_gf_model_set.rst:1311
msgid ""
"``ind = gf_model_set(model M, 'add mass brick', mesh_im mim, string "
"varname[, string dataexpr_rho[, int region]])``"
msgstr ""

# 60a6536ace9a41f0955a9308568a8db6
#: ../source/matlab/cmdref_gf_model_set.rst:1313
msgid ""
"Add mass term to the model relatively to the variable `varname`. If "
"specified, the data `dataexpr_rho` is the density (1 if omitted). "
"`region` is an optional mesh region on which the term is added. If it is "
"not specified, it is added on the whole mesh. Return the brick index in "
"the model."
msgstr ""

# f71002adfdee4e07b58eb90adaa52920
#: ../source/matlab/cmdref_gf_model_set.rst:1320
msgid "``gf_model_set(model M, 'shift variables for time integration')``"
msgstr ""

# 5ede1cc856144424830e0da8d9b3292b
#: ../source/matlab/cmdref_gf_model_set.rst:1322
msgid ""
"Function used to shift the variables of a model to the data corresponding"
" of ther value on the previous time step for time integration schemes. "
"For each variable for which a time integration scheme has been declared, "
"the scheme is called to perform the shift. This function has to be called"
" between two time steps."
msgstr ""

# f279e4f74eed4ef6a5ce31366e36a93f
#: ../source/matlab/cmdref_gf_model_set.rst:1329
msgid "``gf_model_set(model M, 'perform init time derivative', scalar ddt)``"
msgstr ""

# ba158b0ef8a24fe19af9b87a4d778f66
#: ../source/matlab/cmdref_gf_model_set.rst:1331
msgid ""
"By calling this function, indicates that the next solve will compute the "
"solution for a (very) small time step `ddt` in order to initalize the "
"data corresponding to the derivatives needed by time integration schemes "
"(mainly the initial time derivative for order one in time problems  and "
"the second order time derivative for second order in time problems). The "
"next solve will not change the value of the variables."
msgstr ""

# 83e3d55953f4452e9e2dc0069653c7a2
#: ../source/matlab/cmdref_gf_model_set.rst:1339
msgid "``gf_model_set(model M, 'set time step', scalar dt)``"
msgstr ""

# 2569f2e49ca5454ca1c5878450c858a5
#: ../source/matlab/cmdref_gf_model_set.rst:1341
msgid ""
"Set the value of the time step to `dt`. This value can be change from a "
"step to another for all one-step schemes (i.e for the moment to all "
"proposed time integration schemes)."
msgstr ""

# 3eefee4f42ad469a974888bbe8a4bb43
#: ../source/matlab/cmdref_gf_model_set.rst:1346
msgid "``gf_model_set(model M, 'set time', scalar t)``"
msgstr ""

# 5e1b3f204ee9453ca128e27dcfca7979
#: ../source/matlab/cmdref_gf_model_set.rst:1348
msgid "Set the value of the data `t` corresponding to the current time to `t`."
msgstr ""

# 9c6d0911b4194557897b221bf4b28236
#: ../source/matlab/cmdref_gf_model_set.rst:1352
msgid ""
"``gf_model_set(model M, 'add theta method for first order', string "
"varname, scalar theta)``"
msgstr ""

# 5632a727904c4ee5b4319d243fd83276
#: ../source/matlab/cmdref_gf_model_set.rst:1354
msgid ""
"Attach a theta method for the time discretization of the variable "
"`varname`. Valid only if there is at most first order time derivative of "
"the variable."
msgstr ""

# 983329990e454360a6add255b90f35c0
#: ../source/matlab/cmdref_gf_model_set.rst:1359
msgid ""
"``gf_model_set(model M, 'add theta method for second order', string "
"varname, scalar theta)``"
msgstr ""

# 5cf102fca29f4b32a62feb74e0612654
# 9c2c341b3773449e8b30abbb7e996ffe
#: ../source/matlab/cmdref_gf_model_set.rst:1361
#: ../source/matlab/cmdref_gf_model_set.rst:1368
msgid ""
"Attach a theta method for the time discretization of the variable "
"`varname`. Valid only if there is at most second order time derivative of"
" the variable."
msgstr ""

# 2dad14e9c3404dbda3dd09e51a2494bd
#: ../source/matlab/cmdref_gf_model_set.rst:1366
msgid ""
"``gf_model_set(model M, 'add Newmark scheme', string varname, scalar "
"beta, scalar gamma)``"
msgstr ""

# 689a76c705654ec3b43c6fc50b5b5abc
#: ../source/matlab/cmdref_gf_model_set.rst:1373
msgid "``gf_model_set(model M, 'disable bricks', ivec bricks_indices)``"
msgstr ""

# 93726686aa5443cdaaf6f92df0e22696
#: ../source/matlab/cmdref_gf_model_set.rst:1375
msgid ""
"Disable a brick (the brick will no longer participate to the building of "
"the tangent linear system)."
msgstr ""

# b6de3aa181474aefbaa044f13d936fbc
#: ../source/matlab/cmdref_gf_model_set.rst:1379
msgid "``gf_model_set(model M, 'enable bricks', ivec bricks_indices)``"
msgstr ""

# a1085c47749e4f35b4e427f8a192d6cf
#: ../source/matlab/cmdref_gf_model_set.rst:1381
msgid "Enable a disabled brick."
msgstr ""

# 428fd6da31e549679b5bc05087d3435d
#: ../source/matlab/cmdref_gf_model_set.rst:1384
msgid "``gf_model_set(model M, 'disable variable', string varname)``"
msgstr ""

# ed297331b521483da7e4ff18aabb5fd1
#: ../source/matlab/cmdref_gf_model_set.rst:1386
msgid ""
"Disable a variable for a solve (and its attached multipliers). The next "
"solve will operate only on the remaining variables. This allows to solve "
"separately different parts of a model. If there is a strong coupling of "
"the variables, a fixed point strategy can the be used."
msgstr ""

# 764090d086434aa5bbda9035578c9be2
#: ../source/matlab/cmdref_gf_model_set.rst:1393
msgid "``gf_model_set(model M, 'enable variable', string varname)``"
msgstr ""

# dcbc62af38de457d88f89dbedaa30b85
#: ../source/matlab/cmdref_gf_model_set.rst:1395
msgid "Enable a disabled variable (and its attached multipliers)."
msgstr ""

# 4ef9b015a4734ec8bbf0c62d37aa16c3
#: ../source/matlab/cmdref_gf_model_set.rst:1398
msgid "``gf_model_set(model M, 'first iter')``"
msgstr ""

# 95df4afd71394b94a883248c9c8abc2d
#: ../source/matlab/cmdref_gf_model_set.rst:1400
msgid "To be executed before the first iteration of a time integration scheme."
msgstr ""

# 0f8f895c89bc472f823b4e152cd4c9f5
#: ../source/matlab/cmdref_gf_model_set.rst:1404
msgid "``gf_model_set(model M, 'next iter')``"
msgstr ""

# e65fd39d4d92434f90de1ce933c7bdbf
#: ../source/matlab/cmdref_gf_model_set.rst:1406
msgid "To be executed at the end of each iteration of a time integration scheme."
msgstr ""

# 1ab6633f6a75493c88d1e2d6620b7319
#: ../source/matlab/cmdref_gf_model_set.rst:1410
msgid ""
"``ind = gf_model_set(model M, 'add basic contact brick', string "
"varname_u, string multname_n[, string multname_t], string dataname_r, "
"spmat BN[, spmat BT, string dataname_friction_coeff][, string "
"dataname_gap[, string dataname_alpha[, int augmented_version[, string "
"dataname_gamma, string dataname_wt]]])``"
msgstr ""

# 3d1184cfa6594885900080612a7d3d7c
#: ../source/matlab/cmdref_gf_model_set.rst:1412
msgid ""
"Add a contact with or without friction brick to the model. If U is the "
"vector of degrees of freedom on which the unilateral constraint is "
"applied, the matrix `BN` have to be such that this constraint is defined "
"by :math:`B_N U \\le 0`. A friction condition can be considered by adding"
" the three parameters `multname_t`, `BT` and `dataname_friction_coeff`. "
"In this case, the tangential displacement is :math:`B_T U` and the matrix"
" `BT` should have as many rows as `BN` multiplied by :math:`d-1` where "
":math:`d` is the domain dimension. In this case also, "
"`dataname_friction_coeff` is a data which represents the coefficient of "
"friction. It can be a scalar or a vector representing a value on each "
"contact condition.  The unilateral constraint is prescribed thank to a "
"multiplier `multname_n` whose dimension should be equal to the number of "
"rows of `BN`. If a friction condition is added, it is prescribed with a "
"multiplier `multname_t` whose dimension should be equal to the number of "
"rows of `BT`. The augmentation parameter `r` should be chosen in a range "
"of acceptabe values (see Getfem user documentation). `dataname_gap` is an"
" optional parameter representing the initial gap. It can be a single "
"value or a vector of value. `dataname_alpha` is an optional "
"homogenization parameter for the augmentation parameter (see Getfem user "
"documentation).  The parameter `augmented_version` indicates the "
"augmentation strategy : 1 for the non-symmetric Alart-Curnier augmented "
"Lagrangian, 2 for the symmetric one (except for the coupling between "
"contact and Coulomb friction), 3 for the unsymmetric method with "
"augmented multipliers, 4 for the unsymmetric method with augmented "
"multipliers and De Saxce projection."
msgstr ""

# 56c9ea2747884fec992417ba1c4da064
#: ../source/matlab/cmdref_gf_model_set.rst:1442
msgid ""
"``ind = gf_model_set(model M, 'add basic contact brick two deformable "
"bodies', string varname_u1, string varname_u2, string multname_n, string "
"dataname_r, spmat BN1, spmat BN2[, string dataname_gap[, string "
"dataname_alpha[, int augmented_version]]])``"
msgstr ""

# 21ce9b69cbee4fce87bd6b3eabba2900
#: ../source/matlab/cmdref_gf_model_set.rst:1461
msgid "Add a frictionless contact condition to the model between two deformable"
msgstr ""

# 66f72d94e6cc48c09d243c00fcd765d2
#: ../source/matlab/cmdref_gf_model_set.rst:1445
msgid ""
"bodies. If U1, U2 are the vector of degrees of freedom on which the "
"unilateral constraint is applied, the matrices `BN1` and `BN2` have to be"
" such that this condition is defined by $B_{N1} U_1 B_{N2} U_2 + \\le "
"gap$. The constraint is prescribed thank to a multiplier `multname_n` "
"whose dimension should be equal to the number of lines of `BN`. The "
"augmentation parameter `r` should be chosen in a range of acceptabe "
"values (see Getfem user documentation). `dataname_gap` is an optional "
"parameter representing the initial gap. It can be a single value or a "
"vector of value. `dataname_alpha` is an optional homogenization parameter"
" for the augmentation parameter (see Getfem user documentation). The "
"parameter `aug_version` indicates the augmentation strategy : 1 for the "
"non-symmetric Alart-Curnier augmented Lagrangian, 2 for the symmetric "
"one, 3 for the unsymmetric method with augmented multiplier."
msgstr ""

# 6902e09e294d4283a395109377cccc2f
#: ../source/matlab/cmdref_gf_model_set.rst:1463
msgid "``gf_model_set(model M, 'contact brick set BN', int indbrick, spmat BN)``"
msgstr ""

# 21f09f722acc453d975b664e3d4f44e8
#: ../source/matlab/cmdref_gf_model_set.rst:1465
msgid "Can be used to set the BN matrix of a basic contact/friction brick."
msgstr ""

# fdd55d86bf8e4fc2af3e32dc760302f5
#: ../source/matlab/cmdref_gf_model_set.rst:1468
msgid "``gf_model_set(model M, 'contact brick set BT', int indbrick, spmat BT)``"
msgstr ""

# dc47587b50c84c138e48c8d390919fdf
#: ../source/matlab/cmdref_gf_model_set.rst:1470
msgid "Can be used to set the BT matrix of a basic contact with friction brick."
msgstr ""

# c00b255217c74d1fa2a2748bc3b5dcfb
#: ../source/matlab/cmdref_gf_model_set.rst:1474
msgid ""
"``ind = gf_model_set(model M, 'add nodal contact with rigid obstacle "
"brick',  mesh_im mim, string varname_u, string multname_n[, string "
"multname_t], string dataname_r[, string dataname_friction_coeff], int "
"region, string obstacle[,  int augmented_version])``"
msgstr ""

# 53d97f96d3f940a1adc4b47ed827bf51
#: ../source/matlab/cmdref_gf_model_set.rst:1476
msgid ""
"Add a contact with or without friction condition with a rigid obstacle to"
" the model. The condition is applied on the variable `varname_u` on the "
"boundary corresponding to `region`. The rigid obstacle should be "
"described with the string `obstacle` being a signed distance to the "
"obstacle. This string should be an expression where the coordinates are "
"'x', 'y' in 2D and 'x', 'y', 'z' in 3D. For instance, if the rigid "
"obstacle correspond to :math:`z \\le 0`, the corresponding signed "
"distance will be simply \"z\". `multname_n` should be a fixed size "
"variable whose size is the number of degrees of freedom on boundary "
"`region`. It represents the contact equivalent nodal forces. In order to "
"add a friction condition one has to add the `multname_t` and "
"`dataname_friction_coeff` parameters. `multname_t` should be a fixed size"
" variable whose size is the number of degrees of freedom on boundary "
"`region` multiplied by :math:`d-1` where :math:`d` is the domain "
"dimension. It represents the friction equivalent nodal forces. The "
"augmentation parameter `r` should be chosen in a range of acceptabe "
"values (close to the Young modulus of the elastic body, see Getfem user "
"documentation).  `dataname_friction_coeff` is the friction coefficient. "
"It could be a scalar or a vector of values representing the friction "
"coefficient on each contact node. The parameter `augmented_version` "
"indicates the augmentation strategy : 1 for the non-symmetric Alart-"
"Curnier augmented Lagrangian, 2 for the symmetric one (except for the "
"coupling between contact and Coulomb friction), 3 for the new unsymmetric"
" method. Basically, this brick compute the matrix BN and the vectors gap "
"and alpha and calls the basic contact brick."
msgstr ""

# 8cc7a4f3219e406093a10b5307cf204e
#: ../source/matlab/cmdref_gf_model_set.rst:1505
msgid ""
"``ind = gf_model_set(model M, 'add contact with rigid obstacle brick',  "
"mesh_im mim, string varname_u, string multname_n[, string multname_t], "
"string dataname_r[, string dataname_friction_coeff], int region, string "
"obstacle[,  int augmented_version])``"
msgstr ""

# f022160361514ff7830f6796a2cdd28c
#: ../source/matlab/cmdref_gf_model_set.rst:1507
msgid ""
"DEPRECATED FUNCTION. Use 'add nodal contact with rigid obstacle brick' "
"instead."
msgstr ""

# 2f151926a5e847b39820fb9c2043b3de
#: ../source/matlab/cmdref_gf_model_set.rst:1510
msgid ""
"``ind = gf_model_set(model M, 'add integral contact with rigid obstacle "
"brick',  mesh_im mim, string varname_u, string multname, string "
"dataname_obstacle, string dataname_r [, string dataname_friction_coeff], "
"int region [, int option [, string dataname_alpha [, string dataname_wt "
"[, string dataname_gamma [, string dataname_vt]]]]])``"
msgstr ""

# 5188a27a066040bdb11cb0d4e2baebee
#: ../source/matlab/cmdref_gf_model_set.rst:1512
msgid ""
"Add a contact with or without friction condition with a rigid obstacle to"
" the model. This brick adds a contact which is defined in an integral "
"way. It is the direct approximation of an augmented Lagrangian "
"formulation (see Getfem user documentation) defined at the continuous "
"level. The advantage is a better scalability: the number of Newton "
"iterations should be more or less independent of the mesh size. The "
"contact condition is applied on the variable `varname_u` on the boundary "
"corresponding to `region`. The rigid obstacle should be described with "
"the data `dataname_obstacle` being a signed distance to the obstacle "
"(interpolated on a finite element method). `multname` should be a fem "
"variable representing the contact stress. An inf-sup condition beetween "
"`multname` and `varname_u` is required. The augmentation parameter "
"`dataname_r` should be chosen in a range of acceptabe values. The "
"optional parameter `dataname_friction_coeff` is the friction coefficient "
"which could be constant or defined on a finite element method. Possible "
"values for `option` is 1 for the non-symmetric Alart-Curnier augmented "
"Lagrangian method, 2 for the symmetric one, 3 for the non-symmetric "
"Alart-Curnier method with an additional augmentation and 4 for a new "
"unsymmetric method. The default value is 1. In case of contact with "
"friction, `dataname_alpha` and `dataname_wt` are optional parameters to "
"solve evolutionary friction problems. `dataname_gamma` and `dataname_vt` "
"represent optional data for adding a parameter-dependent sliding velocity"
" to the friction condition."
msgstr ""

# a342b662f7b6495fb483cbe20b78e5b9
#: ../source/matlab/cmdref_gf_model_set.rst:1539
msgid ""
"``ind = gf_model_set(model M, 'add penalized contact with rigid obstacle "
"brick',  mesh_im mim, string varname_u, string dataname_obstacle, string "
"dataname_r [, string dataname_coeff], int region [, int option, string "
"dataname_lambda, [, string dataname_alpha [, string dataname_wt]]])``"
msgstr ""

# 78521f1ff5b148099882a168849b070d
#: ../source/matlab/cmdref_gf_model_set.rst:1541
msgid ""
"Add a penalized contact with or without friction condition with a rigid "
"obstacle to the model. The condition is applied on the variable "
"`varname_u` on the boundary corresponding to `region`. The rigid obstacle"
" should be described with the data `dataname_obstacle` being a signed "
"distance to the obstacle (interpolated on a finite element method). The "
"penalization parameter `dataname_r` should be chosen large enough to "
"prescribe approximate non-penetration and friction conditions but not too"
" large not to deteriorate too much the conditionning of the tangent "
"system. `dataname_lambda` is an optional parameter used if option is 2. "
"In that case, the penalization term is shifted by lambda (this allows the"
" use of an Uzawa algorithm on the corresponding augmented Lagrangian "
"formulation)"
msgstr ""

# 001802bf6bb0429ab129bca60b18866c
#: ../source/matlab/cmdref_gf_model_set.rst:1558
msgid ""
"``ind = gf_model_set(model M, 'add Nitsche contact with rigid obstacle "
"brick', mesh_im mim, string varname, string Neumannterm, string "
"dataname_obstacle, string gamma0name,  int region[, scalar theta[, string"
" dataname_friction_coeff[, string dataname_alpha, string "
"dataname_wt]]])``"
msgstr ""

# a921a2f819ed46fcbdb2f5567eec4bb4
#: ../source/matlab/cmdref_gf_model_set.rst:1560
msgid ""
"Adds a contact condition with or without Coulomb friction on the variable"
" `varname` and the mesh boundary `region`. The contact condition is "
"prescribed with Nitsche's method. The rigid obstacle should be described "
"with the data `dataname_obstacle` being a signed distance to the obstacle"
" (interpolated on a finite element method). `gamma0name` is the Nitsche's"
" method parameter. `theta` is a scalar value which can be positive or "
"negative. `theta = 1` corresponds to the standard symmetric method which "
"is conditionnaly coercive for  `gamma0` small. `theta = -1` corresponds "
"to the skew-symmetric method which is inconditionnaly coercive. `theta = "
"0` is the simplest method for which the second derivative of the Neumann "
"term is not necessary. The optional parameter `dataname_friction_coeff` "
"is the friction coefficient which could be constant or defined on a "
"finite element method. CAUTION: This brick has to be added in the model "
"after all the bricks corresponding to partial differential terms having a"
" Neumann term. Moreover, This brick can only be applied to bricks "
"declaring their Neumann terms. Returns the brick index in the model."
msgstr ""

# 486b6712828c4952bf28bea9cf29c29a
#: ../source/matlab/cmdref_gf_model_set.rst:1582
msgid ""
"``ind = gf_model_set(model M, 'add Nitsche midpoint contact with rigid "
"obstacle brick', mesh_im mim, string varname, string Neumannterm, string "
"Neumannterm_wt, string dataname_obstacle, string gamma0name,  int region,"
" scalar theta, string dataname_friction_coeff, string dataname_alpha, "
"string dataname_wt)``"
msgstr ""

# a70e5ca842354a97bdbde56f4514e66e
#: ../source/matlab/cmdref_gf_model_set.rst:1584
msgid ""
"EXPERIMENTAL BRICK: for midpoint scheme only !! Adds a contact condition "
"with or without Coulomb friction on the variable `varname` and the mesh "
"boundary `region`. The contact condition is prescribed with Nitsche's "
"method. The rigid obstacle should be described with the data "
"`dataname_obstacle` being a signed distance to the obstacle (interpolated"
" on a finite element method). `gamma0name` is the Nitsche's method "
"parameter. `theta` is a scalar value which can be positive or negative. "
"`theta = 1` corresponds to the standard symmetric method which is "
"conditionnaly coercive for  `gamma0` small. `theta = -1` corresponds to "
"the skew-symmetric method which is inconditionnaly coercive. `theta = 0` "
"is the simplest method for which the second derivative of the Neumann "
"term is not necessary. The optional parameter `dataname_friction_coeff` "
"is the friction coefficient which could be constant or defined on a "
"finite element method. Returns the brick index in the model."
msgstr ""

# 280833cdc7cb4b98858f30d70bbaebd7
#: ../source/matlab/cmdref_gf_model_set.rst:1605
msgid ""
"``ind = gf_model_set(model M, 'add Nitsche fictitious domain contact "
"brick', mesh_im mim, string varname1, string varname2, string "
"dataname_d1, string dataname_d2, string gamma0name [, scalar theta[, "
"string dataname_friction_coeff[, string dataname_alpha, string "
"dataname_wt1,string dataname_wt2]]])``"
msgstr ""

# 07179f0b4899492d9e5e83128c758e9a
#: ../source/matlab/cmdref_gf_model_set.rst:1607
msgid ""
"Adds a contact condition with or without Coulomb friction between two "
"bodies in a fictitious domain. The contact condition is applied on the "
"variable `varname_u1` corresponds with the first and slave body with "
"Nitsche's method and on the variable `varname_u2` corresponds with the "
"second and master body with Nitsche's method. The contact condition is "
"evaluated on the fictitious slave boundary. The first body should be "
"described by the level-set `dataname_d1` and the second body should be "
"described by the level-set `dataname_d2`. `gamma0name` is the Nitsche's "
"method parameter. `theta` is a scalar value which can be positive or "
"negative. `theta = 1` corresponds to the standard symmetric method which "
"is conditionnaly coercive for  `gamma0` small. `theta = -1` corresponds "
"to the skew-symmetric method which is inconditionnaly coercive. `theta = "
"0` is the simplest method for which the second derivative of the Neumann "
"term is not necessary. The optional parameter `dataname_friction_coeff` "
"is the friction coefficient which could be constant or defined on a "
"finite element method. CAUTION: This brick has to be added in the model "
"after all the bricks corresponding to partial differential terms having a"
" Neumann term. Moreover, This brick can only be applied to bricks "
"declaring their Neumann terms. Returns the brick index in the model."
msgstr ""

# 957c1a95433747caafe86fe5db363a8d
#: ../source/matlab/cmdref_gf_model_set.rst:1630
msgid ""
"``ind = gf_model_set(model M, 'add nodal contact between nonmatching "
"meshes brick',  mesh_im mim1[, mesh_im mim2], string varname_u1[, string "
"varname_u2], string multname_n[, string multname_t], string dataname_r[, "
"string dataname_fr], int rg1, int rg2[, int slave1, int slave2,  int "
"augmented_version])``"
msgstr ""

# 703c409fc89340b6ba4eb94110ca12c6
#: ../source/matlab/cmdref_gf_model_set.rst:1632
msgid ""
"Add a contact with or without friction condition between two faces of one"
" or two elastic bodies. The condition is applied on the variable "
"`varname_u1` or the variables `varname_u1` and `varname_u2` depending if "
"a single or two distinct displacement fields are given. Integers `rg1` "
"and `rg2` represent the regions expected to come in contact with each "
"other. In the single displacement variable case the regions defined in "
"both `rg1` and `rg2` refer to the variable `varname_u1`. In the case of "
"two displacement variables, `rg1` refers to `varname_u1` and `rg2` refers"
" to `varname_u2`. `multname_n` should be a fixed size variable whose size"
" is the number of degrees of freedom on those regions among the ones "
"defined in `rg1` and `rg2` which are characterized as \"slaves\". It "
"represents the contact equivalent nodal normal forces. `multname_t` "
"should be a fixed size variable whose size corresponds to the size of "
"`multname_n` multiplied by qdim - 1 . It represents the contact "
"equivalent nodal tangent (frictional) forces. The augmentation parameter "
"`r` should be chosen in a range of acceptabe values (close to the Young "
"modulus of the elastic body, see Getfem user documentation). The friction"
" coefficient stored in the parameter `fr` is either a single value or a "
"vector of the same size as `multname_n`. The optional parameters `slave1`"
" and `slave2` declare if the regions defined in `rg1` and `rg2` are "
"correspondingly considered as \"slaves\". By default `slave1` is true and"
" `slave2` is false, i.e. `rg1` contains the slave surfaces, while 'rg2' "
"the master surfaces. Preferrably only one of `slave1` and `slave2` is set"
" to true.  The parameter `augmented_version` indicates the augmentation "
"strategy : 1 for the non-symmetric Alart-Curnier augmented Lagrangian, 2 "
"for the symmetric one (except for the coupling between contact and "
"Coulomb friction), 3 for the new unsymmetric method. Basically, this "
"brick computes the matrices BN and BT and the vectors gap and alpha and "
"calls the basic contact brick."
msgstr ""

# 51177ed6539042dcbed8d6023e85060d
#: ../source/matlab/cmdref_gf_model_set.rst:1664
msgid ""
"``ind = gf_model_set(model M, 'add nonmatching meshes contact brick',  "
"mesh_im mim1[, mesh_im mim2], string varname_u1[, string varname_u2], "
"string multname_n[, string multname_t], string dataname_r[, string "
"dataname_fr], int rg1, int rg2[, int slave1, int slave2,  int "
"augmented_version])``"
msgstr ""

# f5ba65717c9c42b59ef6cb4c4f0afa98
#: ../source/matlab/cmdref_gf_model_set.rst:1666
msgid ""
"DEPRECATED FUNCTION. Use 'add nodal contact between nonmatching meshes "
"brick' instead."
msgstr ""

# 3846a75a966e481e86fc00d2ebe8f678
#: ../source/matlab/cmdref_gf_model_set.rst:1669
msgid ""
"``ind = gf_model_set(model M, 'add integral contact between nonmatching "
"meshes brick',  mesh_im mim, string varname_u1, string varname_u2, string"
" multname, string dataname_r [, string dataname_friction_coeff], int "
"region1, int region2 [, int option [, string dataname_alpha [, string "
"dataname_wt1 , string dataname_wt2]]])``"
msgstr ""

# 5a63b77a71e84d9cb4264bd8544aed7e
#: ../source/matlab/cmdref_gf_model_set.rst:1671
msgid ""
"Add a contact with or without friction condition between nonmatching "
"meshes to the model. This brick adds a contact which is defined in an "
"integral way. It is the direct approximation of an augmented agrangian "
"formulation (see Getfem user documentation) defined at the continuous "
"level. The advantage should be a better scalability: the number of Newton"
" iterations should be more or less independent of the mesh size. The "
"condition is applied on the variables `varname_u1` and `varname_u2` on "
"the boundaries corresponding to `region1` and `region2`. `multname` "
"should be a fem variable representing the contact stress for the "
"frictionless case and the contact and friction stress for the case with "
"friction. An inf-sup condition between `multname` and `varname_u1` and "
"`varname_u2` is required. The augmentation parameter `dataname_r` should "
"be chosen in a range of acceptable values. The optional parameter "
"`dataname_friction_coeff` is the friction coefficient which could be "
"constant or defined on a finite element method on the same mesh as "
"`varname_u1`. Possible values for `option` is 1 for the non-symmetric "
"Alart-Curnier augmented Lagrangian method, 2 for the symmetric one, 3 for"
" the non-symmetric Alart-Curnier method with an additional augmentation "
"and 4 for a new unsymmetric method. The default value is 1. In case of "
"contact with friction, `dataname_alpha`, `dataname_wt1` and "
"`dataname_wt2` are optional parameters to solve evolutionary friction "
"problems."
msgstr ""

# fa96dd16eb0045e4bbec3e51c605cb4e
#: ../source/matlab/cmdref_gf_model_set.rst:1699
msgid ""
"``ind = gf_model_set(model M, 'add penalized contact between nonmatching "
"meshes brick',  mesh_im mim, string varname_u1, string varname_u2, string"
" dataname_r [, string dataname_coeff], int region1, int region2 [, int "
"option [, string dataname_lambda, [, string dataname_alpha [, string "
"dataname_wt1, string dataname_wt2]]]])``"
msgstr ""

# f7d466c1520048f69b44d61aaf3ce6b7
#: ../source/matlab/cmdref_gf_model_set.rst:1701
msgid ""
"Add a penalized contact condition with or without friction between "
"nonmatching meshes to the model. The condition is applied on the "
"variables `varname_u1` and  `varname_u2` on the boundaries corresponding "
"to `region1` and `region2`. The penalization parameter `dataname_r` "
"should be chosen large enough to prescribe approximate non-penetration "
"and friction conditions but not too large not to deteriorate too much the"
" conditionning of the tangent system. The optional parameter "
"`dataname_friction_coeff` is the friction coefficient which could be "
"constant or defined on a finite element method on the same mesh as "
"`varname_u1`. `dataname_lambda` is an optional parameter used if option "
"is 2. In that case, the penalization term is shifted by lambda (this "
"allows the use of an Uzawa algorithm on the corresponding augmented "
"Lagrangian formulation) In case of contact with friction, "
"`dataname_alpha`, `dataname_wt1` and `dataname_wt2` are optional "
"parameters to solve evolutionary friction problems."
msgstr ""

# 9d33338fc2094faca9103a54d9add7f8
#: ../source/matlab/cmdref_gf_model_set.rst:1722
msgid ""
"``ind = gf_model_set(model M, 'add integral large sliding contact brick "
"raytracing', string dataname_r, scalar release_distance, [, string "
"dataname_fr[, string dataname_alpha[, int version]]])``"
msgstr ""

# 934c19463e654275838771d4a083f7e8
#: ../source/matlab/cmdref_gf_model_set.rst:1724
msgid ""
"Adds a large sliding contact with friction brick to the model. This brick"
" is able to deal with self-contact, contact between several deformable "
"bodies and contact with rigid obstacles. It uses the high-level generic "
"assembly. It adds to the model a raytracing_interpolate_transformation "
"object. For each slave boundary a multiplier variable should be defined. "
"The release distance should be determined with care (generally a few "
"times a mean element size, and less than the thickness of the body). "
"Initially, the brick is added with no contact boundaries. The contact "
"boundaries and rigid bodies are added with special functions. `version` "
"is 0 (the default value) for the non-symmetric version and 1 for the more"
" symmetric one (not fully symmetric even without friction)."
msgstr ""

# ad7d54c4632e43b48d608e87cb7e9c50
#: ../source/matlab/cmdref_gf_model_set.rst:1739
msgid ""
"``gf_model_set(model M, 'add rigid obstacle to large sliding contact "
"brick', int indbrick, string expr, int N)``"
msgstr ""

# 4a1b200cf3964a90abfc585ce4f5092d
# 8540e9ee63894a4cbde6c7b5c38f70ed
#: ../source/matlab/cmdref_gf_model_set.rst:1741
#: ../source/matlab/cmdref_gf_model_set.rst:1787
msgid ""
"Adds a rigid obstacle to an existing large sliding contact with friction "
"brick. `expr` is an expression using the high-level generic assembly "
"language (where `x` is the current point n the mesh) which should be a "
"signed distance to the obstacle. `N` is the mesh dimension."
msgstr ""

# d65122b0a6ec4f09bdfd4d4b5752cde3
#: ../source/matlab/cmdref_gf_model_set.rst:1748
msgid ""
"``gf_model_set(model M, 'add master contact boundary to large sliding "
"contact brick', int indbrick, mesh_im mim, int region, string dispname[, "
"string wname])``"
msgstr ""

# 11ed3f3af19e4e9db7ccb75552d0cc64
#: ../source/matlab/cmdref_gf_model_set.rst:1750
msgid ""
"Adds a master contact boundary to an existing large sliding contact with "
"friction brick."
msgstr ""

# a7de0d8ddd724e52980d7225f8929beb
#: ../source/matlab/cmdref_gf_model_set.rst:1754
msgid ""
"``gf_model_set(model M, 'add slave contact boundary to large sliding "
"contact brick', int indbrick, mesh_im mim, int region, string dispname, "
"string lambdaname[, string wname])``"
msgstr ""

# 6f3f8d9c4c894fa5b85003f0acb015d1
#: ../source/matlab/cmdref_gf_model_set.rst:1756
msgid ""
"Adds a slave contact boundary to an existing large sliding contact with "
"friction brick."
msgstr ""

# 83ecb9ef43074325b44489877ab8dab1
#: ../source/matlab/cmdref_gf_model_set.rst:1760
msgid ""
"``gf_model_set(model M, 'add master slave contact boundary to large "
"sliding contact brick', int indbrick, mesh_im mim, int region, string "
"dispname, string lambdaname[, string wname])``"
msgstr ""

# 8a0bae14a53e4c8084bb78e7396e2869
#: ../source/matlab/cmdref_gf_model_set.rst:1762
msgid ""
"Adds a contact boundary to an existing large sliding contact with "
"friction brick which is both master and slave (allowing the self-"
"contact)."
msgstr ""

# 833b29462f334defbf1679404efc6033
#: ../source/matlab/cmdref_gf_model_set.rst:1767
msgid ""
"``ind = gf_model_set(model M, 'add Nitsche large sliding contact brick "
"raytracing', bool unbiased_version, string dataname_r, scalar "
"release_distance[, string dataname_fr[, string dataname_alpha[, int "
"version]]])``"
msgstr ""

# 87212adfb0884deabbc3934762c447ac
#: ../source/matlab/cmdref_gf_model_set.rst:1769
msgid ""
"Adds a large sliding contact with friction brick to the model based on "
"the Nitsche's method. This brick is able to deal with self-contact, "
"contact between several deformable bodies and contact with rigid "
"obstacles. It uses the high-level generic assembly. It adds to the model "
"a raytracing_interpolate_transformation object. \"unbiased_version\" "
"refers to the version of Nische's method to be used. (unbiased or biased "
"one). For each slave boundary a  material law should be defined as a "
"function of the dispacement variable on this boundary. The release "
"distance should be determined with care (generally a few times a mean "
"element size, and less than the thickness of the body). Initially, the "
"brick is added with no contact boundaries. The contact boundaries and "
"rigid bodies are added with special functions. `version` is 0 (the "
"default value) for the non-symmetric version and 1 for the more symmetric"
" one (not fully symmetric even without friction)."
msgstr ""

# 58d1a8baa1924399969038875b9917cf
#: ../source/matlab/cmdref_gf_model_set.rst:1785
msgid ""
"``gf_model_set(model M, 'add rigid obstacle to Nitsche large sliding "
"contact brick', int indbrick, string expr, int N)``"
msgstr ""

# 9038225e65fa47829329f4d4f22b50ff
#: ../source/matlab/cmdref_gf_model_set.rst:1794
msgid ""
"``gf_model_set(model M, 'add master contact boundary to biased Nitsche "
"large sliding contact brick', int indbrick, mesh_im mim, int region, "
"string dispname[, string wname])``"
msgstr ""

# 4aebb45e68ef4b2db07daa30898a6fba
#: ../source/matlab/cmdref_gf_model_set.rst:1796
msgid ""
"Adds a master contact boundary to an existing biased Nitsche's large "
"sliding contact with friction brick."
msgstr ""

# 1ae81b3622eb4b6da34cd448aa91c647
#: ../source/matlab/cmdref_gf_model_set.rst:1800
msgid ""
"``gf_model_set(model M, 'add slave contact boundary to biased Nitsche "
"large sliding contact brick', int indbrick, mesh_im mim, int region, "
"string dispname, string lambdaname[, string wname])``"
msgstr ""

# 2a2763bd89b94dc5a443c5e4c91f28d2
#: ../source/matlab/cmdref_gf_model_set.rst:1802
msgid ""
"Adds a slave contact boundary to an existing biased Nitsche's large "
"sliding contact with friction brick."
msgstr ""

# 9e625b462c1048a38f06ae0836ab4c39
#: ../source/matlab/cmdref_gf_model_set.rst:1806
msgid ""
"``gf_model_set(model M, 'add contact boundary to unbiased Nitsche large "
"sliding contact brick', int indbrick, mesh_im mim, int region, string "
"dispname, string lambdaname[, string wname])``"
msgstr ""

# 4ad527c27b4d4a4c9e7c3c9a86f4b491
#: ../source/matlab/cmdref_gf_model_set.rst:1808
msgid ""
"Adds a contact boundary to an existing unbiased Nitschelarge sliding "
"contact with friction brick which is both master and slave."
msgstr ""

