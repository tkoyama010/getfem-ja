# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2004-2017 GetFEM++ project
# This file is distributed under the same license as the GetFEM++ package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: GetFEM++ 5.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-22 15:02+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

# 49c297d7eb9e4c68912b3cebaca9147d
#: ../source/scilab/cmdref_gf_compute.rst:8
msgid "gf_compute"
msgstr ""

# cdccc79143634f6eb7791170376b38af
#: ../source/scilab/cmdref_gf_compute.rst:10
msgid "**Synopsis**"
msgstr ""

# 2a1f2142cc2b4c1dbb4ff81fe4554dcc
#: ../source/scilab/cmdref_gf_compute.rst:30
msgid "**Description :**"
msgstr ""

# 7b83479e2fb54cf180d09aa692322dfa
#: ../source/scilab/cmdref_gf_compute.rst:34
msgid "Various computations involving the solution U to a finite element problem."
msgstr ""

# c08468e0093348df923ba13a29a1f948
#: ../source/scilab/cmdref_gf_compute.rst:37
msgid "**Command list :**"
msgstr ""

# cc9238db845d4a3d81101b380f2f3016
#: ../source/scilab/cmdref_gf_compute.rst:41
msgid ""
"``n = gf_compute(mesh_fem MF, vec U, 'L2 norm', mesh_im mim[, mat "
"CVids])``"
msgstr ""

# 2569149089fa4ab2990ca0479fcfc10a
#: ../source/scilab/cmdref_gf_compute.rst:43
msgid "Compute the L2 norm of the (real or complex) field <literal>U</literal>."
msgstr ""

# 7b667b5b4ee74f1682326864c6db8d03
# cb4ab33289c343d0b9901bbb105e8fae
# 686c0422533d40bf925e1bdf94cdcd01
# 29a866a072f24d39840c9e01dd680d8e
# c821eeed06414ca19f423064a81bf282
# 139f917760614b179709aae56b0036a7
# d8f0f63574fe4796afd55990c6730abc
#: ../source/scilab/cmdref_gf_compute.rst:45
#: ../source/scilab/cmdref_gf_compute.rst:53
#: ../source/scilab/cmdref_gf_compute.rst:61
#: ../source/scilab/cmdref_gf_compute.rst:69
#: ../source/scilab/cmdref_gf_compute.rst:77
#: ../source/scilab/cmdref_gf_compute.rst:85
#: ../source/scilab/cmdref_gf_compute.rst:93
msgid ""
"If <literal>CVids</literal> is given, the norm will be computed only on "
"the listed elements."
msgstr ""

# 45c17f75ef894759b726241d2dd52b38
#: ../source/scilab/cmdref_gf_compute.rst:49
msgid ""
"``n = gf_compute(mesh_fem MF, vec U, 'L2 dist', mesh_im mim, mesh_fem "
"mf2, vec U2[, mat CVids])``"
msgstr ""

# c9f4c463e96243c48e42b182af3be658
#: ../source/scilab/cmdref_gf_compute.rst:51
msgid ""
"Compute the L2 distance between <literal>U</literal> and "
"<literal>U2</literal>."
msgstr ""

# a8d01d3459d74db78de18e9b797d6727
#: ../source/scilab/cmdref_gf_compute.rst:57
msgid ""
"``n = gf_compute(mesh_fem MF, vec U, 'H1 semi norm', mesh_im mim[, mat "
"CVids])``"
msgstr ""

# 35d3af17f98448389152f0d74fb117ce
#: ../source/scilab/cmdref_gf_compute.rst:59
msgid "Compute the L2 norm of grad(<literal>U</literal>)."
msgstr ""

# 04e5e99420704ccfb97ff0bae92ba954
#: ../source/scilab/cmdref_gf_compute.rst:65
msgid ""
"``n = gf_compute(mesh_fem MF, vec U, 'H1 semi dist', mesh_im mim, "
"mesh_fem mf2, vec U2[, mat CVids])``"
msgstr ""

# 1627233ec5f54ae2a3336a1c95de459e
#: ../source/scilab/cmdref_gf_compute.rst:67
msgid ""
"Compute the semi H1 distance between <literal>U</literal> and "
"<literal>U2</literal>."
msgstr ""

# 782566e6e9c4465cafbdd3d13cbc3d62
#: ../source/scilab/cmdref_gf_compute.rst:73
msgid ""
"``n = gf_compute(mesh_fem MF, vec U, 'H1 norm', mesh_im mim[, mat "
"CVids])``"
msgstr ""

# 873e686fd7ad4b00b8ff515c6e381609
#: ../source/scilab/cmdref_gf_compute.rst:75
msgid "Compute the H1 norm of <literal>U</literal>."
msgstr ""

# 65af2e784f354a058d24bd7fd45515f1
#: ../source/scilab/cmdref_gf_compute.rst:81
msgid ""
"``n = gf_compute(mesh_fem MF, vec U, 'H2 semi norm', mesh_im mim[, mat "
"CVids])``"
msgstr ""

# 34d07e00439b47c1afae2e044946831d
#: ../source/scilab/cmdref_gf_compute.rst:83
msgid "Compute the L2 norm of D^2(<literal>U</literal>)."
msgstr ""

# 458536a75bef473686efa06fb8bc1419
#: ../source/scilab/cmdref_gf_compute.rst:89
msgid ""
"``n = gf_compute(mesh_fem MF, vec U, 'H2 norm', mesh_im mim[, mat "
"CVids])``"
msgstr ""

# c7dbb76d9fb449c6b78e902ef3620283
#: ../source/scilab/cmdref_gf_compute.rst:91
msgid "Compute the H2 norm of <literal>U</literal>."
msgstr ""

# 4e8e475d917b4fdea7aded56e4686435
#: ../source/scilab/cmdref_gf_compute.rst:97
msgid "``DU = gf_compute(mesh_fem MF, vec U, 'gradient', mesh_fem mf_du)``"
msgstr ""

# d2739ed7ea3e4721af3b8fd20d30327f
#: ../source/scilab/cmdref_gf_compute.rst:99
msgid ""
"Compute the gradient of the field <literal>U</literal> defined on "
"mesh_fem <literal>mf_du</literal>."
msgstr ""

# c14c86ba76d24cad9201618c2941366b
#: ../source/scilab/cmdref_gf_compute.rst:101
msgid ""
"The gradient is interpolated on the mesh_fem <literal>mf_du</literal>, "
"and returned in <literal>DU</literal>. For example, if "
"<literal>U</literal> is defined on a P2 mesh_fem, <literal>DU</literal> "
"should be evaluated on a P1-discontinuous mesh_fem. <literal>mf</literal>"
" and <literal>mf_du</literal> should share the same mesh."
msgstr ""

# 248525b086dd471f88b6d4a27242a59a
#: ../source/scilab/cmdref_gf_compute.rst:106
msgid ""
"<literal>U</literal> may have any number of dimensions (i.e. this "
"function is not restricted to the gradient of scalar fields, but may also"
" be used for tensor fields). However the last dimension of "
"<literal>U</literal> has to be equal to the number of dof of "
"<literal>mf</literal>. For example, if <literal>U</literal> is a "
"[3x3xNmf] array (where Nmf is the number of dof of "
"<literal>mf</literal>), <literal>DU</literal> will be a "
"[Nx3x3[xQ]xNmf_du] array, where N is the dimension of the mesh, Nmf_du is"
" the number of dof of <literal>mf_du</literal>, and the optional Q "
"dimension is inserted if <literal>Qdim_mf != Qdim_mf_du</literal>, where "
"Qdim_mf is the Qdim of <literal>mf</literal> and Qdim_mf_du is the Qdim "
"of <literal>mf_du</literal>."
msgstr ""

# 3d675c927dde4f279f4bb6e8603973be
#: ../source/scilab/cmdref_gf_compute.rst:117
msgid "``HU = gf_compute(mesh_fem MF, vec U, 'hessian', mesh_fem mf_h)``"
msgstr ""

# 233aef3483d543329f86ea1a03a04e23
#: ../source/scilab/cmdref_gf_compute.rst:119
msgid ""
"Compute the hessian of the field <literal>U</literal> defined on mesh_fem"
" <literal>mf_h</literal>."
msgstr ""

# 23612f1d847d4a69b5cb61f33c8c9860
#: ../source/scilab/cmdref_gf_compute.rst:121
msgid "See also gf_compute('gradient', mesh_fem mf_du)."
msgstr ""

# d657b695d30147d38f4d1003f47290a8
#: ../source/scilab/cmdref_gf_compute.rst:124
msgid ""
"``UP = gf_compute(mesh_fem MF, vec U, 'eval on triangulated surface', int"
" Nrefine, [vec CVLIST])``"
msgstr ""

# a37781700853413d80b2c55e48fda31c
#: ../source/scilab/cmdref_gf_compute.rst:126
msgid ""
"[OBSOLETE FUNCTION! will be removed in a future release] Utility function"
" designed for 2D triangular meshes : returns a list of triangles "
"coordinates with interpolated U values. This can be used for the accurate"
" visualization of data defined on a discontinous high order element. On "
"output, the six first rows of UP contains the triangle coordinates, and "
"the others rows contain the interpolated values of U (one for each "
"triangle vertex) CVLIST may indicate the list of convex number that "
"should be consider, if not used then all the mesh convexes will be used. "
"U should be a row vector."
msgstr ""

# 3ea17e1e678c47d28d70fbfb002e34ab
#: ../source/scilab/cmdref_gf_compute.rst:139
msgid ""
"``Ui = gf_compute(mesh_fem MF, vec U, 'interpolate on', {mesh_fem mfi | "
"slice sli | vec pts})``"
msgstr ""

# 1e292c8c629c4a1b9900ea6cc9a2a5c6
#: ../source/scilab/cmdref_gf_compute.rst:141
msgid "Interpolate a field on another mesh_fem or a slice or a list of points."
msgstr ""

# e91b85dd307846359c4b536a9690e671
#: ../source/scilab/cmdref_gf_compute.rst:144
msgid "Interpolation on another mesh_fem <literal>mfi</literal>:"
msgstr ""

# df4a7e39d1f748739847dc8d5e56b508
#: ../source/scilab/cmdref_gf_compute.rst:144
msgid ""
"<literal>mfi</literal> has to be Lagrangian. If <literal>mf</literal> and"
" <literal>mfi</literal> share the same mesh object, the interpolation "
"will be much faster."
msgstr ""

# 2540bd184e2c44b4b349aab01d0c8c04
#: ../source/scilab/cmdref_gf_compute.rst:149
msgid "Interpolation on a slice <literal>sli</literal>:"
msgstr ""

# 6d55b3a3b99844e3ba7a4a9c7100a78c
#: ../source/scilab/cmdref_gf_compute.rst:147
msgid ""
"this is similar to interpolation on a refined P1-discontinuous mesh, but "
"it is much faster. This can also be used with gf_slice('points') to "
"obtain field values at a given set of points."
msgstr ""

# d02d82a447e04b08aab64bebfc9962a2
#: ../source/scilab/cmdref_gf_compute.rst:151
msgid "Interpolation on a set of points <literal>pts</literal>"
msgstr ""

# a1b3ba6cfbc94001ad306029170aba8e
#: ../source/scilab/cmdref_gf_compute.rst:153
msgid "See also gf_asm('interpolation matrix')"
msgstr ""

# 75a86db9125747deb2c1047502ddcf02
#: ../source/scilab/cmdref_gf_compute.rst:157
msgid "``Ue = gf_compute(mesh_fem MF, vec U, 'extrapolate on', mesh_fem mfe)``"
msgstr ""

# f782ef3286eb4b6eb062f6ac69d4b6ca
#: ../source/scilab/cmdref_gf_compute.rst:159
msgid "Extrapolate a field on another mesh_fem."
msgstr ""

# a80d878cb18e4592addd94fdb7c9097e
#: ../source/scilab/cmdref_gf_compute.rst:161
msgid ""
"If the mesh of <literal>mfe</literal> is stricly included in the mesh of "
"<literal>mf</literal>, this function does stricly the same job as "
"gf_compute('interpolate_on'). However, if the mesh of "
"<literal>mfe</literal> is not exactly included in <literal>mf</literal> "
"(imagine interpolation between a curved refined mesh and a coarse mesh), "
"then values which are outside <literal>mf</literal> will be extrapolated."
msgstr ""

# 8b60581f9a6741c7a4ef47d9c6bd4c44
#: ../source/scilab/cmdref_gf_compute.rst:168
msgid "See also gf_asm('extrapolation matrix')"
msgstr ""

# a4a847b7d3c245a6ac6608867dfa6e64
#: ../source/scilab/cmdref_gf_compute.rst:171
msgid "``E = gf_compute(mesh_fem MF, vec U, 'error estimate', mesh_im mim)``"
msgstr ""

# 3157d0283bf94b6f94b11adb45000e4e
#: ../source/scilab/cmdref_gf_compute.rst:173
msgid "Compute an a posteriori error estimate."
msgstr ""

# e3fc3ec8d6ce40fca2dd12a26cbc5a3d
# fce5ae02cd8643fe84617feb92ce8dcf
#: ../source/scilab/cmdref_gf_compute.rst:175
#: ../source/scilab/cmdref_gf_compute.rst:183
msgid ""
"Currently there is only one which is available: for each convex, the jump"
" of the normal derivative is integrated on its faces."
msgstr ""

# 4961b825dd694073be2d8bedce6c34d8
#: ../source/scilab/cmdref_gf_compute.rst:179
msgid ""
"``E = gf_compute(mesh_fem MF, vec U, 'error estimate nitsche', mesh_im "
"mim, int GAMMAC, int GAMMAN, scalar lambda_, scalar mu_, scalar gamma0, "
"scalar f_coeff, scalar vertical_force)``"
msgstr ""

# b3e741c0f07d4ea2acd4ccb0ee2b4c6f
#: ../source/scilab/cmdref_gf_compute.rst:181
msgid "Compute an a posteriori error estimate in the case of Nitsche method."
msgstr ""

# 67b0c36003e740afb9a915a8cea4f382
#: ../source/scilab/cmdref_gf_compute.rst:187
msgid ""
"``gf_compute(mesh_fem MF, vec U, 'convect', mesh_fem mf_v, vec V, scalar "
"dt, int nt[, string option[, vec per_min, vec per_max]])``"
msgstr ""

# e70f47e7c892404e9e3c81891e99f84a
#: ../source/scilab/cmdref_gf_compute.rst:189
msgid ""
"Compute a convection of <literal>U</literal> with regards to a steady "
"state velocity field <literal>V</literal> with a Characteristic-Galerkin "
"method. The result is returned in-place in <literal>U</literal>. This "
"method is restricted to pure Lagrange fems for U. <literal>mf_v</literal>"
" should represent a continuous finite element method. "
"<literal>dt</literal> is the integration time and <literal>nt</literal> "
"is the number of integration step on the caracteristics. "
"<literal>option</literal> is an option for the part of the boundary where"
" there is a re-entrant convection. <literal>option = "
"'extrapolation'</literal> for an extrapolation on the nearest element, "
"<literal>option = 'unchanged'</literal> for a constant value on that "
"boundary or <literal>option = 'periodicity'</literal> for a peridiodic "
"boundary. For this latter option the two vectors per_min, per_max has to "
"be given and represent the limits of the periodic domain (on components "
"where per_max[k] < per_min[k] no operation is done). This method is "
"rather dissipative, but stable."
msgstr ""

