# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2004-2017 GetFEM++ project
# This file is distributed under the same license as the GetFEM++ package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: GetFEM++ 5.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-22 15:02+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

# de955ab6e64f4f0eb9d9b7691cea4c84
#: ../source/scilab/cmdref_gf_asm.rst:8
msgid "gf_asm"
msgstr ""

# d5731d0429eb470e9c78c3bc346c1b2b
#: ../source/scilab/cmdref_gf_asm.rst:10
msgid "**Synopsis**"
msgstr ""

# efdf5dcfcf174c499e9031f53d7d466d
#: ../source/scilab/cmdref_gf_asm.rst:41
msgid "**Description :**"
msgstr ""

# 7d2a6cdb0ec24d14a65d65dc5f098590
#: ../source/scilab/cmdref_gf_asm.rst:45
msgid "General assembly function."
msgstr ""

# 5311cd4cbdb843e3a47d273f6aae2bf9
#: ../source/scilab/cmdref_gf_asm.rst:47
msgid ""
"Many of the functions below use more than one mesh_fem: the main mesh_fem"
" (mf_u) used for the main unknown, and data mesh_fem (mf_d) used for the "
"data. It is always assumed that the Qdim of mf_d is equal to 1: if mf_d "
"is used to describe vector or tensor data, you just have to \"stack\" (in"
" fortran ordering) as many scalar fields as necessary."
msgstr ""

# 09bc68f1ff62429583ae9a7c00422fcf
#: ../source/scilab/cmdref_gf_asm.rst:55
msgid "**Command list :**"
msgstr ""

# 775c4738f053476e83531f2284be1bb9
#: ../source/scilab/cmdref_gf_asm.rst:59
msgid ""
"``{...} = gf_asm('generic', mesh_im mim, int order, string expression, "
"int region, [model model,] [string varname, int is_variable[, {mesh_fem "
"mf, mesh_imd mimd}], value], ...)``"
msgstr ""

# bbbb091b8e6a4481aa4bf49139159bfe
#: ../source/scilab/cmdref_gf_asm.rst:61
msgid "High-level generic assembly procedure for volumic or boundary assembly."
msgstr ""

# ca73a69f7d0a4fafb853076ca4e14ea5
#: ../source/scilab/cmdref_gf_asm.rst:63
msgid ""
"Performs the generic assembly of <literal>expression</literal> with the "
"integration method <literal>mim</literal> on the mesh region of index "
"<literal>region</literal> (-1 means all the element of the mesh). The "
"same mesh should be shared by the integration method and all the finite "
"element methods or mesh_im_data corresponding to the variables."
msgstr ""

# d24aaf6f37f248539267c9ce323b62a4
#: ../source/scilab/cmdref_gf_asm.rst:69
msgid ""
"<literal>order</literal> indicates either that the (scalar) potential "
"(order = 0) or the (vector) residual (order = 1) or the tangent (matrix) "
"(order = 2) is to be computed."
msgstr ""

# dd85dd9d570d4fc8ba0ce1cf2da2c8b5
#: ../source/scilab/cmdref_gf_asm.rst:73
msgid ""
"<literal>model</literal> is an optional parameter allowing to take into "
"account all variables and data of a model."
msgstr ""

# 83fe4048ecba4200b5a9fdfa1a0e8b05
#: ../source/scilab/cmdref_gf_asm.rst:76
msgid ""
"The variables and constant (data) are listed after the region number (or "
"optionally the model). For each variable/constant, first the "
"variable/constant name should be given (as it is referred in the assembly"
" string), then 1 if it is a variable or 0 for a constant, then the finite"
" element method if it is a fem variable/constant or the mesh_im_data if "
"it is data defined on integration points, and the vector representing the"
" value of the variable/constant. It is possible to give an arbitrary "
"number of variable/constant. The difference between a variable and a "
"constant is that automatic differentiation is done with respect to "
"variables only (see GetFEM++ user documentation). Test functions are only"
" available for variables, not for constants."
msgstr ""

# 7854295e38bf49c4b68392ee27328604
#: ../source/scilab/cmdref_gf_asm.rst:89
msgid ""
"Note that if several variables are given, the assembly of the tangent "
"matrix/residual vector will be done considering the order in the call of "
"the function (the degrees of freedom of the first variable, then of the "
"second, and so on). If a model is provided, all degrees of freedom of the"
" model will be counted first."
msgstr ""

# f6b6a235eda1404b89189a8419dbd51b
#: ../source/scilab/cmdref_gf_asm.rst:95
msgid "For example, the L2 norm of a vector field \"u\" can be computed with::"
msgstr ""

# 62df5acf475140849c0f4bbb3bc7c01e
#: ../source/scilab/cmdref_gf_asm.rst:101
msgid ""
"The nonhomogeneous Laplacian stiffness matrix of a scalar field can be "
"evaluated with::"
msgstr ""

# 43407069ce6a42cd9c8a72e211718420
#: ../source/scilab/cmdref_gf_asm.rst:110
msgid ""
"``M = gf_asm('mass matrix', mesh_im mim, mesh_fem mf1[, mesh_fem mf2[, "
"int region]])``"
msgstr ""

# 46415c71c6f049bcb29059bf6ca3c32c
#: ../source/scilab/cmdref_gf_asm.rst:112
msgid "Assembly of a mass matrix."
msgstr ""

# cd27baa3df3b430985f04abe6f8c2f77
# 293cb99c112348c59e19a5d6f62ccc63
# a1b7f75d2b4a425fb826b80bc99f239e
# 2be79b23809c43308b9a64c90be4c6e6
# a9b497dda63e45a3ae8f52d72e722987
# 1ed33550dd084f6d9908489d06a903e4
# cb254c60467c4f96b8597efbc700ffce
# 3cc86c7dcb0646759479e1d96f869325
# e9555b613c3a439f825d7f24933ce02b
# 7f227cc905d749c68c4c4e9739c351db
#: ../source/scilab/cmdref_gf_asm.rst:114
#: ../source/scilab/cmdref_gf_asm.rst:124
#: ../source/scilab/cmdref_gf_asm.rst:135
#: ../source/scilab/cmdref_gf_asm.rst:182
#: ../source/scilab/cmdref_gf_asm.rst:192
#: ../source/scilab/cmdref_gf_asm.rst:202
#: ../source/scilab/cmdref_gf_asm.rst:264
#: ../source/scilab/cmdref_gf_asm.rst:397
#: ../source/scilab/cmdref_gf_asm.rst:405
#: ../source/scilab/cmdref_gf_asm.rst:413
msgid "Return a spmat object."
msgstr ""

# 712f5975c43b481db14d443992f5be76
#: ../source/scilab/cmdref_gf_asm.rst:118
msgid ""
"``L = gf_asm('laplacian', mesh_im mim, mesh_fem mf_u, mesh_fem mf_d, vec "
"a[, int region])``"
msgstr ""

# ef240375f52d49a09345400e103be190
#: ../source/scilab/cmdref_gf_asm.rst:120
msgid "Assembly of the matrix for the Laplacian problem."
msgstr ""

# ccf3c0a0128b4e3d98927564e1622d2c
#: ../source/scilab/cmdref_gf_asm.rst:122
msgid ""
"<latex style=\"text\"><![CDATA[\\nabla\\cdot(a(x)\\nabla u)]]></latex>  "
"with <literal>a</literal> a scalar."
msgstr ""

# c094247fcc95434e86b487275fa6402a
#: ../source/scilab/cmdref_gf_asm.rst:128
msgid ""
"``Le = gf_asm('linear elasticity', mesh_im mim, mesh_fem mf_u, mesh_fem "
"mf_d, vec lambda_d, vec mu_d[, int region])``"
msgstr ""

# 9b91f9c3fea246c2ba9b45e4e33b3922
#: ../source/scilab/cmdref_gf_asm.rst:130
msgid "Assembles of the matrix for the linear (isotropic) elasticity problem."
msgstr ""

# 4db12ad7b3db417b97d6183852991650
#: ../source/scilab/cmdref_gf_asm.rst:132
msgid ""
"<latex style=\"text\"><![CDATA[\\nabla\\cdot(C(x):\\nabla u)]]></latex> "
"with <latex style=\"text\"><![CDATA[C]]></latex> defined via "
"<literal>lambda_d</literal> and <literal>mu_d</literal>."
msgstr ""

# c5e0649c02d44cf79720091d8e753586
#: ../source/scilab/cmdref_gf_asm.rst:139
msgid ""
"``TRHS = gf_asm('nonlinear elasticity', mesh_im mim, mesh_fem mf_u, vec "
"U, string law, mesh_fem mf_d, mat params, {'tangent "
"matrix'|'rhs'|'incompressible tangent matrix', mesh_fem mf_p, vec "
"P|'incompressible rhs', mesh_fem mf_p, vec P})``"
msgstr ""

# a9c297ad905d410b81e93e2c789ffdc4
#: ../source/scilab/cmdref_gf_asm.rst:141
msgid ""
"Assembles terms (tangent matrix and right hand side) for nonlinear "
"elasticity."
msgstr ""

# 1024765922c943d38d24fea2bc034b14
#: ../source/scilab/cmdref_gf_asm.rst:143
msgid ""
"The solution <literal>U</literal> is required at the current time-step. "
"The <literal>law</literal> may be choosen among:"
msgstr ""

# fa7e9c0d6fe842f69f895619318afaff
#: ../source/scilab/cmdref_gf_asm.rst:146
msgid ""
"'SaintVenant Kirchhoff': Linearized law, should be avoided). This law has"
" the two usual Lame coefficients as parameters, called lambda and mu."
msgstr ""

# 3694d080e9514f8c8d41c57d2f5e0db3
#: ../source/scilab/cmdref_gf_asm.rst:149
msgid ""
"'Mooney Rivlin': This law has three parameters, called C1, C2 and D1. Can"
" be preceded with the words 'compressible' or 'incompressible' to force a"
" specific version. By default, the incompressible version is considered "
"which requires only the first two material coefficients."
msgstr ""

# e77c617c31e64005b6570a30f81b2332
#: ../source/scilab/cmdref_gf_asm.rst:154
msgid ""
"'neo Hookean': A special case of the 'Mooney Rivlin' law that requires "
"one material coefficient less (C2 = 0). By default, its compressible "
"version is used."
msgstr ""

# 059f21f4e5cf498799c7f6f0300b756a
#: ../source/scilab/cmdref_gf_asm.rst:157
msgid ""
"'Ciarlet Geymonat': This law has 3 parameters, called lambda, mu and "
"gamma, with gamma chosen such that gamma is in ]-lambda/2-mu, -mu[."
msgstr ""

# 633ac817d7b447d787e35938eb45d89f
#: ../source/scilab/cmdref_gf_asm.rst:161
msgid ""
"The parameters of the material law are described on the mesh_fem "
"<literal>mf_d</literal>. The matrix <literal>params</literal> should have"
" <literal>nbdof(mf_d)</literal> columns, each row correspounds to a "
"parameter."
msgstr ""

# bffb01865f3344308affe4f8f5c1ad85
#: ../source/scilab/cmdref_gf_asm.rst:165
msgid ""
"The last argument selects what is to be built: either the tangent matrix,"
" or the right hand side. If the incompressibility is considered, it "
"should be followed by a mesh_fem <literal>mf_p</literal>, for the "
"pression."
msgstr ""

# 096f0ba8079149e282b54bf8e2b78d92
#: ../source/scilab/cmdref_gf_asm.rst:170
msgid ""
"Return a spmat object (tangent matrix), vec object (right hand side), "
"tuple of spmat objects (incompressible tangent matrix), or tuple of vec "
"objects (incompressible right hand side)."
msgstr ""

# 6b8d8c09a1404d1ba388ac98eeaaeb7d
#: ../source/scilab/cmdref_gf_asm.rst:176
msgid ""
"``A = gf_asm('helmholtz', mesh_im mim, mesh_fem mf_u, mesh_fem mf_d, vec "
"k[, int region])``"
msgstr ""

# d83348ace70c45b7b93612fd7ec5030b
#: ../source/scilab/cmdref_gf_asm.rst:178
msgid "Assembly of the matrix for the Helmholtz problem."
msgstr ""

# b474c55b3648455e8871c7adf5418cd7
#: ../source/scilab/cmdref_gf_asm.rst:180
msgid ""
"<latex style=\"text\"><![CDATA[\\Delta u + k^2 u]]></latex> = 0,  with "
"<literal>k</literal> complex scalar."
msgstr ""

# 9e08ca8d78aa429aadc9c2ec39a82fe9
#: ../source/scilab/cmdref_gf_asm.rst:186
msgid ""
"``A = gf_asm('bilaplacian', mesh_im mim, mesh_fem mf_u, mesh_fem mf_d, "
"vec a[, int region])``"
msgstr ""

# f4e17643ee014712994813ba47abc4d4
#: ../source/scilab/cmdref_gf_asm.rst:188
msgid "Assembly of the matrix for the Bilaplacian problem."
msgstr ""

# 93711ec5c48b43c8b6a2ce18895ae8c7
# ed334045fe294e58b71ad6eb58bc90ec
#: ../source/scilab/cmdref_gf_asm.rst:190
#: ../source/scilab/cmdref_gf_asm.rst:200
msgid ""
"<latex style=\"text\"><![CDATA[\\Delta(a(x)\\Delta u) = 0]]></latex>   "
"with <literal>a</literal> scalar."
msgstr ""

# a3a040a3df7a4d4dba3c96d920d5c4f4
#: ../source/scilab/cmdref_gf_asm.rst:196
msgid ""
"``A = gf_asm('bilaplacian KL', mesh_im mim, mesh_fem mf_u, mesh_fem mf_d,"
" vec a, vec nu[, int region])``"
msgstr ""

# 1a417693560f41eea7657ee11d6a20d7
#: ../source/scilab/cmdref_gf_asm.rst:198
msgid ""
"Assembly of the matrix for the Bilaplacian problem with Kirchhoff-Love "
"formulation."
msgstr ""

# 32878bbdbf154e93916c77d5a7a8da2b
#: ../source/scilab/cmdref_gf_asm.rst:206
msgid ""
"``V = gf_asm('volumic source', mesh_im mim, mesh_fem mf_u, mesh_fem mf_d,"
" vec fd[, int region])``"
msgstr ""

# 9f1a7d64461c4fc398fdbe4bb62833e9
#: ../source/scilab/cmdref_gf_asm.rst:208
msgid "Assembly of a volumic source term."
msgstr ""

# e62c68f8ab964fefb073b4c16fd63ac5
#: ../source/scilab/cmdref_gf_asm.rst:210
msgid ""
"Output a vector <literal>V</literal>, assembled on the mesh_fem "
"<literal>mf_u</literal>, using the data vector <literal>fd</literal> "
"defined on the data mesh_fem <literal>mf_d</literal>. "
"<literal>fd</literal> may be real or complex-valued."
msgstr ""

# 4ce7bfca83984f86a207b9826a8a30c7
# e5709a2208a94049bbaae08d06ade6cc
# 7978286683bf49dc9a6e50783ad7d867
# 4a5bc08354d449a3b7861cb45ed6e7c7
#: ../source/scilab/cmdref_gf_asm.rst:214
#: ../source/scilab/cmdref_gf_asm.rst:226
#: ../source/scilab/cmdref_gf_asm.rst:378
#: ../source/scilab/cmdref_gf_asm.rst:389
msgid "Return a vec object."
msgstr ""

# 63ed399c938b436782dbefe38bb8786c
#: ../source/scilab/cmdref_gf_asm.rst:218
msgid ""
"``B = gf_asm('boundary source', int bnum, mesh_im mim, mesh_fem mf_u, "
"mesh_fem mf_d, vec G)``"
msgstr ""

# c0e17b3501f946ef957438815784b3a4
#: ../source/scilab/cmdref_gf_asm.rst:220
msgid "Assembly of a boundary source term."
msgstr ""

# 2cf4295bd252461585bda5a028c424f8
#: ../source/scilab/cmdref_gf_asm.rst:222
msgid ""
"<literal>G</literal> should be a [Qdim x N] matrix, where N is the number"
" of dof of <literal>mf_d</literal>, and Qdim is the dimension of the "
"unkown u (that is set when creating the mesh_fem)."
msgstr ""

# 77465917ad594af7b4dea6b647237cbb
#: ../source/scilab/cmdref_gf_asm.rst:230
msgid ""
"``{HH, RR} = gf_asm('dirichlet', int bnum, mesh_im mim, mesh_fem mf_u, "
"mesh_fem mf_d, mat H, vec R [, scalar threshold])``"
msgstr ""

# 619d110ba14e492fb3622ab5a33f2d2f
#: ../source/scilab/cmdref_gf_asm.rst:232
msgid "Assembly of Dirichlet conditions of type <literal>h.u = r</literal>."
msgstr ""

# 926223aaec7f4f48bcd7edc658d02cea
#: ../source/scilab/cmdref_gf_asm.rst:234
msgid ""
"Handle <literal>h.u = r</literal> where h is a square matrix (of any "
"rank) whose size is equal to the dimension of the unkown u. This matrix "
"is stored in <literal>H</literal>, one column per dof in "
"<literal>mf_d</literal>, each column containing the values of the matrix "
"h stored in fortran order:"
msgstr ""

# 6390b85badb94a02bd3003704d91838c
#: ../source/scilab/cmdref_gf_asm.rst:243
msgid "if u is a 2D vector field."
msgstr ""

# dddb71f136e94de5a940225496e0df39
#: ../source/scilab/cmdref_gf_asm.rst:245
msgid ""
"Of course, if the unknown is a scalar field, you just have to set "
"<literal>H = ones(1, N)</literal>, where N is the number of dof of "
"<literal>mf_d</literal>."
msgstr ""

# 48d26b1fe5804770a1ca11b60e7f76d0
#: ../source/scilab/cmdref_gf_asm.rst:248
msgid ""
"This is basically the same than calling gf_asm('boundary qu term') for "
"<literal>H</literal> and calling gf_asm('neumann') for "
"<literal>R</literal>, except that this function tries to produce a "
"'better' (more diagonal) constraints matrix (when possible)."
msgstr ""

# a846f4187a504f08a80677dc65e5d485
#: ../source/scilab/cmdref_gf_asm.rst:253
msgid "See also gf_spmat_get(spmat S, 'Dirichlet_nullspace')."
msgstr ""

# 763b263ea3c54ef6861977b27324cb8b
#: ../source/scilab/cmdref_gf_asm.rst:256
msgid ""
"``Q = gf_asm('boundary qu term',int boundary_num, mesh_im mim, mesh_fem "
"mf_u, mesh_fem mf_d, mat q)``"
msgstr ""

# ea35bc7ff1a349d7a1d2088eea2bfef4
#: ../source/scilab/cmdref_gf_asm.rst:258
msgid "Assembly of a boundary qu term."
msgstr ""

# a06101e106734b51bdc2460bcd01b2d7
#: ../source/scilab/cmdref_gf_asm.rst:260
msgid ""
"<literal>q</literal> should be be a [Qdim x Qdim x N] array, where N is "
"the number of dof of <literal>mf_d</literal>, and Qdim is the dimension "
"of the unkown u (that is set when creating the mesh_fem)."
msgstr ""

# d3ce5e2a9ceb425683fb2d56f8d1e6b2
#: ../source/scilab/cmdref_gf_asm.rst:268
msgid ""
"``gf_asm('define function', string name, int nb_args, string expression[,"
" string expression_derivative_t[, string expression_derivative_u]])``"
msgstr ""

# 768d99a123c1413ea94fa4c672e61190
#: ../source/scilab/cmdref_gf_asm.rst:270
msgid ""
"Define a new function <literal>name</literal> which can be used in high "
"level generic assembly. The function can have one or two parameters. In "
"<literal>expression</literal> all available predefined function or "
"operation of the generic assembly can be used. However, no reference to "
"some variables or data can be specified. The argument of the function is "
"<literal>t</literal> for a one parameter function and "
"<literal>t</literal> and <literal>u</literal> for a two parameter "
"function. For instance 'sin(pi*t)+2*t*t' is a valid expression for a one "
"parameter function and 'sin(max(t,u)*pi)' is a valid expression for a two"
" parameters function. <literal>expression_derivative_t</literal> and "
"<literal>expression_derivative_u</literal> are optional expressions for "
"the derivatives with respect to <literal>t</literal> and "
"<literal>u</literal>. If they are not furnished, a symbolic derivation is"
" used."
msgstr ""

# e9d486ffe4414d24be8dccdbf136e65e
#: ../source/scilab/cmdref_gf_asm.rst:285
msgid "``gf_asm('undefine function', string name)``"
msgstr ""

# 4491f03422a2491aabdace5cc0398a57
#: ../source/scilab/cmdref_gf_asm.rst:287
msgid ""
"Cancel the definition of a previously defined function "
"<literal>name</literal> for the high level generic assembly."
msgstr ""

# 1082a7ba542b429baeac33c75559875b
#: ../source/scilab/cmdref_gf_asm.rst:291
msgid ""
"``gf_asm('define linear hardening function', string name, scalar "
"sigma_y0, scalar H, ... [string 'Frobenius'])``"
msgstr ""

# bdaf09ccd17d42f8a2b4fb67e4435077
#: ../source/scilab/cmdref_gf_asm.rst:293
msgid ""
"Define a new linear hardening function under the name "
"<literal>name</literal>, with initial yield stress "
"<literal>sigma_y0</literal> and hardening modulus H. If an extra string "
"argument with the value 'Frobenius' is provided, the hardening function "
"is expressed in terms of Frobenius norms of its input strain and output "
"stress, instead of their Von-Mises equivalents."
msgstr ""

# d3c0b04be64f4fc28f0a1475e4e6ae11
#: ../source/scilab/cmdref_gf_asm.rst:300
msgid ""
"``gf_asm('define Ramberg Osgood hardening function', string name, scalar "
"sigma_ref, {scalar eps_ref | scalar E, scalar alpha}, scalar n[, string "
"'Frobenius'])``"
msgstr ""

# a214643e5c79434c91f8dfe1578cdd7b
#: ../source/scilab/cmdref_gf_asm.rst:302
msgid ""
"Define a new Ramberg Osgood hardening function under the name "
"<literal>name</literal>, with initial yield stress "
"<literal>sigma_y0</literal> and hardening modulus H. If an extra string "
"argument with the value 'Frobenius' is provided, the hardening function "
"is expressed in terms of Frobenius norms of its input strain and output "
"stress, instead of their Von-Mises equivalents."
msgstr ""

# 0de85591b7e44719ac00a13a19f4c388
#: ../source/scilab/cmdref_gf_asm.rst:309
msgid ""
"``gf_asm('expression analysis', string expression [, {@tm mesh | mesh_im "
"mim}] [, der_order] [, model model] [, string varname, int is_variable[, "
"{mesh_fem mf | mesh_imd mimd}], ...])``"
msgstr ""

# 35420e35b7a8408fbcbd07bfd0b62529
#: ../source/scilab/cmdref_gf_asm.rst:311
msgid ""
"Analyse a high-level generic assembly expression and print information "
"about the provided expression."
msgstr ""

# 2b86ed1d6ad04f71964341cd97c537a0
#: ../source/scilab/cmdref_gf_asm.rst:315
msgid ""
"``{...} = gf_asm('volumic' [,CVLST], expr [, mesh_ims, mesh_fems, "
"data...])``"
msgstr ""

# 5736d761b8034f4aa7eee3e074a689a5
#: ../source/scilab/cmdref_gf_asm.rst:317
msgid "Low-level generic assembly procedure for volumic assembly."
msgstr ""

# 09c8fbe58bb64656a1ad8bb513d3bb4f
#: ../source/scilab/cmdref_gf_asm.rst:319
msgid ""
"The expression <literal>expr</literal> is evaluated over the mesh_fem's "
"listed in the arguments (with optional data) and assigned to the output "
"arguments. For details about the syntax of assembly expressions, please "
"refer to the getfem user manual (or look at the file getfem_assembling.h "
"in the getfem++ sources)."
msgstr ""

# e923f934fdaa48d6a7e6034fa876eba2
#: ../source/scilab/cmdref_gf_asm.rst:325
msgid "For example, the L2 norm of a field can be computed with::"
msgstr ""

# 33a172ebbc244741b5f915368e8e31e4
#: ../source/scilab/cmdref_gf_asm.rst:331
msgid "The Laplacian stiffness matrix can be evaluated with::"
msgstr ""

# 25904541a73041b7bc36a006d8a0a661
#: ../source/scilab/cmdref_gf_asm.rst:338
msgid ""
"``{...} = gf_asm('boundary', int bnum, string expr [, mesh_im mim, "
"mesh_fem mf, data...])``"
msgstr ""

# cb97e8e0bbf54211a73ebc5de761c222
#: ../source/scilab/cmdref_gf_asm.rst:340
msgid "Low-level generic boundary assembly."
msgstr ""

# 83d0c05eff804d91b75604274ff3d2c5
#: ../source/scilab/cmdref_gf_asm.rst:342
msgid "See the help for gf_asm('volumic')."
msgstr ""

# 7b2d2a53f5074ed290c2f93f95a75d53
#: ../source/scilab/cmdref_gf_asm.rst:345
msgid ""
"``Mi = gf_asm('interpolation matrix', mesh_fem mf, {mesh_fem mfi | vec "
"pts})``"
msgstr ""

# a285a48305584d26a3f13e60bb951239
#: ../source/scilab/cmdref_gf_asm.rst:347
msgid ""
"Build the interpolation matrix from a mesh_fem onto another mesh_fem or a"
" set of points."
msgstr ""

# 97086e9506164fc98e0f16cc2967ef89
#: ../source/scilab/cmdref_gf_asm.rst:349
msgid ""
"Return a matrix <literal>Mi</literal>, such that <literal>V = "
"Mi.U</literal> is equal to gf_compute('interpolate_on',mfi). Useful for "
"repeated interpolations. Note that this is just interpolation, no "
"elementary integrations are involved here, and <literal>mfi</literal> has"
" to be lagrangian. In the more general case, you would have to do a L2 "
"projection via the mass matrix."
msgstr ""

# 75b3388e8910443cba1c9dbb1bccc8c9
#: ../source/scilab/cmdref_gf_asm.rst:356
msgid "<literal>Mi</literal> is a spmat object."
msgstr ""

# ef7d21ee9a234d4dadd5078fe4461b30
#: ../source/scilab/cmdref_gf_asm.rst:360
msgid ""
"``Me = gf_asm('extrapolation matrix',mesh_fem mf,  {mesh_fem mfe | vec "
"pts})``"
msgstr ""

# e474c7fbba0045f3bf765d150a91a6c6
#: ../source/scilab/cmdref_gf_asm.rst:362
msgid ""
"Build the extrapolation matrix from a mesh_fem onto another mesh_fem or a"
" set of points."
msgstr ""

# 77ad060009564433b26b9ccb8a4c728e
#: ../source/scilab/cmdref_gf_asm.rst:364
msgid ""
"Return a matrix <literal>Me</literal>, such that <literal>V = "
"Me.U</literal> is equal to gf_compute('extrapolate_on',mfe). Useful for "
"repeated extrapolations."
msgstr ""

# 24d9e02d8a2b4f73ba27d289934fb3e7
#: ../source/scilab/cmdref_gf_asm.rst:368
msgid "<literal>Me</literal> is a spmat object."
msgstr ""

# 56d123963c3b4fef9438251d222b7e1d
#: ../source/scilab/cmdref_gf_asm.rst:372
msgid ""
"``B = gf_asm('integral contact Uzawa projection', int bnum, mesh_im mim, "
"mesh_fem mf_u, vec U, mesh_fem mf_lambda, vec vec_lambda, mesh_fem "
"mf_obstacle, vec obstacle, scalar r [, {scalar coeff | mesh_fem mf_coeff,"
" vec coeff} [, int option[, scalar alpha, vec W]]])``"
msgstr ""

# ccfa447fa8884d82bb5fbf0760662a12
#: ../source/scilab/cmdref_gf_asm.rst:376
msgid "Specific assembly procedure for the use of an Uzawa algorithm to solve"
msgstr ""

# 4a33b20700814f8d864975f7d52b9dcf
#: ../source/scilab/cmdref_gf_asm.rst:375
msgid ""
"contact problems. Projects the term $-(\\lambda - r (u_N-g))_-$ on the "
"finite element space of $\\lambda$."
msgstr ""

# d51d460d59eb4f7f8acccfc1abffea1d
#: ../source/scilab/cmdref_gf_asm.rst:382
msgid ""
"``B = gf_asm('level set normal source term', int bnum, mesh_im mim, "
"mesh_fem mf_u, mesh_fem mf_lambda, vec vec_lambda, mesh_fem mf_levelset, "
"vec levelset)``"
msgstr ""

# e73777b4304d4efa96f8a493c5e44631
#: ../source/scilab/cmdref_gf_asm.rst:384
msgid ""
"Performs an assembly of the source term represented by "
"<literal>vec_lambda</literal> on <literal>mf_lambda</literal> considered "
"to be a component in the direction of the gradient of a levelset function"
" (normal to the levelset) of a vector field defined on "
"<literal>mf_u</literal> on the boundary <literal>bnum</literal>."
msgstr ""

# 89237bfe288f48508453afd2b9290d02
#: ../source/scilab/cmdref_gf_asm.rst:393
msgid ""
"``M = gf_asm('lsneuman matrix', mesh_im mim, mesh_fem mf1, mesh_fem mf2, "
"levelset ls[, int region])``"
msgstr ""

# ae22e3e21d184d35a6b7e736374b9c24
#: ../source/scilab/cmdref_gf_asm.rst:395
msgid "Assembly of a level set Neuman  matrix."
msgstr ""

# d2ec5765d65243f08052aabcbcac6608
#: ../source/scilab/cmdref_gf_asm.rst:401
msgid ""
"``M = gf_asm('nlsgrad matrix', mesh_im mim, mesh_fem mf1, mesh_fem mf2, "
"levelset ls[, int region])``"
msgstr ""

# 6c3afb74a07e4030852061d76b079f46
#: ../source/scilab/cmdref_gf_asm.rst:403
msgid "Assembly of a nlsgrad matrix."
msgstr ""

# 59ad8156fa2a419cbe49e95eddcd7596
#: ../source/scilab/cmdref_gf_asm.rst:409
msgid ""
"``M = gf_asm('stabilization patch matrix', @tm mesh, mesh_fem mf,  "
"mesh_im mim, real ratio, real h)``"
msgstr ""

# 264e8b8c0b094051976e861de3b8cc06
#: ../source/scilab/cmdref_gf_asm.rst:411
msgid "Assembly of stabilization patch matrix ."
msgstr ""

