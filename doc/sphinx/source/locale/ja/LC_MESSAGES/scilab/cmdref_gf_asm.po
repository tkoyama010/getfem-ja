# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2004-2017 GetFEM++ project
# This file is distributed under the same license as the GetFEM++ package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: GetFEM++ 5.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-07-07 10:04+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

# 148723092c824b5cb9cc1d9dd4afcbc5
#: ../source/scilab/cmdref_gf_asm.rst:8
msgid "gf_asm"
msgstr ""

# 51434256067c491c971af687bf1daaa0
#: ../source/scilab/cmdref_gf_asm.rst:10
msgid "**Synopsis**"
msgstr ""

# b0f2a8fa66cb437793cde8bccb2d8d2d
#: ../source/scilab/cmdref_gf_asm.rst:41
msgid "**Description :**"
msgstr ""

# 8c1b4a63c44a4fbf8d1f618c1d99727e
#: ../source/scilab/cmdref_gf_asm.rst:45
msgid "General assembly function."
msgstr ""

# 96b27947b97c40358abc90dd1d6215ba
#: ../source/scilab/cmdref_gf_asm.rst:47
msgid ""
"Many of the functions below use more than one mesh_fem: the main mesh_fem"
" (mf_u) used for the main unknown, and data mesh_fem (mf_d) used for the "
"data. It is always assumed that the Qdim of mf_d is equal to 1: if mf_d "
"is used to describe vector or tensor data, you just have to \"stack\" (in"
" fortran ordering) as many scalar fields as necessary."
msgstr ""

# 2e0495ff547a4f6c8cacd946c49e8eba
#: ../source/scilab/cmdref_gf_asm.rst:55
msgid "**Command list :**"
msgstr ""

# 428412e511f64181a326ea2b637ba740
#: ../source/scilab/cmdref_gf_asm.rst:59
msgid ""
"``{...} = gf_asm('generic', mesh_im mim, int order, string expression, "
"int region, [model model, ['Secondary_domain', 'name',]] [string varname,"
" int is_variable[, {mesh_fem mf, mesh_imd mimd}], value], ...)``"
msgstr ""

# 7ed3f21c604b489f816ba15fbb721d8b
#: ../source/scilab/cmdref_gf_asm.rst:61
msgid "High-level generic assembly procedure for volumic or boundary assembly."
msgstr ""

# 3f52e2e2d5554519b29319e607a96f5e
#: ../source/scilab/cmdref_gf_asm.rst:63
msgid ""
"Performs the generic assembly of <literal>expression</literal> with the "
"integration method <literal>mim</literal> on the mesh region of index "
"<literal>region</literal> (-1 means all the element of the mesh). The "
"same mesh should be shared by the integration method and all the finite "
"element methods or mesh_im_data corresponding to the variables."
msgstr ""

# 7e7507f006c64c498a4da77f416dcea6
#: ../source/scilab/cmdref_gf_asm.rst:69
msgid ""
"<literal>order</literal> indicates either that the (scalar) potential "
"(order = 0) or the (vector) residual (order = 1) or the tangent (matrix) "
"(order = 2) is to be computed."
msgstr ""

# 5129cf737947461bafb9c7d6bb7005f4
#: ../source/scilab/cmdref_gf_asm.rst:73
msgid ""
"<literal>model</literal> is an optional parameter allowing to take into "
"account all variables and data of a model. Optionnally, for the "
"integration on the product of two domains, a secondary domain of the "
"model can be specified after a 'Secondary_domain' string."
msgstr ""

# f1d831ef8a074a1e83dd0aba8356db70
#: ../source/scilab/cmdref_gf_asm.rst:78
msgid ""
"The variables and constant (data) are listed after the region number (or "
"optionally the model). For each variable/constant, first the "
"variable/constant name should be given (as it is referred in the assembly"
" string), then 1 if it is a variable or 0 for a constant, then the finite"
" element method if it is a fem variable/constant or the mesh_im_data if "
"it is data defined on integration points, and the vector representing the"
" value of the variable/constant. It is possible to give an arbitrary "
"number of variable/constant. The difference between a variable and a "
"constant is that automatic differentiation is done with respect to "
"variables only (see GetFEM++ user documentation). Test functions are only"
" available for variables, not for constants."
msgstr ""

# d5b8b6652b4741889757622235645ffa
#: ../source/scilab/cmdref_gf_asm.rst:91
msgid ""
"Note that if several variables are given, the assembly of the tangent "
"matrix/residual vector will be done considering the order in the call of "
"the function (the degrees of freedom of the first variable, then of the "
"second, and so on). If a model is provided, all degrees of freedom of the"
" model will be counted first."
msgstr ""

# 1d8e8693ae2a4d1c91d4c9bf420dc36f
#: ../source/scilab/cmdref_gf_asm.rst:97
msgid "For example, the L2 norm of a vector field \"u\" can be computed with::"
msgstr ""

# f3c242e5ad4f48f099d701cf7c1fa755
#: ../source/scilab/cmdref_gf_asm.rst:103
msgid ""
"The nonhomogeneous Laplacian stiffness matrix of a scalar field can be "
"evaluated with::"
msgstr ""

# f7615164f2734715bc0e3491819545c4
#: ../source/scilab/cmdref_gf_asm.rst:112
msgid ""
"``M = gf_asm('mass matrix', mesh_im mim, mesh_fem mf1[, mesh_fem mf2[, "
"int region]])``"
msgstr ""

# 0081cd7e36d54e4080263c85be85d809
#: ../source/scilab/cmdref_gf_asm.rst:114
msgid "Assembly of a mass matrix."
msgstr ""

# 67abb3e3290d43b9b5c5c5318ce96ae7
# 6c74c0f44f2b425797a7eebdc8999be2
# 5ee47bf682694e8fb8984aaf65ad1b9e
# e7c0dc89286e4fdd83b700cbc4aeca3f
# c52b0c6306c34b3e820dc9d1b8dd471d
# 4036be856d774f5ab8867464c05290a9
# 30eaac4395cb4188a5aa534b930bf5db
# 64c1641e7ed049808fdf0690478003d7
# 7e0bfbcceffd4aa59978ddf0373a6e80
# d0a742d1ca9b4ae998934d88703ddc21
#: ../source/scilab/cmdref_gf_asm.rst:116
#: ../source/scilab/cmdref_gf_asm.rst:126
#: ../source/scilab/cmdref_gf_asm.rst:137
#: ../source/scilab/cmdref_gf_asm.rst:184
#: ../source/scilab/cmdref_gf_asm.rst:194
#: ../source/scilab/cmdref_gf_asm.rst:204
#: ../source/scilab/cmdref_gf_asm.rst:266
#: ../source/scilab/cmdref_gf_asm.rst:399
#: ../source/scilab/cmdref_gf_asm.rst:407
#: ../source/scilab/cmdref_gf_asm.rst:415
msgid "Return a spmat object."
msgstr ""

# 571e4e4139114c15844e944d4bd585b1
#: ../source/scilab/cmdref_gf_asm.rst:120
msgid ""
"``L = gf_asm('laplacian', mesh_im mim, mesh_fem mf_u, mesh_fem mf_d, vec "
"a[, int region])``"
msgstr ""

# f5f0e9f3a63f4ea2ae7d6aedae9b5e0e
#: ../source/scilab/cmdref_gf_asm.rst:122
msgid "Assembly of the matrix for the Laplacian problem."
msgstr ""

# 9097529b61ec4ef792408e187a1fdd5b
#: ../source/scilab/cmdref_gf_asm.rst:124
msgid ""
"<latex style=\"text\"><![CDATA[\\nabla\\cdot(a(x)\\nabla u)]]></latex>  "
"with <literal>a</literal> a scalar."
msgstr ""

# 6c4ee718485d4d86b7d188b102130c09
#: ../source/scilab/cmdref_gf_asm.rst:130
msgid ""
"``Le = gf_asm('linear elasticity', mesh_im mim, mesh_fem mf_u, mesh_fem "
"mf_d, vec lambda_d, vec mu_d[, int region])``"
msgstr ""

# 21d449f823924479a2594fbed1d2a8f6
#: ../source/scilab/cmdref_gf_asm.rst:132
msgid "Assembles of the matrix for the linear (isotropic) elasticity problem."
msgstr ""

# 754abef0281543d18d69e20b9ae00358
#: ../source/scilab/cmdref_gf_asm.rst:134
msgid ""
"<latex style=\"text\"><![CDATA[\\nabla\\cdot(C(x):\\nabla u)]]></latex> "
"with <latex style=\"text\"><![CDATA[C]]></latex> defined via "
"<literal>lambda_d</literal> and <literal>mu_d</literal>."
msgstr ""

# 02facf6bec11479890ddcd72c4ee7594
#: ../source/scilab/cmdref_gf_asm.rst:141
msgid ""
"``TRHS = gf_asm('nonlinear elasticity', mesh_im mim, mesh_fem mf_u, vec "
"U, string law, mesh_fem mf_d, mat params, {'tangent "
"matrix'|'rhs'|'incompressible tangent matrix', mesh_fem mf_p, vec "
"P|'incompressible rhs', mesh_fem mf_p, vec P})``"
msgstr ""

# a261d7f4ab7c40feaa813de5178ef3b4
#: ../source/scilab/cmdref_gf_asm.rst:143
msgid ""
"Assembles terms (tangent matrix and right hand side) for nonlinear "
"elasticity."
msgstr ""

# 73cfbfd6010a42348498129547567c75
#: ../source/scilab/cmdref_gf_asm.rst:145
msgid ""
"The solution <literal>U</literal> is required at the current time-step. "
"The <literal>law</literal> may be choosen among:"
msgstr ""

# 88933c1c14eb4301b207bf77ecd905b5
#: ../source/scilab/cmdref_gf_asm.rst:148
msgid ""
"'SaintVenant Kirchhoff': Linearized law, should be avoided). This law has"
" the two usual Lame coefficients as parameters, called lambda and mu."
msgstr ""

# c0487a50dc564e8599cda4f3bc584ae9
#: ../source/scilab/cmdref_gf_asm.rst:151
msgid ""
"'Mooney Rivlin': This law has three parameters, called C1, C2 and D1. Can"
" be preceded with the words 'compressible' or 'incompressible' to force a"
" specific version. By default, the incompressible version is considered "
"which requires only the first two material coefficients."
msgstr ""

# c85f90f3cef4405cada0d09753f814d2
#: ../source/scilab/cmdref_gf_asm.rst:156
msgid ""
"'neo Hookean': A special case of the 'Mooney Rivlin' law that requires "
"one material coefficient less (C2 = 0). By default, its compressible "
"version is used."
msgstr ""

# 5acd8bcdcf1148eda6458edc81e463f1
#: ../source/scilab/cmdref_gf_asm.rst:159
msgid ""
"'Ciarlet Geymonat': This law has 3 parameters, called lambda, mu and "
"gamma, with gamma chosen such that gamma is in ]-lambda/2-mu, -mu[."
msgstr ""

# 762f4bf8abf345a8ac7162d31d96f284
#: ../source/scilab/cmdref_gf_asm.rst:163
msgid ""
"The parameters of the material law are described on the mesh_fem "
"<literal>mf_d</literal>. The matrix <literal>params</literal> should have"
" <literal>nbdof(mf_d)</literal> columns, each row correspounds to a "
"parameter."
msgstr ""

# 3d54817891094cc0945d5e8a1f99a43d
#: ../source/scilab/cmdref_gf_asm.rst:167
msgid ""
"The last argument selects what is to be built: either the tangent matrix,"
" or the right hand side. If the incompressibility is considered, it "
"should be followed by a mesh_fem <literal>mf_p</literal>, for the "
"pression."
msgstr ""

# 5dfb967d059b42eaafcd4b6702235cb3
#: ../source/scilab/cmdref_gf_asm.rst:172
msgid ""
"Return a spmat object (tangent matrix), vec object (right hand side), "
"tuple of spmat objects (incompressible tangent matrix), or tuple of vec "
"objects (incompressible right hand side)."
msgstr ""

# 02df517d3fad4b73b90e96fd82fa950b
#: ../source/scilab/cmdref_gf_asm.rst:178
msgid ""
"``A = gf_asm('helmholtz', mesh_im mim, mesh_fem mf_u, mesh_fem mf_d, vec "
"k[, int region])``"
msgstr ""

# e850363bcdd34f62a942aadd5b377fa2
#: ../source/scilab/cmdref_gf_asm.rst:180
msgid "Assembly of the matrix for the Helmholtz problem."
msgstr ""

# 3880381267bc46879bf64c8f383e7cfb
#: ../source/scilab/cmdref_gf_asm.rst:182
msgid ""
"<latex style=\"text\"><![CDATA[\\Delta u + k^2 u]]></latex> = 0,  with "
"<literal>k</literal> complex scalar."
msgstr ""

# 73dcdf4d0e29477193c94c989e525ef2
#: ../source/scilab/cmdref_gf_asm.rst:188
msgid ""
"``A = gf_asm('bilaplacian', mesh_im mim, mesh_fem mf_u, mesh_fem mf_d, "
"vec a[, int region])``"
msgstr ""

# c467157415fd4a47983d29b3f4f1eb3e
#: ../source/scilab/cmdref_gf_asm.rst:190
msgid "Assembly of the matrix for the Bilaplacian problem."
msgstr ""

# df5904954a1f463f963b2f703c936e67
# 278385164e3b4156bde7626ceea479e5
#: ../source/scilab/cmdref_gf_asm.rst:192
#: ../source/scilab/cmdref_gf_asm.rst:202
msgid ""
"<latex style=\"text\"><![CDATA[\\Delta(a(x)\\Delta u) = 0]]></latex>   "
"with <literal>a</literal> scalar."
msgstr ""

# 11fbc08b57a34de6b6e474efd7a4c652
#: ../source/scilab/cmdref_gf_asm.rst:198
msgid ""
"``A = gf_asm('bilaplacian KL', mesh_im mim, mesh_fem mf_u, mesh_fem mf_d,"
" vec a, vec nu[, int region])``"
msgstr ""

# 8902711c55f043589f550e60612efc16
#: ../source/scilab/cmdref_gf_asm.rst:200
msgid ""
"Assembly of the matrix for the Bilaplacian problem with Kirchhoff-Love "
"formulation."
msgstr ""

# f699e8f7b04b4c7384ddb5c20ca11c4e
#: ../source/scilab/cmdref_gf_asm.rst:208
msgid ""
"``V = gf_asm('volumic source', mesh_im mim, mesh_fem mf_u, mesh_fem mf_d,"
" vec fd[, int region])``"
msgstr ""

# dac397c18b3140e7ac28b0b91f7723b7
#: ../source/scilab/cmdref_gf_asm.rst:210
msgid "Assembly of a volumic source term."
msgstr ""

# 0cf57d67b1b54e21b977ea9126fd0aa3
#: ../source/scilab/cmdref_gf_asm.rst:212
msgid ""
"Output a vector <literal>V</literal>, assembled on the mesh_fem "
"<literal>mf_u</literal>, using the data vector <literal>fd</literal> "
"defined on the data mesh_fem <literal>mf_d</literal>. "
"<literal>fd</literal> may be real or complex-valued."
msgstr ""

# 097b5ba5076d45968593f83b5fa6ee95
# 8fdcacb738a94239b3aaa8a1de5adab4
# bb1d52ea3bdf46078b60cc8b7708f3bb
# 815e14aa6b25461892d5fbeae18e6f12
#: ../source/scilab/cmdref_gf_asm.rst:216
#: ../source/scilab/cmdref_gf_asm.rst:228
#: ../source/scilab/cmdref_gf_asm.rst:380
#: ../source/scilab/cmdref_gf_asm.rst:391
msgid "Return a vec object."
msgstr ""

# ab4226814b3f4bd9a36817f9f1b871c6
#: ../source/scilab/cmdref_gf_asm.rst:220
msgid ""
"``B = gf_asm('boundary source', int bnum, mesh_im mim, mesh_fem mf_u, "
"mesh_fem mf_d, vec G)``"
msgstr ""

# 60c8e069271d48c6b127c43ad421326f
#: ../source/scilab/cmdref_gf_asm.rst:222
msgid "Assembly of a boundary source term."
msgstr ""

# 10154926cc3c44d8b0cabf6a4c74a401
#: ../source/scilab/cmdref_gf_asm.rst:224
msgid ""
"<literal>G</literal> should be a [Qdim x N] matrix, where N is the number"
" of dof of <literal>mf_d</literal>, and Qdim is the dimension of the "
"unkown u (that is set when creating the mesh_fem)."
msgstr ""

# 8e9dc1a5e0a44be3883ea9d7b19e912b
#: ../source/scilab/cmdref_gf_asm.rst:232
msgid ""
"``{HH, RR} = gf_asm('dirichlet', int bnum, mesh_im mim, mesh_fem mf_u, "
"mesh_fem mf_d, mat H, vec R [, scalar threshold])``"
msgstr ""

# 2cec754ea72545b7a90d442325fffdca
#: ../source/scilab/cmdref_gf_asm.rst:234
msgid "Assembly of Dirichlet conditions of type <literal>h.u = r</literal>."
msgstr ""

# d5f096f7fcb7422583ef20f5e838d54f
#: ../source/scilab/cmdref_gf_asm.rst:236
msgid ""
"Handle <literal>h.u = r</literal> where h is a square matrix (of any "
"rank) whose size is equal to the dimension of the unkown u. This matrix "
"is stored in <literal>H</literal>, one column per dof in "
"<literal>mf_d</literal>, each column containing the values of the matrix "
"h stored in fortran order:"
msgstr ""

# dcdff873ab1b412694f888adc639643a
#: ../source/scilab/cmdref_gf_asm.rst:245
msgid "if u is a 2D vector field."
msgstr ""

# 41337659cac7415db33b9a21f9753f6c
#: ../source/scilab/cmdref_gf_asm.rst:247
msgid ""
"Of course, if the unknown is a scalar field, you just have to set "
"<literal>H = ones(1, N)</literal>, where N is the number of dof of "
"<literal>mf_d</literal>."
msgstr ""

# 9e1f87e913dd46fca4d2590b17a61f35
#: ../source/scilab/cmdref_gf_asm.rst:250
msgid ""
"This is basically the same than calling gf_asm('boundary qu term') for "
"<literal>H</literal> and calling gf_asm('neumann') for "
"<literal>R</literal>, except that this function tries to produce a "
"'better' (more diagonal) constraints matrix (when possible)."
msgstr ""

# 4eb4adfdadba4ad3a3212fa10c8ad729
#: ../source/scilab/cmdref_gf_asm.rst:255
msgid "See also gf_spmat_get(spmat S, 'Dirichlet_nullspace')."
msgstr ""

# b36da0ff63d94b71bddc2062c847ace8
#: ../source/scilab/cmdref_gf_asm.rst:258
msgid ""
"``Q = gf_asm('boundary qu term',int boundary_num, mesh_im mim, mesh_fem "
"mf_u, mesh_fem mf_d, mat q)``"
msgstr ""

# 1935444d9a1a4d49bddb6cb7e436b39a
#: ../source/scilab/cmdref_gf_asm.rst:260
msgid "Assembly of a boundary qu term."
msgstr ""

# 36997720ff78446096d9ef2e2f032226
#: ../source/scilab/cmdref_gf_asm.rst:262
msgid ""
"<literal>q</literal> should be be a [Qdim x Qdim x N] array, where N is "
"the number of dof of <literal>mf_d</literal>, and Qdim is the dimension "
"of the unkown u (that is set when creating the mesh_fem)."
msgstr ""

# c446ce94a0b9464a84e2d2aa8f8285ca
#: ../source/scilab/cmdref_gf_asm.rst:270
msgid ""
"``gf_asm('define function', string name, int nb_args, string expression[,"
" string expression_derivative_t[, string expression_derivative_u]])``"
msgstr ""

# 4bae6191a16a4272b195819a63c6164e
#: ../source/scilab/cmdref_gf_asm.rst:272
msgid ""
"Define a new function <literal>name</literal> which can be used in high "
"level generic assembly. The function can have one or two parameters. In "
"<literal>expression</literal> all available predefined function or "
"operation of the generic assembly can be used. However, no reference to "
"some variables or data can be specified. The argument of the function is "
"<literal>t</literal> for a one parameter function and "
"<literal>t</literal> and <literal>u</literal> for a two parameter "
"function. For instance 'sin(pi*t)+2*t*t' is a valid expression for a one "
"parameter function and 'sin(max(t,u)*pi)' is a valid expression for a two"
" parameters function. <literal>expression_derivative_t</literal> and "
"<literal>expression_derivative_u</literal> are optional expressions for "
"the derivatives with respect to <literal>t</literal> and "
"<literal>u</literal>. If they are not furnished, a symbolic derivation is"
" used."
msgstr ""

# 4324f024cbcb44c792c2d31d849df525
#: ../source/scilab/cmdref_gf_asm.rst:287
msgid "``gf_asm('undefine function', string name)``"
msgstr ""

# e3401b7e3321412b963f7df9fb18562e
#: ../source/scilab/cmdref_gf_asm.rst:289
msgid ""
"Cancel the definition of a previously defined function "
"<literal>name</literal> for the high level generic assembly."
msgstr ""

# fb6f6f2778c748f6b02620570f3f055b
#: ../source/scilab/cmdref_gf_asm.rst:293
msgid ""
"``gf_asm('define linear hardening function', string name, scalar "
"sigma_y0, scalar H, ... [string 'Frobenius'])``"
msgstr ""

# 43541883cbbb487da2ebac0728ae22f2
#: ../source/scilab/cmdref_gf_asm.rst:295
msgid ""
"Define a new linear hardening function under the name "
"<literal>name</literal>, with initial yield stress "
"<literal>sigma_y0</literal> and hardening modulus H. If an extra string "
"argument with the value 'Frobenius' is provided, the hardening function "
"is expressed in terms of Frobenius norms of its input strain and output "
"stress, instead of their Von-Mises equivalents."
msgstr ""

# 1c86257d408b48c9b148e6b9f8b99498
#: ../source/scilab/cmdref_gf_asm.rst:302
msgid ""
"``gf_asm('define Ramberg Osgood hardening function', string name, scalar "
"sigma_ref, {scalar eps_ref | scalar E, scalar alpha}, scalar n[, string "
"'Frobenius'])``"
msgstr ""

# 237decf4173e42d7967ede3edb83d080
#: ../source/scilab/cmdref_gf_asm.rst:304
msgid ""
"Define a new Ramberg Osgood hardening function under the name "
"<literal>name</literal>, with initial yield stress "
"<literal>sigma_y0</literal> and hardening modulus H. If an extra string "
"argument with the value 'Frobenius' is provided, the hardening function "
"is expressed in terms of Frobenius norms of its input strain and output "
"stress, instead of their Von-Mises equivalents."
msgstr ""

# 25a393ad38e64266b28fa390af63dc4b
#: ../source/scilab/cmdref_gf_asm.rst:311
msgid ""
"``gf_asm('expression analysis', string expression [, {@tm mesh | mesh_im "
"mim}] [, der_order] [, model model] [, string varname, int is_variable[, "
"{mesh_fem mf | mesh_imd mimd}], ...])``"
msgstr ""

# 67be64607b734a5286cde27d86371ae1
#: ../source/scilab/cmdref_gf_asm.rst:313
msgid ""
"Analyse a high-level generic assembly expression and print information "
"about the provided expression."
msgstr ""

# c9cca6f62fd045c095727068605ce56e
#: ../source/scilab/cmdref_gf_asm.rst:317
msgid ""
"``{...} = gf_asm('volumic' [,CVLST], expr [, mesh_ims, mesh_fems, "
"data...])``"
msgstr ""

# 35240598768d4466a5a0a8263d6e3eef
#: ../source/scilab/cmdref_gf_asm.rst:319
msgid "Low-level generic assembly procedure for volumic assembly."
msgstr ""

# c347378797364260897b9d92f28735c5
#: ../source/scilab/cmdref_gf_asm.rst:321
msgid ""
"The expression <literal>expr</literal> is evaluated over the mesh_fem's "
"listed in the arguments (with optional data) and assigned to the output "
"arguments. For details about the syntax of assembly expressions, please "
"refer to the getfem user manual (or look at the file getfem_assembling.h "
"in the getfem++ sources)."
msgstr ""

# 096e03da87624ebd914a7d4c975d8b2c
#: ../source/scilab/cmdref_gf_asm.rst:327
msgid "For example, the L2 norm of a field can be computed with::"
msgstr ""

# 3fa0ae055e1240e9adcffcca1f98fcb8
#: ../source/scilab/cmdref_gf_asm.rst:333
msgid "The Laplacian stiffness matrix can be evaluated with::"
msgstr ""

# aeac567241bf4f0cb77f2315ffcf7bab
#: ../source/scilab/cmdref_gf_asm.rst:340
msgid ""
"``{...} = gf_asm('boundary', int bnum, string expr [, mesh_im mim, "
"mesh_fem mf, data...])``"
msgstr ""

# 5dd65dcf1b624553b875e842f1180f55
#: ../source/scilab/cmdref_gf_asm.rst:342
msgid "Low-level generic boundary assembly."
msgstr ""

# 787dfb0fad8946f897c2269248b406af
#: ../source/scilab/cmdref_gf_asm.rst:344
msgid "See the help for gf_asm('volumic')."
msgstr ""

# f6566107238a4a30ad802ee62d785a87
#: ../source/scilab/cmdref_gf_asm.rst:347
msgid ""
"``Mi = gf_asm('interpolation matrix', mesh_fem mf, {mesh_fem mfi | vec "
"pts})``"
msgstr ""

# 8b43f83e1c944244b5d37817f5c91e1e
#: ../source/scilab/cmdref_gf_asm.rst:349
msgid ""
"Build the interpolation matrix from a mesh_fem onto another mesh_fem or a"
" set of points."
msgstr ""

# d095b273ba5c46ca8c96eaa59980d1ce
#: ../source/scilab/cmdref_gf_asm.rst:351
msgid ""
"Return a matrix <literal>Mi</literal>, such that <literal>V = "
"Mi.U</literal> is equal to gf_compute('interpolate_on',mfi). Useful for "
"repeated interpolations. Note that this is just interpolation, no "
"elementary integrations are involved here, and <literal>mfi</literal> has"
" to be lagrangian. In the more general case, you would have to do a L2 "
"projection via the mass matrix."
msgstr ""

# 2320d1f42b874870adf96aecf41d6134
#: ../source/scilab/cmdref_gf_asm.rst:358
msgid "<literal>Mi</literal> is a spmat object."
msgstr ""

# 02f59c7f65484081960e618affe1bde4
#: ../source/scilab/cmdref_gf_asm.rst:362
msgid ""
"``Me = gf_asm('extrapolation matrix',mesh_fem mf,  {mesh_fem mfe | vec "
"pts})``"
msgstr ""

# 73fc8de141de419eaaea9fd1ac6aa47c
#: ../source/scilab/cmdref_gf_asm.rst:364
msgid ""
"Build the extrapolation matrix from a mesh_fem onto another mesh_fem or a"
" set of points."
msgstr ""

# 2fec4185b4c346b590bf3160948ea9f7
#: ../source/scilab/cmdref_gf_asm.rst:366
msgid ""
"Return a matrix <literal>Me</literal>, such that <literal>V = "
"Me.U</literal> is equal to gf_compute('extrapolate_on',mfe). Useful for "
"repeated extrapolations."
msgstr ""

# 97873ed3ff82419fbbfe4d466af07d3b
#: ../source/scilab/cmdref_gf_asm.rst:370
msgid "<literal>Me</literal> is a spmat object."
msgstr ""

# 55c350cdf4154273b892ebb94b0ffdf6
#: ../source/scilab/cmdref_gf_asm.rst:374
msgid ""
"``B = gf_asm('integral contact Uzawa projection', int bnum, mesh_im mim, "
"mesh_fem mf_u, vec U, mesh_fem mf_lambda, vec vec_lambda, mesh_fem "
"mf_obstacle, vec obstacle, scalar r [, {scalar coeff | mesh_fem mf_coeff,"
" vec coeff} [, int option[, scalar alpha, vec W]]])``"
msgstr ""

# 675503a7b1294396b266b03a472569e0
#: ../source/scilab/cmdref_gf_asm.rst:378
msgid "Specific assembly procedure for the use of an Uzawa algorithm to solve"
msgstr ""

# b790d7707c7f419d98d870494dcd0e6c
#: ../source/scilab/cmdref_gf_asm.rst:377
msgid ""
"contact problems. Projects the term $-(\\lambda - r (u_N-g))_-$ on the "
"finite element space of $\\lambda$."
msgstr ""

# b9e66c2d884742c19c2230bc747c0e4e
#: ../source/scilab/cmdref_gf_asm.rst:384
msgid ""
"``B = gf_asm('level set normal source term', int bnum, mesh_im mim, "
"mesh_fem mf_u, mesh_fem mf_lambda, vec vec_lambda, mesh_fem mf_levelset, "
"vec levelset)``"
msgstr ""

# f968608b93204538ab812537e7d77c9a
#: ../source/scilab/cmdref_gf_asm.rst:386
msgid ""
"Performs an assembly of the source term represented by "
"<literal>vec_lambda</literal> on <literal>mf_lambda</literal> considered "
"to be a component in the direction of the gradient of a levelset function"
" (normal to the levelset) of a vector field defined on "
"<literal>mf_u</literal> on the boundary <literal>bnum</literal>."
msgstr ""

# 2a30bf1a295746a2815d461e76d85543
#: ../source/scilab/cmdref_gf_asm.rst:395
msgid ""
"``M = gf_asm('lsneuman matrix', mesh_im mim, mesh_fem mf1, mesh_fem mf2, "
"levelset ls[, int region])``"
msgstr ""

# 769f6179607e41c2bcfbbe2e12f0e5e8
#: ../source/scilab/cmdref_gf_asm.rst:397
msgid "Assembly of a level set Neuman  matrix."
msgstr ""

# e0e3f1d8917943c1ae516b0b4f6614be
#: ../source/scilab/cmdref_gf_asm.rst:403
msgid ""
"``M = gf_asm('nlsgrad matrix', mesh_im mim, mesh_fem mf1, mesh_fem mf2, "
"levelset ls[, int region])``"
msgstr ""

# 9f90641d6e6e4e7ea2c5c4f1abea7b35
#: ../source/scilab/cmdref_gf_asm.rst:405
msgid "Assembly of a nlsgrad matrix."
msgstr ""

# 3d12b8c75a1d44de85f254164d3ddf39
#: ../source/scilab/cmdref_gf_asm.rst:411
msgid ""
"``M = gf_asm('stabilization patch matrix', @tm mesh, mesh_fem mf,  "
"mesh_im mim, real ratio, real h)``"
msgstr ""

# 7eb16f7fa24745af82bf43c1a35b68c3
#: ../source/scilab/cmdref_gf_asm.rst:413
msgid "Assembly of stabilization patch matrix ."
msgstr ""

# 775c4738f053476e83531f2284be1bb9
#~ msgid ""
#~ "``{...} = gf_asm('generic', mesh_im mim, "
#~ "int order, string expression, int "
#~ "region, [model model,] [string varname, "
#~ "int is_variable[, {mesh_fem mf, mesh_imd "
#~ "mimd}], value], ...)``"
#~ msgstr ""

# dd85dd9d570d4fc8ba0ce1cf2da2c8b5
#~ msgid ""
#~ "<literal>model</literal> is an optional "
#~ "parameter allowing to take into account"
#~ " all variables and data of a "
#~ "model."
#~ msgstr ""

