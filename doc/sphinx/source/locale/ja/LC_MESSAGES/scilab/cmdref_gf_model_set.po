# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2004-2017 GetFEM++ project
# This file is distributed under the same license as the GetFEM++ package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: GetFEM++ 5.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-22 15:02+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

# ae2d94a06c894a109b5f7e82585d94bd
#: ../source/scilab/cmdref_gf_model_set.rst:8
msgid "gf_model_set"
msgstr ""

# 2d2f147f8cdd4f17b89ed9c5c6d345e0
#: ../source/scilab/cmdref_gf_model_set.rst:10
msgid "**Synopsis**"
msgstr ""

# b50b0d68934a43a9a3a23e9d47e32866
#: ../source/scilab/cmdref_gf_model_set.rst:136
msgid "**Description :**"
msgstr ""

# 249f2199e52d4653b0c2db947b426c1b
#: ../source/scilab/cmdref_gf_model_set.rst:139
msgid "Modifies a model object."
msgstr ""

# 8740146e5309429bb3a500e1a049a433
#: ../source/scilab/cmdref_gf_model_set.rst:142
msgid "**Command list :**"
msgstr ""

# 741185da105a4a968b8b6c7266369b73
#: ../source/scilab/cmdref_gf_model_set.rst:146
msgid "``gf_model_set(model M, 'clear')``"
msgstr ""

# 1adb8335aebb46e487106318216d18c8
#: ../source/scilab/cmdref_gf_model_set.rst:148
msgid "Clear the model."
msgstr ""

# 7c5b956c8e1a4135a15bfd8cc2f478d0
#: ../source/scilab/cmdref_gf_model_set.rst:151
msgid "``gf_model_set(model M, 'add fem variable', string name, mesh_fem mf)``"
msgstr ""

# a59e806b85424342ac6610a9269ac435
#: ../source/scilab/cmdref_gf_model_set.rst:153
msgid ""
"Add a variable to the model linked to a mesh_fem. <literal>name</literal>"
" is the variable name."
msgstr ""

# 9a86a86352af4af8a418be114e5393ab
#: ../source/scilab/cmdref_gf_model_set.rst:157
msgid ""
"``gf_model_set(model M, 'add filtered fem variable', string name, "
"mesh_fem mf, int region)``"
msgstr ""

# bd1a71387b0b481e8b6adeb29abc650c
#: ../source/scilab/cmdref_gf_model_set.rst:159
msgid ""
"Add a variable to the model linked to a mesh_fem. The variable is "
"filtered in the sense that only the dof on the region are considered. "
"<literal>name</literal> is the variable name."
msgstr ""

# 12c13f31f075435c9ce8ae3ae3cd57ca
#: ../source/scilab/cmdref_gf_model_set.rst:164
msgid "``gf_model_set(model M, 'add variable', string name, sizes)``"
msgstr ""

# 4044b1345dfd496b88b1c0cdda2ea0c2
#: ../source/scilab/cmdref_gf_model_set.rst:166
msgid ""
"Add a variable to the model of constant sizes. <literal>sizes</literal> "
"is either a integer (for a scalar or vector variable) or a vector of "
"dimensions for a tensor variable. <literal>name</literal> is the variable"
" name."
msgstr ""

# 080e952283a04bd3b50f7b0ad5eaf4ed
#: ../source/scilab/cmdref_gf_model_set.rst:171
msgid "``gf_model_set(model M, 'delete variable', string name)``"
msgstr ""

# 0e9ed6b1c7f94b8e9c0716a88c468ce5
# 26d49eb245434de1b1fcf5ddcd753c93
#: ../source/scilab/cmdref_gf_model_set.rst:173
#: ../source/scilab/cmdref_gf_model_set.rst:263
msgid "Delete a variable or a data from the model."
msgstr ""

# 40283ac468114d7789434a5b8454c1af
#: ../source/scilab/cmdref_gf_model_set.rst:176
msgid "``gf_model_set(model M, 'resize variable', string name, sizes)``"
msgstr ""

# 9bf8838fc1364e6cbf98eb66b5f18ac4
#: ../source/scilab/cmdref_gf_model_set.rst:178
msgid ""
"Resize a  constant size variable of the model.  <literal>sizes</literal> "
"is either a integer (for a scalar or vector variable) or a vector of "
"dimensions for a tensor variable. <literal>name</literal> is the variable"
" name."
msgstr ""

# b6f49268e3d64faa9f6827c45bf5f109
#: ../source/scilab/cmdref_gf_model_set.rst:183
msgid ""
"``gf_model_set(model M, 'add multiplier', string name, mesh_fem mf, "
"string primalname[, mesh_im mim, int region])``"
msgstr ""

# 51248de4267945e595cf553ca2a0a809
#: ../source/scilab/cmdref_gf_model_set.rst:185
msgid ""
"Add a particular variable linked to a fem being a multiplier with respect"
" to a primal variable. The dof will be filtered with the "
"<literal></literal>gmm::range_basis<literal></literal> function applied "
"on the terms of the model which link the multiplier and the primal "
"variable. This in order to retain only linearly independent constraints "
"on the primal variable. Optimized for boundary multipliers."
msgstr ""

# c405e2db5f4f4b83966291bb495cdedf
#: ../source/scilab/cmdref_gf_model_set.rst:193
msgid "``gf_model_set(model M, 'add im data', string name, mesh_imd mimd)``"
msgstr ""

# 16346a51bec5402f86ce0ad713303a21
#: ../source/scilab/cmdref_gf_model_set.rst:195
msgid ""
"Add a data set to the model linked to a mesh_imd. <literal>name</literal>"
" is the data name."
msgstr ""

# 107af5a112724fb2b5d1dd2e55743692
#: ../source/scilab/cmdref_gf_model_set.rst:199
msgid ""
"``gf_model_set(model M, 'add fem data', string name, mesh_fem mf[, "
"sizes])``"
msgstr ""

# 13f94f6d906b40f6bf047bd3df9ddfd0
#: ../source/scilab/cmdref_gf_model_set.rst:201
msgid ""
"Add a data to the model linked to a mesh_fem. <literal>name</literal> is "
"the data name, <literal>sizes</literal> an optional parameter which is "
"either an integer  or a vector of suplementary dimensions with respect to"
" <literal>mf</literal>."
msgstr ""

# 2bac7a4acf33462ca47e63e5629dd1a3
#: ../source/scilab/cmdref_gf_model_set.rst:206
msgid ""
"``gf_model_set(model M, 'add initialized fem data', string name, mesh_fem"
" mf, vec V[, sizes])``"
msgstr ""

# 5fcf960fb19d4c16b1a7eb916ac100db
#: ../source/scilab/cmdref_gf_model_set.rst:208
msgid ""
"Add a data to the model linked to a mesh_fem. <literal>name</literal> is "
"the data name. The data is initiakized with <literal>V</literal>. The "
"data can be a scalar or vector field. <literal>sizes</literal> an "
"optional parameter which is either an integer or a vector of suplementary"
" dimensions with respect to <literal>mf</literal>."
msgstr ""

# 7564e139102249baa2f5f5ed1f68d775
#: ../source/scilab/cmdref_gf_model_set.rst:214
msgid "``gf_model_set(model M, 'add data', string name, int size)``"
msgstr ""

# 0ab64a3eb39b412bbc578311376ce1cc
#: ../source/scilab/cmdref_gf_model_set.rst:216
msgid ""
"Add a fixed size data to the model.  <literal>sizes</literal> is either a"
" integer (for a scalar or vector data) or a vector of dimensions for a "
"tensor data. <literal>name</literal> is the data name."
msgstr ""

# 1a7fabb875ca476c8dd22fbf740bb6d7
#: ../source/scilab/cmdref_gf_model_set.rst:221
msgid "``gf_model_set(model M, 'add macro', string name, string expr)``"
msgstr ""

# fa647c95621141d3ba206b4b33c4c7dc
#: ../source/scilab/cmdref_gf_model_set.rst:223
msgid ""
"Define a new macro for the high generic assembly language. The name "
"include the parameters. For instance name='sp(a,b)', expr='a.b' is a "
"valid definition. Macro without parameter can also be defined. For "
"instance name='x1', expr='X[1]' is valid. Teh form name='grad(u)', "
"expr='Grad_u' is also allowed but in that case, the parameter 'u' will "
"only be allowed to be a variable name when using the macro. Note that "
"macros can be directly defined inside the assembly strings with the "
"keyword 'Def'."
msgstr ""

# f1a44b45bda2421db2d2692b24594e6e
#: ../source/scilab/cmdref_gf_model_set.rst:234
msgid "``gf_model_set(model M, 'del macro', string name)``"
msgstr ""

# af3e33016ce54cdfbda0968e85f9cc71
#: ../source/scilab/cmdref_gf_model_set.rst:236
msgid "Delete a previously defined macro for the high generic assembly language."
msgstr ""

# faff0fbcda6246d9bb4471535cb62f77
#: ../source/scilab/cmdref_gf_model_set.rst:240
msgid ""
"``gf_model_set(model M, 'add initialized data', string name, vec V[, "
"sizes])``"
msgstr ""

# a597333ae2be467698ab96675ab2db24
#: ../source/scilab/cmdref_gf_model_set.rst:242
msgid ""
"Add an initialized fixed size data to the model. <literal>sizes</literal>"
" an optional parameter which is either an integer  or a vector dimensions"
" that describes the format of the data. By default, the data is "
"considered to b a vector field. <literal>name</literal> is the data name "
"and <literal>V</literal> is the value of the data."
msgstr ""

# 498c430f751d4ba1a816af7a52ff3237
#: ../source/scilab/cmdref_gf_model_set.rst:249
msgid "``gf_model_set(model M, 'variable', string name, vec V)``"
msgstr ""

# 7aca03baf814470da82f3f3456a88ffa
#: ../source/scilab/cmdref_gf_model_set.rst:251
msgid ""
"Set the value of a variable or data. <literal>name</literal> is the data "
"name."
msgstr ""

# 4c598ec9392b437ea8cadd10b02db2c1
#: ../source/scilab/cmdref_gf_model_set.rst:254
msgid "``gf_model_set(model M, 'to variables', vec V)``"
msgstr ""

# 2ccaee10c17d44f48297c192277c973e
#: ../source/scilab/cmdref_gf_model_set.rst:256
msgid ""
"Set the value of the variables of the model with the vector "
"<literal>V</literal>. Typically, the vector <literal>V</literal> results "
"of the solve of the tangent linear system (useful to solve your problem "
"with you own solver)."
msgstr ""

# 180266a0161d4c179d49325746a81eab
#: ../source/scilab/cmdref_gf_model_set.rst:261
msgid "``gf_model_set(model M, 'delete brick', int ind_brick)``"
msgstr ""

# cd758972071145178f94d9ee3a02f147
#: ../source/scilab/cmdref_gf_model_set.rst:266
msgid ""
"``gf_model_set(model M, 'define variable group', string name[, string "
"varname, ...])``"
msgstr ""

# 38adfe89a1e842ea95063fdbc1b71abe
#: ../source/scilab/cmdref_gf_model_set.rst:268
msgid ""
"Defines a group of variables for the interpolation (mainly for the "
"raytracing interpolation transformation."
msgstr ""

# e3756cbfad044ced94b931dc80a6f9c0
#: ../source/scilab/cmdref_gf_model_set.rst:272
msgid ""
"``gf_model_set(model M, 'add elementary rotated RT0 projection', string "
"transname)``"
msgstr ""

# 5a0b27d339104476821f597f720f5b27
#: ../source/scilab/cmdref_gf_model_set.rst:274
msgid "Experimental method ..."
msgstr ""

# 9c2ce6b8801e42a899ebed26f2eba2e2
#: ../source/scilab/cmdref_gf_model_set.rst:277
msgid ""
"``gf_model_set(model M, 'add interpolate transformation from expression',"
" string transname, mesh source_mesh, mesh target_mesh, string expr)``"
msgstr ""

# 9442b1cb78f2413790cece18047c29f0
#: ../source/scilab/cmdref_gf_model_set.rst:279
msgid ""
"Add a transformation to the model from mesh "
"<literal>source_mesh</literal> to mesh <literal>target_mesh</literal> "
"given by the expression <literal>expr</literal> which corresponds to a "
"high-level generic assembly expression which may contains some variable "
"of the model. CAUTION: the derivative of the transformation with used "
"variable is taken into account in the computation of the tangen system. "
"However, order two derivative is not implemented, so such tranformation "
"is not allowed in the definition of a potential."
msgstr ""

# 41717ed45a784556bbc5666521607184
#: ../source/scilab/cmdref_gf_model_set.rst:289
msgid ""
"``gf_model_set(model M, 'add element extrapolation transformation', "
"string transname, mesh source_mesh, mat elt_corr)``"
msgstr ""

# 87c66b91ff3b414ca8529b01ce6bdb67
#: ../source/scilab/cmdref_gf_model_set.rst:291
msgid ""
"Add a special interpolation transformation which represents the identity "
"transformation but allows to evaluate the expression on another element "
"than the current element by polynomial extrapolation. It is used for "
"stabilization term in fictitious domain applications. the array elt_cor "
"should be a two entry array whose first line contains the elements "
"concerned by the transformation and the second line the respective "
"elements on which the extrapolation has to be made. If an element is not "
"listed in elt_cor the evaluation is just made on the current element."
msgstr ""

# d50ca6b24d4e44799ef3acdc89960fe6
#: ../source/scilab/cmdref_gf_model_set.rst:302
msgid ""
"``gf_model_set(model M, 'set element extrapolation correspondance', "
"string transname, mat elt_corr)``"
msgstr ""

# dee40c9d7eae4a5192ffc301f45d440b
#: ../source/scilab/cmdref_gf_model_set.rst:304
msgid ""
"Change the correspondance map of an element extrapolation interpolate "
"transformation."
msgstr ""

# ba2f43c5bfe04b989658378e55e5ff9a
#: ../source/scilab/cmdref_gf_model_set.rst:308
msgid ""
"``gf_model_set(model M, 'add raytracing transformation', string "
"transname, scalar release_distance)``"
msgstr ""

# f32e3dac04f443d7b73cfc9a5cd980b1
#: ../source/scilab/cmdref_gf_model_set.rst:310
msgid ""
"Add a raytracing interpolate transformation called "
"<literal>transname</literal> to a model to be used by the generic "
"assembly bricks. CAUTION: For the moment, the derivative of the "
"transformation is not taken into account in the model solve."
msgstr ""

# 0a5c1fe7adac441ebfe9f2240e104f9e
#: ../source/scilab/cmdref_gf_model_set.rst:316
msgid ""
"``gf_model_set(model M, 'add master contact boundary to raytracing "
"transformation', string transname, mesh m, string dispname, int region)``"
msgstr ""

# 7513227cb40543658ba793ec3a0dcc7e
#: ../source/scilab/cmdref_gf_model_set.rst:318
msgid ""
"Add a master contact boundary with corresponding displacement variable "
"<literal>dispname</literal> on a specific boundary "
"<literal>region</literal> to an existing raytracing interpolate "
"transformation called <literal>transname</literal>."
msgstr ""

# 73798ce0e11d44369ce9e114defb87b2
#: ../source/scilab/cmdref_gf_model_set.rst:323
msgid ""
"``gf_model_set(model M, 'add slave contact boundary to raytracing "
"transformation', string transname, mesh m, string dispname, int region)``"
msgstr ""

# 09f9197a6e6942fd9fca18114df4d967
#: ../source/scilab/cmdref_gf_model_set.rst:325
msgid ""
"Add a slave contact boundary with corresponding displacement variable "
"<literal>dispname</literal> on a specific boundary "
"<literal>region</literal> to an existing raytracing interpolate "
"transformation called <literal>transname</literal>."
msgstr ""

# abb3264dfa9d4f0aa3b3040b5bddd0ac
#: ../source/scilab/cmdref_gf_model_set.rst:330
msgid ""
"``gf_model_set(model M, 'add rigid obstacle to raytracing "
"transformation', string transname, string expr, int N)``"
msgstr ""

# 26965a23988640e788959422fc43d9c3
#: ../source/scilab/cmdref_gf_model_set.rst:332
msgid ""
"Add a rigid obstacle whose geometry corresponds to the zero level-set of "
"the high-level generic assembly expression <literal>expr</literal> to an "
"existing raytracing interpolate transformation called "
"<literal>transname</literal>."
msgstr ""

# 4bd72838986f4391814e28ce6f024f67
#: ../source/scilab/cmdref_gf_model_set.rst:338
msgid ""
"``gf_model_set(model M, 'add projection transformation', string "
"transname, scalar release_distance)``"
msgstr ""

# 10e618cc670240959a5361c5829267fa
#: ../source/scilab/cmdref_gf_model_set.rst:340
msgid ""
"Add a projection interpolate transformation called "
"<literal>transname</literal> to a model to be used by the generic "
"assembly bricks. CAUTION: For the moment, the derivative of the "
"transformation is not taken into account in the model solve."
msgstr ""

# bcf39f3926eb4320b16c07fd5ef588a6
#: ../source/scilab/cmdref_gf_model_set.rst:346
msgid ""
"``gf_model_set(model M, 'add master contact boundary to projection "
"transformation', string transname, mesh m, string dispname, int region)``"
msgstr ""

# 7b5d8ff3f47d486f8547a63c3e29e661
#: ../source/scilab/cmdref_gf_model_set.rst:348
msgid ""
"Add a master contact boundary with corresponding displacement variable "
"<literal>dispname</literal> on a specific boundary "
"<literal>region</literal> to an existing projection interpolate "
"transformation called <literal>transname</literal>."
msgstr ""

# 017d88c1c93b44e5a92c41f20f862fee
#: ../source/scilab/cmdref_gf_model_set.rst:353
msgid ""
"``gf_model_set(model M, 'add slave contact boundary to projection "
"transformation', string transname, mesh m, string dispname, int region)``"
msgstr ""

# 79191fe6afbe4c0c8df16a9d2be84f93
#: ../source/scilab/cmdref_gf_model_set.rst:355
msgid ""
"Add a slave contact boundary with corresponding displacement variable "
"<literal>dispname</literal> on a specific boundary "
"<literal>region</literal> to an existing projection interpolate "
"transformation called <literal>transname</literal>."
msgstr ""

# f6600f3c408a412dae56974ac6a3f0d5
#: ../source/scilab/cmdref_gf_model_set.rst:360
msgid ""
"``gf_model_set(model M, 'add rigid obstacle to projection "
"transformation', string transname, string expr, int N)``"
msgstr ""

# ca4556c09599457abe8318210eeb1a16
#: ../source/scilab/cmdref_gf_model_set.rst:362
msgid ""
"Add a rigid obstacle whose geometry corresponds to the zero level-set of "
"the high-level generic assembly expression <literal>expr</literal> to an "
"existing projection interpolate transformation called "
"<literal>transname</literal>."
msgstr ""

# 411e093b513a4530864cd0a783662259
#: ../source/scilab/cmdref_gf_model_set.rst:368
msgid ""
"``ind = gf_model_set(model M, 'add linear term', mesh_im mim, string "
"expression[, int region[, int is_symmetric[, int is_coercive]]])``"
msgstr ""

# f72d9edb8a4549caa977de12739d2274
#: ../source/scilab/cmdref_gf_model_set.rst:370
msgid ""
"Adds a matrix term given by the assembly string <literal>expr</literal> "
"which will be assembled in region <literal>region</literal> and with the "
"integration method <literal>mim</literal>. Only the matrix term will be "
"taken into account, assuming that it is linear. The advantage of "
"declaring a term linear instead of nonlinear is that it will be assembled"
" only once and no assembly is necessary for the residual. Take care that "
"if the expression contains some variables and if the expression is a "
"potential or of first order (i.e. describe the weak form, not the "
"derivative of the weak form), the expression will be derivated with "
"respect to all variables. You can specify if the term is symmetric, "
"coercive or not. If you are not sure, the better is to declare the term "
"not symmetric and not coercive. But some solvers (conjugate gradient for "
"instance) are not allowed for non-coercive problems. "
"<literal>brickname</literal> is an otpional name for the brick."
msgstr ""

# 33b4223018974dde83f81b1d5cea9fdc
#: ../source/scilab/cmdref_gf_model_set.rst:388
msgid ""
"``ind = gf_model_set(model M, 'add linear generic assembly brick', "
"mesh_im mim, string expression[, int region[, int is_symmetric[, int "
"is_coercive]]])``"
msgstr ""

# 9178a6b50594422aa7731fb0b0f03b0d
#: ../source/scilab/cmdref_gf_model_set.rst:390
msgid "Deprecated. Use gf_model_set(model M, 'add linear term') instead."
msgstr ""

# 6ff1c1e064c14714acbb285cc24adca1
#: ../source/scilab/cmdref_gf_model_set.rst:393
msgid ""
"``ind = gf_model_set(model M, 'add nonlinear term', mesh_im mim, string "
"expression[, int region[, int is_symmetric[, int is_coercive]]])``"
msgstr ""

# 98a6bde985da40d7a3c965eb02b39d5a
#: ../source/scilab/cmdref_gf_model_set.rst:395
msgid ""
"Adds a nonlinear term given by the assembly string "
"<literal>expr</literal> which will be assembled in region "
"<literal>region</literal> and with the integration method "
"<literal>mim</literal>. The expression can describe a potential or a weak"
" form. Second order terms (i.e. containing second order test functions, "
"Test2) are not allowed. You can specify if the term is symmetric, "
"coercive or not. If you are not sure, the better is to declare the term "
"not symmetric and not coercive. But some solvers (conjugate gradient for "
"instance) are not allowed for non-coercive problems. "
"<literal>brickname</literal> is an otpional name for the brick."
msgstr ""

# 93a00c2e7b9348198ad064f5429eacea
#: ../source/scilab/cmdref_gf_model_set.rst:407
msgid ""
"``ind = gf_model_set(model M, 'add nonlinear generic assembly brick', "
"mesh_im mim, string expression[, int region[, int is_symmetric[, int "
"is_coercive]]])``"
msgstr ""

# c1060eb9e88c4892a1c0a1d586832344
#: ../source/scilab/cmdref_gf_model_set.rst:409
msgid "Deprecated. Use gf_model_set(model M, 'add nonlinear term') instead."
msgstr ""

# 547ac6b820ef41cb96e9cf6d9f78b1f3
#: ../source/scilab/cmdref_gf_model_set.rst:412
msgid ""
"``ind = gf_model_set(model M, 'add source term', mesh_im mim, string "
"expression[, int region])``"
msgstr ""

# c535aeccdbaf42419b947b45d4ad61af
#: ../source/scilab/cmdref_gf_model_set.rst:414
msgid ""
"Adds a source term given by the assembly string <literal>expr</literal> "
"which will be assembled in region <literal>region</literal> and with the "
"integration method <literal>mim</literal>. Only the residual term will be"
" taken into account. Take care that if the expression contains some "
"variables and if the expression is a potential, the expression will be "
"derivated with respect to all variables. <literal>brickname</literal> is "
"an optional name for the brick."
msgstr ""

# 0a161d34f4e041aa9499fe03fbce391d
#: ../source/scilab/cmdref_gf_model_set.rst:423
msgid ""
"``ind = gf_model_set(model M, 'add source term generic assembly brick', "
"mesh_im mim, string expression[, int region])``"
msgstr ""

# 0f195c3c27214d8eb841881fc674ea25
#: ../source/scilab/cmdref_gf_model_set.rst:425
msgid "Deprecated. Use gf_model_set(model M, 'add source term') instead."
msgstr ""

# 6158afa755d4486198264ed41db270b0
#: ../source/scilab/cmdref_gf_model_set.rst:428
msgid ""
"``gf_model_set(model M, 'add assembly assignment', string dataname, "
"string expression[, int region[, int order[, int before]]])``"
msgstr ""

# 4ad56018050d4851898b908b99e090b8
#: ../source/scilab/cmdref_gf_model_set.rst:430
msgid ""
"Adds expression <literal>expr</literal> to be evaluated at assembly time "
"and being assigned to the data <literal>dataname</literal> which has to "
"be of im_data type. This allows for instance to store a sub-expression of"
" an assembly computation to be used on an other assembly. It can be used "
"for instance to store the plastic strain in plasticity models. "
"<literal>order</literal> represents the order of assembly where this "
"assignement has to be done (potential(0), weak form(1) or tangent "
"system(2) or at each order(-1)). The default value is 1. If before = 1, "
"the the assignement is perfromed before the computation of the other "
"assembly terms, such that the data can be used in the remaining of the "
"assembly as an intermediary result (be careful that it is still "
"considered as a data, no derivation of the expression is performed for "
"the tangent system). If before = 0 (default), the assignement is done "
"after the assembly terms."
msgstr ""

# fada3a690a8d4a21b7d37e722c410b8a
#: ../source/scilab/cmdref_gf_model_set.rst:447
msgid "``gf_model_set(model M, 'clear assembly assignment')``"
msgstr ""

# d3baa5e47cb9448ab8a75f148867b545
#: ../source/scilab/cmdref_gf_model_set.rst:449
msgid "Delete all added assembly assignments"
msgstr ""

# 32126de9106c46438d548cf12eecbd06
#: ../source/scilab/cmdref_gf_model_set.rst:453
msgid ""
"``ind = gf_model_set(model M, 'add Laplacian brick', mesh_im mim, string "
"varname[, int region])``"
msgstr ""

# a25866a69f504798aac9154f010698fa
#: ../source/scilab/cmdref_gf_model_set.rst:455
msgid ""
"Add a Laplacian term to the model relatively to the variable "
"<literal>varname</literal> (in fact with a minus : <latex "
"style=\"text\"><![CDATA[-\\text{div}(\\nabla u)]]></latex>). If this is a"
" vector valued variable, the Laplacian term is added componentwise. "
"<literal>region</literal> is an optional mesh region on which the term is"
" added. If it is not specified, it is added on the whole mesh. Return the"
" brick index in the model."
msgstr ""

# 7d699b1b9c024a22a76a3aa2329de0ae
#: ../source/scilab/cmdref_gf_model_set.rst:463
msgid ""
"``ind = gf_model_set(model M, 'add generic elliptic brick', mesh_im mim, "
"string varname, string dataname[, int region])``"
msgstr ""

# f0e5bb70753444db8f12f0b86e5aa0ed
#: ../source/scilab/cmdref_gf_model_set.rst:465
msgid ""
"Add a generic elliptic term to the model relatively to the variable "
"<literal>varname</literal>. The shape of the elliptic term depends both "
"on the variable and the data. This corresponds to a term <latex "
"style=\"text\"><![CDATA[-\\text{div}(a\\nabla u)]]></latex> where <latex "
"style=\"text\"><![CDATA[a]]></latex> is the data and <latex "
"style=\"text\"><![CDATA[u]]></latex> the variable. The data can be a "
"scalar, a matrix or an order four tensor. The variable can be vector "
"valued or not. If the data is a scalar or a matrix and the variable is "
"vector valued then the term is added componentwise. An order four tensor "
"data is allowed for vector valued variable only. The data can be constant"
" or describbed on a fem. Of course, when the data is a tensor describe on"
" a finite element method (a tensor field) the data can be a huge vector. "
"The components of the matrix/tensor have to be stored with the fortran "
"order (columnwise) in the data vector (compatibility with blas). The "
"symmetry of the given matrix/tensor is not verified (but assumed). If "
"this is a vector valued variable, the elliptic term is added "
"componentwise. <literal>region</literal> is an optional mesh region on "
"which the term is added. If it is not specified, it is added on the whole"
" mesh. Note that for the real version which uses the high-level generic "
"assembly language, <literal>dataname</literal> can be any regular "
"expression of the high-level generic assembly language (like \"1\", "
"\"sin(X(1))\" or \"Norm(u)\" for instance) even depending on model "
"variables. Return the brick index in the model."
msgstr ""

# 553daafae1bc4beba53af96eee5c0675
#: ../source/scilab/cmdref_gf_model_set.rst:491
msgid ""
"``ind = gf_model_set(model M, 'add source term brick', mesh_im mim, "
"string varname, string dataexpr[, int region[, string directdataname]])``"
msgstr ""

# 5aa6d1d5307040c7bcaf9e85da4c641f
#: ../source/scilab/cmdref_gf_model_set.rst:493
msgid ""
"Add a source term to the model relatively to the variable "
"<literal>varname</literal>. The source term is represented by "
"<literal>dataexpr</literal> which could be any regular expression of the "
"high-level generic assembly language (except for the complex version "
"where it has to be a declared data of the model). "
"<literal>region</literal> is an optional mesh region on which the term is"
" added. An additional optional data <literal>directdataname</literal> can"
" be provided. The corresponding data vector will be directly added to the"
" right hand side without assembly. Note that when region is a boundary, "
"this brick allows to prescribe a nonzero Neumann boundary condition. "
"Return the brick index in the model."
msgstr ""

# 710540299d054aa9b92a56df957957b9
#: ../source/scilab/cmdref_gf_model_set.rst:506
msgid ""
"``ind = gf_model_set(model M, 'add normal source term brick', mesh_im "
"mim, string varname, string dataname, int region)``"
msgstr ""

# 3935d737b2124a9fb69d6e0de6a26be3
#: ../source/scilab/cmdref_gf_model_set.rst:508
msgid ""
"Add a source term on the variable <literal>varname</literal> on a "
"boundary <literal>region</literal>. This region should be a boundary. The"
" source term is represented by the data <literal>dataepxpr</literal> "
"which could be any regular expression of the high-level generic assembly "
"language (except for the complex version where it has to be a declared "
"data of the model). A scalar product with the outward normal unit vector "
"to the boundary is performed. The main aim of this brick is to represent "
"a Neumann condition with a vector data without performing the scalar "
"product with the normal as a pre-processing. Return the brick index in "
"the model."
msgstr ""

# 2e36b03d35c34af089ba955ce1a28f15
#: ../source/scilab/cmdref_gf_model_set.rst:520
msgid ""
"``ind = gf_model_set(model M, 'add Dirichlet condition with "
"simplification', string varname, int region[, string dataname])``"
msgstr ""

# 39e6787104eb490da5a87c0d98a83417
#: ../source/scilab/cmdref_gf_model_set.rst:522
msgid ""
"Adds a (simple) Dirichlet condition on the variable "
"<literal>varname</literal> and the mesh region <literal>region</literal>."
" The Dirichlet condition is prescribed by a simple post-treatment of the "
"final linear system (tangent system for nonlinear problems) consisting of"
" modifying the lines corresponding to the degree of freedom of the "
"variable on <literal>region</literal> (0 outside the diagonal, 1 on the "
"diagonal of the matrix and the expected value on the right hand side). "
"The symmetry of the linear system is kept if all other bricks are "
"symmetric. This brick is to be reserved for simple Dirichlet conditions "
"(only dof declared on the correspodning boundary are prescribed). The "
"application of this brick on reduced dof may be problematic. Intrinsic "
"vectorial finite element method are not supported. "
"<literal>dataname</literal> is the optional right hand side of  the "
"Dirichlet condition. It could be constant (but in that case, it can only "
"be applied to Lagrange f.e.m.) or (important) described on the same "
"finite element method as <literal>varname</literal>. Returns the brick "
"index in the model."
msgstr ""

# 88f61f9944fd4fdeab06d96920b5d5f5
#: ../source/scilab/cmdref_gf_model_set.rst:542
msgid ""
"``ind = gf_model_set(model M, 'add Dirichlet condition with multipliers',"
" mesh_im mim, string varname, mult_description, int region[, string "
"dataname])``"
msgstr ""

# 9cd29d5e546e43a38d539aa394e550b3
#: ../source/scilab/cmdref_gf_model_set.rst:544
msgid ""
"Add a Dirichlet condition on the variable <literal>varname</literal> and "
"the mesh region <literal>region</literal>. This region should be a "
"boundary. The Dirichlet condition is prescribed with a multiplier "
"variable described by <literal>mult_description</literal>. If "
"<literal>mult_description</literal> is a string this is assumed to be the"
" variable name corresponding to the multiplier (which should be first "
"declared as a multiplier variable on the mesh region in the model). If it"
" is a finite element method (mesh_fem object) then a multiplier variable "
"will be added to the model and build on this finite element method (it "
"will be restricted to the mesh region <literal>region</literal> and "
"eventually some conflicting dofs with some other multiplier variables "
"will be suppressed). If it is an integer, then a  multiplier variable "
"will be added to the model and build on a classical finite element of "
"degree that integer. <literal>dataname</literal> is the optional right "
"hand side of  the Dirichlet condition. It could be constant or described "
"on a fem; scalar or vector valued, depending on the variable on which the"
" Dirichlet condition is prescribed. Return the brick index in the model."
msgstr ""

# 35290ec9c56f40f09d629b142f714658
#: ../source/scilab/cmdref_gf_model_set.rst:562
msgid ""
"``ind = gf_model_set(model M, 'add Dirichlet condition with Nitsche "
"method', mesh_im mim, string varname, string Neumannterm, string "
"datagamma0, int region[, scalar theta][, string dataname])``"
msgstr ""

# a207641d149e449b88b073a5ad42dd3c
#: ../source/scilab/cmdref_gf_model_set.rst:564
msgid ""
"Add a Dirichlet condition on the variable <literal>varname</literal> and "
"the mesh region <literal>region</literal>. This region should be a "
"boundary. <literal>Neumannterm</literal> is the expression of the Neumann"
" term (obtained by the Green formula) described as an expression of the "
"high-level generic assembly language. This term can be obtained by "
"gf_model_get(model M, 'Neumann term', varname, region) once all volumic "
"bricks have been added to the model. The Dirichlet condition is "
"prescribed with Nitsche's method. <literal>datag</literal> is the "
"optional right hand side of the Dirichlet condition. "
"<literal>datagamma0</literal> is the Nitsche's method parameter. "
"<literal>theta</literal> is a scalar value which can be positive or "
"negative. <literal>theta = 1</literal> corresponds to the standard "
"symmetric method which is conditionnaly coercive for  "
"<literal>gamma0</literal> small. <literal>theta = -1</literal> "
"corresponds to the skew-symmetric method which is inconditionnaly "
"coercive. <literal>theta = 0</literal> (default) is the simplest method "
"for which the second derivative of the Neumann term is not necessary even"
" for nonlinear problems. Return the brick index in the model."
msgstr ""

# 49978eb5ea8a4eeeb013c8c5f8cab07e
#: ../source/scilab/cmdref_gf_model_set.rst:583
msgid ""
"``ind = gf_model_set(model M, 'add Dirichlet condition with "
"penalization', mesh_im mim, string varname, scalar coeff, int region[, "
"string dataname, mesh_fem mf_mult])``"
msgstr ""

# 8b55275a33b245f298ee1eb424b06b93
#: ../source/scilab/cmdref_gf_model_set.rst:585
msgid ""
"Add a Dirichlet condition on the variable <literal>varname</literal> and "
"the mesh region <literal>region</literal>. This region should be a "
"boundary. The Dirichlet condition is prescribed with penalization. The "
"penalization coefficient is initially <literal>coeff</literal> and will "
"be added to the data of the model. <literal>dataname</literal> is the "
"optional right hand side of the Dirichlet condition. It could be constant"
" or described on a fem; scalar or vector valued, depending on the "
"variable on which the Dirichlet condition is prescribed. "
"<literal>mf_mult</literal> is an optional parameter which allows to "
"weaken the Dirichlet condition specifying a multiplier space. Return the "
"brick index in the model."
msgstr ""

# 4614c7d649494c9fad58017effca6db9
#: ../source/scilab/cmdref_gf_model_set.rst:597
msgid ""
"``ind = gf_model_set(model M, 'add normal Dirichlet condition with "
"multipliers', mesh_im mim, string varname, mult_description, int region[,"
" string dataname])``"
msgstr ""

# d343a4b13eba4bfc90ec8edeb447b02b
#: ../source/scilab/cmdref_gf_model_set.rst:599
msgid ""
"Add a Dirichlet condition to the normal component of the vector (or "
"tensor) valued variable <literal>varname</literal> and the mesh region "
"<literal>region</literal>. This region should be a boundary. The "
"Dirichlet condition is prescribed with a multiplier variable described by"
" <literal>mult_description</literal>. If "
"<literal>mult_description</literal> is a string this is assumed to be the"
" variable name corresponding to the multiplier (which should be first "
"declared as a multiplier variable on the mesh region in the model). If it"
" is a finite element method (mesh_fem object) then a multiplier variable "
"will be added to the model and build on this finite element method (it "
"will be restricted to the mesh region <literal>region</literal> and "
"eventually some conflicting dofs with some other multiplier variables "
"will be suppressed). If it is an integer, then a  multiplier variable "
"will be added to the model and build on a classical finite element of "
"degree that integer. <literal>dataname</literal> is the optional right "
"hand side of  the Dirichlet condition. It could be constant or described "
"on a fem; scalar or vector valued, depending on the variable on which the"
" Dirichlet condition is prescribed (scalar if the variable is vector "
"valued, vector if the variable is tensor valued). Returns the brick index"
" in the model."
msgstr ""

# 817805bb9f584fae81b3825c1513c287
#: ../source/scilab/cmdref_gf_model_set.rst:620
msgid ""
"``ind = gf_model_set(model M, 'add normal Dirichlet condition with "
"penalization', mesh_im mim, string varname, scalar coeff, int region[, "
"string dataname, mesh_fem mf_mult])``"
msgstr ""

# 56adbf8a89c04275bf4b1f77746bd37d
#: ../source/scilab/cmdref_gf_model_set.rst:622
msgid ""
"Add a Dirichlet condition to the normal component of the vector (or "
"tensor) valued variable <literal>varname</literal> and the mesh region "
"<literal>region</literal>. This region should be a boundary. The "
"Dirichlet condition is prescribed with penalization. The penalization "
"coefficient is initially <literal>coeff</literal> and will be added to "
"the data of the model. <literal>dataname</literal> is the optional right "
"hand side of the Dirichlet condition. It could be constant or described "
"on a fem; scalar or vector valued, depending on the variable on which the"
" Dirichlet condition is prescribed (scalar if the variable is vector "
"valued, vector if the variable is tensor valued). "
"<literal>mf_mult</literal> is an optional parameter which allows to "
"weaken the Dirichlet condition specifying a multiplier space. Returns the"
" brick index in the model."
msgstr ""

# bbc91464dd28474c9b08cdd3845404b3
#: ../source/scilab/cmdref_gf_model_set.rst:637
msgid ""
"``ind = gf_model_set(model M, 'add normal Dirichlet condition with "
"Nitsche method', mesh_im mim, string varname, string Neumannterm, string "
"gamma0name, int region[, scalar theta][, string dataname])``"
msgstr ""

# abcf9e94657a4d819264e776178e5734
#: ../source/scilab/cmdref_gf_model_set.rst:639
msgid ""
"Add a Dirichlet condition to the normal component of the vector (or "
"tensor) valued variable <literal>varname</literal> and the mesh region "
"<literal>region</literal>. This region should be a boundary. "
"<literal>Neumannterm</literal> is the expression of the Neumann term "
"(obtained by the Green formula) described as an expression of the high-"
"level generic assembly language. This term can be obtained by "
"gf_model_get(model M, 'Neumann term', varname, region) once all volumic "
"bricks have been added to the model. The Dirichlet condition is "
"prescribed with Nitsche's method. <literal>dataname</literal> is the "
"optional right hand side of the Dirichlet condition. It could be constant"
" or described on a fem. <literal>gamma0name</literal> is the Nitsche's "
"method parameter. <literal>theta</literal> is a scalar value which can be"
" positive or negative. <literal>theta = 1</literal> corresponds to the "
"standard symmetric method which is conditionnaly coercive for  "
"<literal>gamma0</literal> small. <literal>theta = -1</literal> "
"corresponds to the skew-symmetric method which is inconditionnaly "
"coercive. <literal>theta = 0</literal> is the simplest method for which "
"the second derivative of the Neumann term is not necessary even for "
"nonlinear problems. Returns the brick index in the model. (This brick is "
"not fully tested)"
msgstr ""

# cdbb2c663d3c415ab8f48ae0f8f9b8ab
#: ../source/scilab/cmdref_gf_model_set.rst:662
msgid ""
"``ind = gf_model_set(model M, 'add generalized Dirichlet condition with "
"multipliers', mesh_im mim, string varname, mult_description, int region, "
"string dataname, string Hname)``"
msgstr ""

# 7cbb34ba3da54f87937789b8bd7ed528
#: ../source/scilab/cmdref_gf_model_set.rst:664
msgid ""
"Add a Dirichlet condition on the variable <literal>varname</literal> and "
"the mesh region <literal>region</literal>.  This version is for vector "
"field. It prescribes a condition <latex style=\"text\"><![CDATA[Hu = "
"r]]></latex> where <literal>H</literal> is a matrix field. The region "
"should be a boundary. The Dirichlet condition is prescribed with a "
"multiplier variable described by <literal>mult_description</literal>. If "
"<literal>mult_description</literal> is a string this is assumed to be the"
" variable name corresponding to the multiplier (which should be first "
"declared as a multiplier variable on the mesh region in the model). If it"
" is a finite element method (mesh_fem object) then a multiplier variable "
"will be added to the model and build on this finite element method (it "
"will be restricted to the mesh region <literal>region</literal> and "
"eventually some conflicting dofs with some other multiplier variables "
"will be suppressed). If it is an integer, then a  multiplier variable "
"will be added to the model and build on a classical finite element of "
"degree that integer. <literal>dataname</literal> is the right hand side "
"of  the Dirichlet condition. It could be constant or described on a fem; "
"scalar or vector valued, depending on the variable on which the Dirichlet"
" condition is prescribed. <literal>Hname</literal> is the data "
"corresponding to the matrix field <literal>H</literal>. Returns the brick"
" index in the model."
msgstr ""

# e91bee56c3ce484da40b50425bf7b9f4
#: ../source/scilab/cmdref_gf_model_set.rst:686
msgid ""
"``ind = gf_model_set(model M, 'add generalized Dirichlet condition with "
"penalization', mesh_im mim, string varname, scalar coeff, int region, "
"string dataname, string Hname[, mesh_fem mf_mult])``"
msgstr ""

# 7fdd8cae45504b1ebc00bb8d41d5c9e8
#: ../source/scilab/cmdref_gf_model_set.rst:688
msgid ""
"Add a Dirichlet condition on the variable <literal>varname</literal> and "
"the mesh region <literal>region</literal>. This version is for vector "
"field. It prescribes a condition <latex style=\"text\"><![CDATA[Hu = "
"r]]></latex> where <literal>H</literal> is a matrix field. The region "
"should be a boundary. The Dirichlet condition is prescribed with "
"penalization. The penalization coefficient is intially "
"<literal>coeff</literal> and will be added to the data of the model. "
"<literal>dataname</literal> is the right hand side of the Dirichlet "
"condition. It could be constant or described on a fem; scalar or vector "
"valued, depending on the variable on which the Dirichlet condition is "
"prescribed. <literal>Hname</literal> is the data corresponding to the "
"matrix field <literal>H</literal>. It has to be a constant matrix or "
"described on a scalar fem. <literal>mf_mult</literal> is an optional "
"parameter which allows to weaken the Dirichlet condition specifying a "
"multiplier space. Return the brick index in the model."
msgstr ""

# 3dc98f094c6646fa9787f86ad9fc5ba1
#: ../source/scilab/cmdref_gf_model_set.rst:706
msgid ""
"``ind = gf_model_set(model M, 'add generalized Dirichlet condition with "
"Nitsche method', mesh_im mim, string varname, string Neumannterm, string "
"gamma0name, int region[, scalar theta], string dataname, string Hname)``"
msgstr ""

# 6d2ebb8c75c4498695aa0de3f5bd1aa3
#: ../source/scilab/cmdref_gf_model_set.rst:708
msgid ""
"Add a Dirichlet condition on the variable <literal>varname</literal> and "
"the mesh region <literal>region</literal>. This version is for vector "
"field. It prescribes a condition @f$ Hu = r @f$ where "
"<literal>H</literal> is a matrix field. CAUTION : the matrix H should "
"have all eigenvalues equal to 1 or 0. The region should be a boundary.   "
"<literal>Neumannterm</literal> is the expression of the Neumann term "
"(obtained by the Green formula) described as an expression of the high-"
"level generic assembly language. This term can be obtained by "
"gf_model_get(model M, 'Neumann term', varname, region) once all volumic "
"bricks have been added to the model.  The Dirichlet condition is "
"prescribed with Nitsche's method. <literal>dataname</literal> is the "
"optional right hand side of the Dirichlet condition. It could be constant"
" or described on a fem. <literal>gamma0name</literal> is the Nitsche's "
"method parameter. <literal>theta</literal> is a scalar value which can be"
" positive or negative. <literal>theta = 1</literal> corresponds to the "
"standard symmetric method which is conditionnaly coercive for  "
"<literal>gamma0</literal> small. <literal>theta = -1</literal> "
"corresponds to the skew-symmetric method which is inconditionnaly "
"coercive. <literal>theta = 0</literal> is the simplest method for which "
"the second derivative of the Neumann term is not necessary even for "
"nonlinear problems. <literal>Hname</literal> is the data corresponding to"
" the matrix field <literal>H</literal>. It has to be a constant matrix or"
" described on a scalar fem. Returns the brick index in the model. (This "
"brick is not fully tested)"
msgstr ""

# ace163671be445109b33059be6af30f5
#: ../source/scilab/cmdref_gf_model_set.rst:735
msgid ""
"``ind = gf_model_set(model M, 'add pointwise constraints with "
"multipliers', string varname, string dataname_pt[, string dataname_unitv]"
" [, string dataname_val])``"
msgstr ""

# a60aa20fabb843a8898d051b8feb787e
#: ../source/scilab/cmdref_gf_model_set.rst:737
msgid ""
"Add some pointwise constraints on the variable <literal>varname</literal>"
" using multiplier. The multiplier variable is automatically added to the "
"model. The conditions are prescribed on a set of points given in the data"
" <literal>dataname_pt</literal> whose dimension is the number of points "
"times the dimension of the mesh. If the variable represents a vector "
"field, one has to give the data <literal>dataname_unitv</literal> which "
"represents a vector of dimension the number of points times the dimension"
" of the vector field which should store some unit vectors. In that case "
"the prescribed constraint is the scalar product of the variable at the "
"corresponding point with the corresponding unit vector. The optional data"
" <literal>dataname_val</literal> is the vector of values to be prescribed"
" at the different points. This brick is specifically designed to kill "
"rigid displacement in a Neumann problem. Returns the brick index in the "
"model."
msgstr ""

# e072e6fd5dda4770ac7347f38706a484
#: ../source/scilab/cmdref_gf_model_set.rst:755
msgid ""
"``ind = gf_model_set(model M, 'add pointwise constraints with given "
"multipliers', string varname, string multname, string dataname_pt[, "
"string dataname_unitv] [, string dataname_val])``"
msgstr ""

# 2ef70c2c612d434c835fd410f694d922
#: ../source/scilab/cmdref_gf_model_set.rst:757
msgid ""
"Add some pointwise constraints on the variable <literal>varname</literal>"
" using a given multiplier <literal>multname</literal>. The conditions are"
" prescribed on a set of points given in the data "
"<literal>dataname_pt</literal> whose dimension is the number of points "
"times the dimension of the mesh. The multiplier variable should be a "
"fixed size variable of size the number of points. If the variable "
"represents a vector field, one has to give the data "
"<literal>dataname_unitv</literal> which represents a vector of dimension "
"the number of points times the dimension of the vector field which should"
" store some unit vectors. In that case the prescribed constraint is the "
"scalar product of the variable at the corresponding point with the "
"corresponding unit vector. The optional data "
"<literal>dataname_val</literal> is the vector of values to be prescribed "
"at the different points. This brick is specifically designed to kill "
"rigid displacement in a Neumann problem. Returns the brick index in the "
"model."
msgstr ""

# 9755fa69634c41c3a5e673026a2d3fdb
#: ../source/scilab/cmdref_gf_model_set.rst:777
msgid ""
"``ind = gf_model_set(model M, 'add pointwise constraints with "
"penalization', string varname, scalar coeff, string dataname_pt[, string "
"dataname_unitv] [, string dataname_val])``"
msgstr ""

# c45ee54aec0f4cb9a0f5f522dca1e446
#: ../source/scilab/cmdref_gf_model_set.rst:779
msgid ""
"Add some pointwise constraints on the variable <literal>varname</literal>"
" thanks to a penalization. The penalization coefficient is initially "
"<literal>penalization_coeff</literal> and will be added to the data of "
"the model. The conditions are prescribed on a set of points given in the "
"data <literal>dataname_pt</literal> whose dimension is the number of "
"points times the dimension of the mesh. If the variable represents a "
"vector field, one has to give the data <literal>dataname_unitv</literal> "
"which represents a vector of dimension the number of points times the "
"dimension of the vector field which should store some unit vectors. In "
"that case the prescribed constraint is the scalar product of the variable"
" at the corresponding point with the corresponding unit vector. The "
"optional data <literal>dataname_val</literal> is the vector of values to "
"be prescribed at the different points. This brick is specifically "
"designed to kill rigid displacement in a Neumann problem. Returns the "
"brick index in the model."
msgstr ""

# 6e97ee763d034099abbbb2604648aea1
#: ../source/scilab/cmdref_gf_model_set.rst:798
msgid ""
"``gf_model_set(model M, 'change penalization coeff', int ind_brick, "
"scalar coeff)``"
msgstr ""

# e9572289129b40818f61fed8d84c947d
#: ../source/scilab/cmdref_gf_model_set.rst:800
msgid ""
"Change the penalization coefficient of a Dirichlet condition with "
"penalization brick. If the brick is not of this kind, this function has "
"an undefined behavior."
msgstr ""

# 375e68602a4a442488875b943866ffb2
#: ../source/scilab/cmdref_gf_model_set.rst:805
msgid ""
"``ind = gf_model_set(model M, 'add Helmholtz brick', mesh_im mim, string "
"varname, string dataexpr[, int region])``"
msgstr ""

# bceea7677da246d69d44e02a18abbc83
#: ../source/scilab/cmdref_gf_model_set.rst:807
msgid ""
"Add a Helmholtz term to the model relatively to the variable "
"<literal>varname</literal>. <literal>dataexpr</literal> is the wave "
"number. <literal>region</literal> is an optional mesh region on which the"
" term is added. If it is not specified, it is added on the whole mesh. "
"Return the brick index in the model."
msgstr ""

# 39a26983e9e84cb0b38b7aea418a65ab
#: ../source/scilab/cmdref_gf_model_set.rst:813
msgid ""
"``ind = gf_model_set(model M, 'add Fourier Robin brick', mesh_im mim, "
"string varname, string dataexpr, int region)``"
msgstr ""

# 21d8f05c2b834bb08237282b05f365a2
#: ../source/scilab/cmdref_gf_model_set.rst:815
msgid ""
"Add a Fourier-Robin term to the model relatively to the variable "
"<literal>varname</literal>. This corresponds to a weak term of the form "
"<latex style=\"text\"><![CDATA[\\int (qu).v]]></latex>. "
"<literal>dataexpr</literal> is the parameter <latex "
"style=\"text\"><![CDATA[q]]></latex> of the Fourier-Robin condition.  It "
"can be an arbitrary valid expression of the high-level generic assembly "
"language (except for the complex version for which it should be a data of"
" the model). <literal>region</literal> is the mesh region on which the "
"term is added. Return the brick index in the model."
msgstr ""

# 8890b7fc369c49818813445485f4ebe4
#: ../source/scilab/cmdref_gf_model_set.rst:824
msgid ""
"``ind = gf_model_set(model M, 'add constraint with multipliers', string "
"varname, string multname, spmat B, {vec L | string dataname})``"
msgstr ""

# 288d11a56be844b591900d17fca3cb96
#: ../source/scilab/cmdref_gf_model_set.rst:826
msgid ""
"Add an additional explicit constraint on the variable "
"<literal>varname</literal> thank to a multiplier "
"<literal>multname</literal> peviously added to the model (should be a "
"fixed size variable). The constraint is <latex "
"style=\"text\"><![CDATA[BU=L]]></latex> with <literal>B</literal> being a"
" rectangular sparse matrix. It is possible to change the constraint at "
"any time with the methods gf_model_set(model M, 'set private matrix') and"
" gf_model_set(model M, 'set private rhs'). If <literal>dataname</literal>"
" is specified instead of <literal>L</literal>, the vector "
"<literal>L</literal> is defined in the model as data with the given name."
" Return the brick index in the model."
msgstr ""

# a209784831b7476292f4408c026cb7be
#: ../source/scilab/cmdref_gf_model_set.rst:836
msgid ""
"``ind = gf_model_set(model M, 'add constraint with penalization', string "
"varname, scalar coeff, spmat B, {vec L | string dataname})``"
msgstr ""

# 30b362b5fadc438e8fb0edb8a58e0172
#: ../source/scilab/cmdref_gf_model_set.rst:838
msgid ""
"Add an additional explicit penalized constraint on the variable "
"<literal>varname</literal>. The constraint is "
":math<literal>BU=L</literal> with <literal>B</literal> being a "
"rectangular sparse matrix. Be aware that <literal>B</literal> should not "
"contain a palin row, otherwise the whole tangent matrix will be plain. It"
" is possible to change the constraint at any time with the methods "
"gf_model_set(model M, 'set private matrix') and gf_model_set(model M, "
"'set private rhs'). The method gf_model_set(model M, 'change penalization"
" coeff') can be used. If <literal>dataname</literal> is specified instead"
" of <literal>L</literal>, the vector <literal>L</literal> is defined in "
"the model as data with the given name. Return the brick index in the "
"model."
msgstr ""

# ad68784229374d809f343f0b261171bc
#: ../source/scilab/cmdref_gf_model_set.rst:851
msgid ""
"``ind = gf_model_set(model M, 'add explicit matrix', string varname1, "
"string varname2, spmat B[, int issymmetric[, int iscoercive]])``"
msgstr ""

# ea2d4336b94d4d7dac830a726f1748f5
#: ../source/scilab/cmdref_gf_model_set.rst:853
msgid ""
"Add a brick representing an explicit matrix to be added to the tangent "
"linear system relatively to the variables <literal>varname1</literal> and"
" <literal>varname2</literal>. The given matrix should have has many rows "
"as the dimension of <literal>varname1</literal> and as many columns as "
"the dimension of <literal>varname2</literal>. If the two variables are "
"different and if <literal>issymmetric</literal> is set to 1 then the "
"transpose of the matrix is also added to the tangent system (default is "
"0). Set <literal>iscoercive</literal> to 1 if the term does not affect "
"the coercivity of the tangent system (default is 0). The matrix can be "
"changed by the command gf_model_set(model M, 'set private matrix'). "
"Return the brick index in the model."
msgstr ""

# cf99242d7c6d4639857d85f2a5420949
#: ../source/scilab/cmdref_gf_model_set.rst:865
msgid "``ind = gf_model_set(model M, 'add explicit rhs', string varname, vec L)``"
msgstr ""

# fcd30a738f1c48aab24e526a50584af1
#: ../source/scilab/cmdref_gf_model_set.rst:867
msgid ""
"Add a brick representing an explicit right hand side to be added to the "
"right hand side of the tangent linear system relatively to the variable "
"<literal>varname</literal>. The given rhs should have the same size than "
"the dimension of <literal>varname</literal>. The rhs can be changed by "
"the command gf_model_set(model M, 'set private rhs'). If "
"<literal>dataname</literal> is specified instead of <literal>L</literal>,"
" the vector <literal>L</literal> is defined in the model as data with the"
" given name. Return the brick index in the model."
msgstr ""

# c8a3a2b85c7e4cd5891e72ec6a6d62df
#: ../source/scilab/cmdref_gf_model_set.rst:876
msgid "``gf_model_set(model M, 'set private matrix', int indbrick, spmat B)``"
msgstr ""

# 4a12a26ac8a842e5906f3b52ba9ed076
#: ../source/scilab/cmdref_gf_model_set.rst:878
msgid ""
"For some specific bricks having an internal sparse matrix (explicit "
"bricks: 'constraint brick' and 'explicit matrix brick'), set this matrix."
msgstr ""

# b231cc7a6e0f455ca285eaec97d1e83f
#: ../source/scilab/cmdref_gf_model_set.rst:883
msgid "``gf_model_set(model M, 'set private rhs', int indbrick, vec B)``"
msgstr ""

# 84ac51a23d5b4916b73cec0a029ae789
#: ../source/scilab/cmdref_gf_model_set.rst:885
msgid ""
"For some specific bricks having an internal right hand side vector "
"(explicit bricks: 'constraint brick' and 'explicit rhs brick'), set this "
"rhs."
msgstr ""

# 152f41b599424a5fae523e3294415521
#: ../source/scilab/cmdref_gf_model_set.rst:890
msgid ""
"``ind = gf_model_set(model M, 'add isotropic linearized elasticity "
"brick', mesh_im mim, string varname, string dataname_lambda, string "
"dataname_mu[, int region])``"
msgstr ""

# 01647db6fba649349b602480360dfba1
#: ../source/scilab/cmdref_gf_model_set.rst:892
msgid ""
"Add an isotropic linearized elasticity term to the model relatively to "
"the variable <literal>varname</literal>. "
"<literal>dataname_lambda</literal> and <literal>dataname_mu</literal> "
"should contain the Lame coefficients. <literal>region</literal> is an "
"optional mesh region on which the term is added. If it is not specified, "
"it is added on the whole mesh. Return the brick index in the model."
msgstr ""

# 22c275a21a7e4e7184deb144c0e14aba
#: ../source/scilab/cmdref_gf_model_set.rst:899
msgid ""
"``ind = gf_model_set(model M, 'add isotropic linearized elasticity brick "
"pstrain', mesh_im mim, string varname, string data_E, string data_nu[, "
"int region])``"
msgstr ""

# 22cfeec3b02c4cd692c0c732570c2fb3
#: ../source/scilab/cmdref_gf_model_set.rst:901
msgid ""
"Add an isotropic linearized elasticity term to the model relatively to "
"the variable <literal>varname</literal>. <literal>data_E</literal> and "
"<literal>data_nu</literal> should contain the Young modulus and Poisson "
"ratio, respectively. <literal>region</literal> is an optional mesh region"
" on which the term is added. If it is not specified, it is added on the "
"whole mesh. On two-dimensional meshes, the term will correpsond to a "
"plain strain approximation. On three-dimensional meshes, it will "
"correspond to the standard model. Return the brick index in the model."
msgstr ""

# 0c56fd1524934e4283420ae682905f62
#: ../source/scilab/cmdref_gf_model_set.rst:913
msgid ""
"``ind = gf_model_set(model M, 'add isotropic linearized elasticity brick "
"pstress', mesh_im mim, string varname, string data_E, string data_nu[, "
"int region])``"
msgstr ""

# 4571dc3f90a94061883ec63f13944456
#: ../source/scilab/cmdref_gf_model_set.rst:915
msgid ""
"Add an isotropic linearized elasticity term to the model relatively to "
"the variable <literal>varname</literal>. <literal>data_E</literal> and "
"<literal>data_nu</literal> should contain the Young modulus and Poisson "
"ratio, respectively. <literal>region</literal> is an optional mesh region"
" on which the term is added. If it is not specified, it is added on the "
"whole mesh. On two-dimensional meshes, the term will correpsond to a "
"plain stress approximation. On three-dimensional meshes, it will "
"correspond to the standard model. Return the brick index in the model."
msgstr ""

# cc83fe22fad047b4b86feee674c88eb5
#: ../source/scilab/cmdref_gf_model_set.rst:927
msgid ""
"``ind = gf_model_set(model M, 'add linear incompressibility brick', "
"mesh_im mim, string varname, string multname_pressure[, int region[, "
"string dataexpr_coeff]])``"
msgstr ""

# cb34596a259d47738402d4eeb5eda35c
#: ../source/scilab/cmdref_gf_model_set.rst:929
msgid ""
"Add a linear incompressibility condition on <literal>variable</literal>. "
"<literal>multname_pressure</literal> is a variable which represent the "
"pressure. Be aware that an inf-sup condition between the finite element "
"method describing the pressure and the primal variable has to be "
"satisfied. <literal>region</literal> is an optional mesh region on which "
"the term is added. If it is not specified, it is added on the whole mesh."
" <literal>dataexpr_coeff</literal> is an optional penalization "
"coefficient for nearly incompressible elasticity for instance. In this "
"case, it is the inverse of the Lame coefficient <latex "
"style=\"text\"><![CDATA[\\lambda]]></latex>. Return the brick index in "
"the model."
msgstr ""

# 8c62972045584c16b0c831bd38eef70d
#: ../source/scilab/cmdref_gf_model_set.rst:940
msgid ""
"``ind = gf_model_set(model M, 'add nonlinear elasticity brick', mesh_im "
"mim, string varname, string constitutive_law, string dataname[, int "
"region])``"
msgstr ""

# 168ea091727546779fbd1a8e4258f5ac
#: ../source/scilab/cmdref_gf_model_set.rst:942
msgid ""
"Add a nonlinear elasticity term to the model relatively to the variable "
"<literal>varname</literal> (deprecated brick, use "
"add_finite_strain_elaticity instead). <literal>lawname</literal> is the "
"constitutive law which could be 'SaintVenant Kirchhoff', 'Mooney Rivlin',"
" 'neo Hookean', 'Ciarlet Geymonat' or 'generalized Blatz Ko'. 'Mooney "
"Rivlin' and 'neo Hookean' law names can be preceded with the word "
"'compressible' or 'incompressible' to force using the corresponding "
"version. The compressible version of these laws requires one additional "
"material coefficient. By default, the incompressible version of 'Mooney "
"Rivlin' law and the compressible one of the 'neo Hookean' law are "
"considered. In general, 'neo Hookean' is a special case of the 'Mooney "
"Rivlin' law that requires one coefficient less. IMPORTANT : if the "
"variable is defined on a 2D mesh, the plane strain approximation is "
"automatically used. <literal>dataname</literal> is a vector of parameters"
" for the constitutive law. Its length depends on the law. It could be a "
"short vector of constant values or a vector field described on a finite "
"element method for variable coefficients. <literal>region</literal> is an"
" optional mesh region on which the term is added. If it is not specified,"
" it is added on the whole mesh. This brick use the low-level generic "
"assembly. Returns the brick index in the model."
msgstr ""

# 2111aeda39b248b98f858b76c5706caa
#: ../source/scilab/cmdref_gf_model_set.rst:965
msgid ""
"``ind = gf_model_set(model M, 'add finite strain elasticity brick', "
"mesh_im mim, string constitutive_law, string varname, string params[, int"
" region])``"
msgstr ""

# 9a772deaa39e418bbbe62edd37b862e0
#: ../source/scilab/cmdref_gf_model_set.rst:967
msgid ""
"Add a nonlinear elasticity term to the model relatively to the variable "
"<literal>varname</literal>. <literal>lawname</literal> is the "
"constitutive law which could be 'SaintVenant Kirchhoff', 'Mooney Rivlin',"
" 'Neo Hookean', 'Ciarlet Geymonat' or 'Generalized Blatz Ko'. 'Mooney "
"Rivlin' and 'Neo Hookean' law names have to be preceeded with the word "
"'Compressible' or 'Incompressible' to force using the corresponding "
"version. The compressible version of these laws requires one additional "
"material coefficient."
msgstr ""

# de3679d8aad4431fabd12c0798cc0ce1
#: ../source/scilab/cmdref_gf_model_set.rst:977
msgid ""
"IMPORTANT : if the variable is defined on a 2D mesh, the plane strain "
"approximation is automatically used. <literal>params</literal> is a "
"vector of parameters for the constitutive law. Its length depends on the "
"law. It could be a short vector of constant values or a vector field "
"described on a finite element method for variable coefficients. "
"<literal>region</literal> is an optional mesh region on which the term is"
" added. If it is not specified, it is added on the whole mesh. This brick"
" use the high-level generic assembly. Returns the brick index in the "
"model."
msgstr ""

# 3de07302e51c462e8dbbf08f804e0cbc
#: ../source/scilab/cmdref_gf_model_set.rst:988
msgid ""
"``ind = gf_model_set(model M, 'add small strain elastoplasticity brick', "
"mesh_im mim,  string lawname, string unknowns_type [, string varnames, "
"...] [, string params, ...] [, string theta = '1' [, string dt = "
"'timestep']] [, int region = -1])``"
msgstr ""

# 57368e2fd51e4984b95cba65527453d5
#: ../source/scilab/cmdref_gf_model_set.rst:990
msgid ""
"Adds a small strain plasticity term to the model <literal>M</literal>. "
"This is the main GetFEM++ brick for small strain plasticity. "
"<literal>lawname</literal> is the name of an implemented plastic law, "
"<literal>unknowns_type</literal> indicates the choice between a "
"discretization where the plastic multiplier is an unknown of the problem "
"or (return mapping approach) just a data of the model stored for the next"
" iteration. Remember that in both cases, a multiplier is stored anyway. "
"<literal>varnames</literal> is a set of variable and data names with "
"length which may depend on the plastic law (at least the displacement, "
"the plastic multiplier and the plastic strain). <literal>params</literal>"
" is a list of expressions for the parameters (at least elastic "
"coefficients and the yield stress). These expressions can be some data "
"names (or even variable names) of the model but can also be any scalar "
"valid expression of the high level assembly language (such as '1/2', "
"'2+sin(X[0])', '1+Norm(v)' ...). The last two parameters optionally "
"provided in <literal>params</literal> are the <literal>theta</literal> "
"parameter of the <literal>theta</literal>-scheme (generalized trapezoidal"
" rule) used for the plastic strain integration and the time-"
"step<literal>dt</literal>. The default value for <literal>theta</literal>"
" if omitted is 1, which corresponds to the classical Backward Euler "
"scheme which is first order consistent. <literal>theta=1/2</literal> "
"corresponds to the Crank-Nicolson scheme (trapezoidal rule) which is "
"second order consistent. Any value between 1/2 and 1 should be a valid "
"value. The default value of <literal>dt</literal> is 'timestep' which "
"simply indicates the time step defined in the model (by "
"md.set_time_step(dt)). Alternatively it can be any expression (data name,"
" constant value ...). The time step can be altered from one iteration to "
"the next one. <literal>region</literal> is a mesh region."
msgstr ""

# cec148ce98734322a70b6cc2c350f321
#: ../source/scilab/cmdref_gf_model_set.rst:1016
msgid "The available plasticity laws are:"
msgstr ""

# c36d9e9c8354401bbab58efc925ab7fb
#: ../source/scilab/cmdref_gf_model_set.rst:1018
msgid ""
"'Prandtl Reuss' (or 'isotropic perfect plasticity'). Isotropic elasto-"
"plasticity with no hardening. The variables are the displacement, the "
"plastic multiplier and the plastic strain. The displacement should be a "
"variable and have a corresponding data having the same name preceded by "
"'Previous\\_' corresponding to the displacement at the previous time step"
" (typically 'u' and 'Previous_u'). The plastic multiplier should also "
"have two versions (typically 'xi' and 'Previous_xi') the first one being "
"defined as data if <literal>unknowns_type </literal> is "
"'DISPLACEMENT_ONLY' or the integer value 0, or as a variable if "
"<literal>unknowns_type</literal> is DISPLACEMENT_AND_PLASTIC_MULTIPLIER "
"or the integer value 1. The plastic strain should represent a n x n data "
"tensor field stored on mesh_fem or (preferably) on an im_data "
"(corresponding to <literal>mim</literal>). The data are the first Lame "
"coefficient, the second one (shear modulus) and the uniaxial yield "
"stress. A typical call is gf_model_get(model M, 'add small strain "
"elastoplasticity brick', mim, 'Prandtl Reuss', 0, 'u', 'xi', "
"'Previous_Ep', 'lambda', 'mu', 'sigma_y', '1', 'timestep'); IMPORTANT: "
"Note that this law implements the 3D expressions. If it is used in 2D, "
"the expressions are just transposed to the 2D. For the plane strain "
"approximation, see below."
msgstr ""

# 658639978db74c51bf428bd654d48473
#: ../source/scilab/cmdref_gf_model_set.rst:1037
msgid ""
"\"plane strain Prandtl Reuss\" (or \"plane strain isotropic perfect "
"plasticity\") The same law as the previous one but adapted to the plane "
"strain approximation. Can only be used in 2D."
msgstr ""

# 6a97fffae7da47bc8bd676bbcfcd7b7c
#: ../source/scilab/cmdref_gf_model_set.rst:1041
msgid ""
"\"Prandtl Reuss linear hardening\" (or \"isotropic plasticity linear "
"hardening\"). Isotropic elasto-plasticity with linear isotropic and "
"kinematic hardening. An additional variable compared to \"Prandtl Reuss\""
" law: the accumulated plastic strain. Similarly to the plastic strain, it"
" is only stored at the end of the time step, so a simple data is required"
" (preferably on an im_data). Two additional parameters: the kinematic "
"hardening modulus and the isotropic one. 3D expressions only. A typical "
"call is gf_model_get(model M, 'add small strain elastoplasticity brick', "
"mim, 'Prandtl Reuss linear hardening', 0, 'u', 'xi', 'Previous_Ep', "
"'Previous_alpha', 'lambda', 'mu', 'sigma_y', 'H_k', H_i', '1', "
"'timestep');"
msgstr ""

# 3ce33c259938434181648f3c155f4a91
#: ../source/scilab/cmdref_gf_model_set.rst:1051
msgid ""
"\"plane strain Prandtl Reuss linear hardening\" (or \"plane strain "
"isotropic plasticity linear hardening\"). The same law as the previous "
"one but adapted to the plane strain approximation. Can only be used in "
"2D."
msgstr ""

# 170df35a39b54b449248fe8db8fb60c0
#: ../source/scilab/cmdref_gf_model_set.rst:1056
msgid ""
"See GetFEM++ user documentation for further explanations on the "
"discretization of the plastic flow and on the implemented plastic laws. "
"See also GetFEM++ user documentation on time integration strategy "
"(integration of transient problems)."
msgstr ""

# f60b561e5de04c3db762a6464bef8ff9
#: ../source/scilab/cmdref_gf_model_set.rst:1061
msgid ""
"IMPORTANT : remember that "
"<literal>small_strain_elastoplasticity_next_iter</literal> has to be "
"called at the end of each time step, before the next one (and before any "
"post-treatment : this sets the value of the plastic strain and plastic "
"multiplier)."
msgstr ""

# f009a392d7ea4dde960ed5ad19bd7b0b
#: ../source/scilab/cmdref_gf_model_set.rst:1068
msgid ""
"``ind = gf_model_set(model M, 'add elastoplasticity brick', mesh_im mim "
",string projname, string varname, string previous_dep_name, string "
"datalambda, string datamu, string datathreshold, string datasigma[, int "
"region])``"
msgstr ""

# a299572328164a3085d35ce306ff32e1
#: ../source/scilab/cmdref_gf_model_set.rst:1070
msgid ""
"Old (obsolete) brick which do not use the high level generic assembly. "
"Add a nonlinear elastoplastic term to the model relatively to the "
"variable <literal>varname</literal>, in small deformations, for an "
"isotropic material and for a quasistatic model. "
"<literal>projname</literal> is the type of projection that used: only the"
" Von Mises projection is available with 'VM' or 'Von Mises'. "
"<literal>datasigma</literal> is the variable representing the constraints"
" on the material. <literal>previous_dep_name</literal> represents the "
"displacement at the previous time step. Moreover, the finite element "
"method on which <literal>varname</literal> is described is an K ordered "
"mesh_fem, the <literal>datasigma</literal> one have to be at least an K-1"
" ordered mesh_fem. <literal>datalambda</literal> and "
"<literal>datamu</literal> are the Lame coefficients of the studied "
"material. <literal>datathreshold</literal> is the plasticity threshold of"
" the material. The three last variables could be constants or described "
"on the same finite element method. <literal>region</literal> is an "
"optional mesh region on which the term is added. If it is not specified, "
"it is added on the whole mesh. Return the brick index in the model."
msgstr ""

# 75f479fda1db4ef5b39a753a6a71e843
#: ../source/scilab/cmdref_gf_model_set.rst:1091
msgid ""
"``ind = gf_model_set(model M, 'add finite strain elastoplasticity brick',"
" mesh_im mim , string lawname, string unknowns_type [, string varnames, "
"...] [, string params, ...] [, int region = -1])``"
msgstr ""

# c8ea918468ac438297bd8641be274f6d
#: ../source/scilab/cmdref_gf_model_set.rst:1093
msgid ""
"Add a finite strain elastoplasticity brick to the model. For the moment "
"there is only one supported law defined through "
"<literal>lawname</literal> as \"Simo_Miehe\". This law supports to "
"possibilities of unknown variables to solve for defined by means of "
"<literal>unknowns_type</literal> set to either "
"'DISPLACEMENT_AND_PLASTIC_MULTIPLIER' (integer value 1) or "
"'DISPLACEMENT_AND_PLASTIC_MULTIPLIER_AND_PRESSURE' (integer value 3). The"
"  \"Simo_Miehe\" law expects as <literal>varnames</literal> a set of the "
"following names that have to be defined as variables in the model:"
msgstr ""

# 05aca19b546f41409d588c9b70c0c9fb
#: ../source/scilab/cmdref_gf_model_set.rst:1103
msgid "the displacement variable which has to be defined as an unknown,"
msgstr ""

# c90fa914805b46b88b9908f102f504c6
#: ../source/scilab/cmdref_gf_model_set.rst:1104
msgid "the plastic multiplier which has also defined as an unknown,"
msgstr ""

# 27918dc3b21c4f1bae40c6666e680f98
#: ../source/scilab/cmdref_gf_model_set.rst:1105
msgid ""
"optionally the pressure variable for a mixed displacement-pressure "
"formulation for 'DISPLACEMENT_AND_PLASTIC_MULTIPLIER_AND_PRESSURE' as "
"<literal>unknowns_type</literal>,"
msgstr ""

# 0f39c1eefe4f438d978970138e932e10
#: ../source/scilab/cmdref_gf_model_set.rst:1108
msgid ""
"the name of a (scalar) fem_data or im_data field that holds the plastic "
"strain at the previous time step, and"
msgstr ""

# 86b366b73196459d80b674e8bfb88d2d
#: ../source/scilab/cmdref_gf_model_set.rst:1110
msgid ""
"the name of a fem_data or im_data field that holds all non-repeated "
"components of the inverse of the plastic right Cauchy-Green tensor at the"
" previous time step (it has to be a 4 element vector for plane strain 2D "
"problems and a 6 element vector for 3D problems)."
msgstr ""

# aef09faad1ff4df1ac568550b8b9d4fe
#: ../source/scilab/cmdref_gf_model_set.rst:1116
msgid ""
"The  \"Simo_Miehe\" law also expects as <literal>params</literal> a set "
"of the following three parameters:"
msgstr ""

# 96d570b758214be08ae9c37b56cd5755
#: ../source/scilab/cmdref_gf_model_set.rst:1119
msgid "an expression for the initial bulk modulus K,"
msgstr ""

# ee9028433c624feb83e01c1e180a21b1
#: ../source/scilab/cmdref_gf_model_set.rst:1120
msgid "an expression for the initial shear modulus G,"
msgstr ""

# a6f85a4e90e14bf89b46efbc30b73f73
#: ../source/scilab/cmdref_gf_model_set.rst:1121
msgid ""
"the name of a user predefined function that decribes the yield limit as a"
" function of the hardening variable (both the yield limit and the "
"hardening variable values are assumed to be Frobenius norms of "
"appropriate stress and strain tensors, respectively)."
msgstr ""

# 237b93c15e2045169cfe102039848abb
#: ../source/scilab/cmdref_gf_model_set.rst:1127
msgid ""
"As usual, <literal>region</literal> is an optional mesh region on which "
"the term is added. If it is not specified, it is added on the whole mesh."
" Return the brick index in the model."
msgstr ""

# 1b357e3105bd4e13b8f63f2bc321e91e
#: ../source/scilab/cmdref_gf_model_set.rst:1132
msgid ""
"``ind = gf_model_set(model M, 'add nonlinear incompressibility brick', "
"mesh_im mim, string varname, string multname_pressure[, int region])``"
msgstr ""

# 4a05ca5d33fe490b93fad6f38e0f00d5
#: ../source/scilab/cmdref_gf_model_set.rst:1134
msgid ""
"Add a nonlinear incompressibility condition on "
"<literal>variable</literal> (for large strain elasticity). "
"<literal>multname_pressure</literal> is a variable which represent the "
"pressure. Be aware that an inf-sup condition between the finite element "
"method describing the pressure and the primal variable has to be "
"satisfied. <literal>region</literal> is an optional mesh region on which "
"the term is added. If it is not specified, it is added on the whole mesh."
" Return the brick index in the model."
msgstr ""

# 6d3ed85bd4ee416096a65f5d4849afab
#: ../source/scilab/cmdref_gf_model_set.rst:1143
msgid ""
"``ind = gf_model_set(model M, 'add finite strain incompressibility "
"brick', mesh_im mim, string varname, string multname_pressure[, int "
"region])``"
msgstr ""

# 784cf46e28af45fcb74ca2a98d9824d6
#: ../source/scilab/cmdref_gf_model_set.rst:1145
msgid ""
"Add a finite strain incompressibility condition on "
"<literal>variable</literal> (for large strain elasticity). "
"<literal>multname_pressure</literal> is a variable which represent the "
"pressure. Be aware that an inf-sup condition between the finite element "
"method describing the pressure and the primal variable has to be "
"satisfied. <literal>region</literal> is an optional mesh region on which "
"the term is added. If it is not specified, it is added on the whole mesh."
" Return the brick index in the model. This brick is equivalent to the "
"<literal></literal>nonlinear incompressibility brick<literal></literal> "
"but uses the high-level generic assembly adding the term "
"<literal></literal>p*(1-Det(Id(meshdim)+Grad_u))<literal></literal> if "
"<literal></literal>p<literal></literal> is the multiplier and "
"<literal></literal>u<literal></literal> the variable which represent the "
"displacement."
msgstr ""

# 0a650bd5350f4c679d5ff7429abbd3d4
#: ../source/scilab/cmdref_gf_model_set.rst:1158
msgid ""
"``ind = gf_model_set(model M, 'add bilaplacian brick', mesh_im mim, "
"string varname, string dataname [, int region])``"
msgstr ""

# bc62b24a9b1e42419faa378a2cead8c0
#: ../source/scilab/cmdref_gf_model_set.rst:1160
msgid ""
"Add a bilaplacian brick on the variable <literal>varname</literal> and on"
" the mesh region <literal>region</literal>. This represent a term <latex "
"style=\"text\"><![CDATA[\\Delta(D \\Delta u)]]></latex>. where <latex "
"style=\"text\"><![CDATA[D(x)]]></latex> is a coefficient determined by "
"<literal>dataname</literal> which could be constant or described on a "
"f.e.m. The corresponding weak form is <latex "
"style=\"text\"><![CDATA[\\int D(x)\\Delta u(x) \\Delta v(x) "
"dx]]></latex>. Return the brick index in the model."
msgstr ""

# 42d9ef341e94449498fdf6981ab44fc5
#: ../source/scilab/cmdref_gf_model_set.rst:1169
msgid ""
"``ind = gf_model_set(model M, 'add Kirchhoff-Love plate brick', mesh_im "
"mim, string varname, string dataname_D, string dataname_nu [, int "
"region])``"
msgstr ""

# 927d5640b71f42c192fc4d0c8d68a2bd
#: ../source/scilab/cmdref_gf_model_set.rst:1171
msgid ""
"Add a bilaplacian brick on the variable <literal>varname</literal> and on"
" the mesh region <literal>region</literal>. This represent a term <latex "
"style=\"text\"><![CDATA[\\Delta(D \\Delta u)]]></latex> where <latex "
"style=\"text\"><![CDATA[D(x)]]></latex> is a the flexion modulus "
"determined by <literal>dataname_D</literal>. The term is integrated by "
"part following a Kirchhoff-Love plate model with "
"<literal>dataname_nu</literal> the poisson ratio. Return the brick index "
"in the model."
msgstr ""

# b06418b200154f3e9d4844d5979f1d3d
#: ../source/scilab/cmdref_gf_model_set.rst:1180
msgid ""
"``ind = gf_model_set(model M, 'add normal derivative source term brick', "
"mesh_im mim, string varname, string dataname, int region)``"
msgstr ""

# f3552adf19de41dd828a30211929382d
#: ../source/scilab/cmdref_gf_model_set.rst:1182
msgid ""
"Add a normal derivative source term brick <latex "
"style=\"text\"><![CDATA[F = \\int b.\\partial_n v]]></latex> on the "
"variable <literal>varname</literal> and the mesh region "
"<literal>region</literal>."
msgstr ""

# b298b346b6024c97970c3997c48ed94e
#: ../source/scilab/cmdref_gf_model_set.rst:1186
msgid ""
"Update the right hand side of the linear system. "
"<literal>dataname</literal> represents <literal>b</literal> and "
"<literal>varname</literal> represents <literal>v</literal>. Return the "
"brick index in the model."
msgstr ""

# 6f7c708f423a45ae95baca0c6914e7a0
#: ../source/scilab/cmdref_gf_model_set.rst:1191
msgid ""
"``ind = gf_model_set(model M, 'add Kirchhoff-Love Neumann term brick', "
"mesh_im mim, string varname, string dataname_M, string dataname_divM, int"
" region)``"
msgstr ""

# 3935864a86c8451b983207223eae0e59
#: ../source/scilab/cmdref_gf_model_set.rst:1193
msgid ""
"Add a Neumann term brick for Kirchhoff-Love model on the variable "
"<literal>varname</literal> and the mesh region <literal>region</literal>."
" <literal>dataname_M</literal> represents the bending moment tensor and  "
"<literal>dataname_divM</literal> its divergence. Return the brick index "
"in the model."
msgstr ""

# 323533b5bcc444ab81588fe69c9cda2d
#: ../source/scilab/cmdref_gf_model_set.rst:1200
msgid ""
"``ind = gf_model_set(model M, 'add normal derivative Dirichlet condition "
"with multipliers', mesh_im mim, string varname, mult_description, int "
"region [, string dataname, int R_must_be_derivated])``"
msgstr ""

# b62054c06c80494c99c99e688062a766
#: ../source/scilab/cmdref_gf_model_set.rst:1202
msgid ""
"Add a Dirichlet condition on the normal derivative of the variable "
"<literal>varname</literal> and on the mesh region "
"<literal>region</literal> (which should be a boundary. The general form "
"is <latex style=\"text\"><![CDATA[\\int \\partial_n u(x)v(x) = \\int "
"r(x)v(x) \\forall v]]></latex> where <latex "
"style=\"text\"><![CDATA[r(x)]]></latex> is the right hand side for the "
"Dirichlet condition (0 for homogeneous conditions) and <latex "
"style=\"text\"><![CDATA[v]]></latex> is in a space of multipliers defined"
" by <literal>mult_description</literal>. If "
"<literal>mult_description</literal> is a string this is assumed to be the"
" variable name corresponding to the multiplier (which should be first "
"declared as a multiplier variable on the mesh region in the model). If it"
" is a finite element method (mesh_fem object) then a multiplier variable "
"will be added to the model and build on this finite element method (it "
"will be restricted to the mesh region <literal>region</literal> and "
"eventually some conflicting dofs with some other multiplier variables "
"will be suppressed). If it is an integer, then a  multiplier variable "
"will be added to the model and build on a classical finite element of "
"degree that integer. <literal>dataname</literal> is an optional parameter"
" which represents the right hand side of the Dirichlet condition. If "
"<literal>R_must_be_derivated</literal> is set to <literal>true</literal> "
"then the normal derivative of <literal>dataname</literal> is considered. "
"Return the brick index in the model."
msgstr ""

# 04d20ee64b5e4d50a5764e8bd8fc4c75
#: ../source/scilab/cmdref_gf_model_set.rst:1226
msgid ""
"``ind = gf_model_set(model M, 'add normal derivative Dirichlet condition "
"with penalization', mesh_im mim, string varname, scalar coeff, int region"
" [, string dataname, int R_must_be_derivated])``"
msgstr ""

# 487af4127afa45659c5d6135665f5416
#: ../source/scilab/cmdref_gf_model_set.rst:1228
msgid ""
"Add a Dirichlet condition on the normal derivative of the variable "
"<literal>varname</literal> and on the mesh region "
"<literal>region</literal> (which should be a boundary. The general form "
"is <latex style=\"text\"><![CDATA[\\int \\partial_n u(x)v(x) = \\int "
"r(x)v(x) \\forall v]]></latex> where <latex "
"style=\"text\"><![CDATA[r(x)]]></latex> is the right hand side for the "
"Dirichlet condition (0 for homogeneous conditions). The penalization "
"coefficient is initially <literal>coeff</literal> and will be added to "
"the data of the model. It can be changed with the command "
"gf_model_set(model M, 'change penalization coeff'). "
"<literal>dataname</literal> is an optional parameter which represents the"
" right hand side of the Dirichlet condition. If "
"<literal>R_must_be_derivated</literal> is set to <literal>true</literal> "
"then the normal derivative of <literal>dataname</literal> is considered. "
"Return the brick index in the model."
msgstr ""

# 2d178250832241019afb831dab22c075
#: ../source/scilab/cmdref_gf_model_set.rst:1245
msgid ""
"``ind = gf_model_set(model M, 'add Mindlin Reissner plate brick', mesh_im"
" mim, mesh_im mim_reduced, string varname_u3, string varname_theta , "
"string param_E, string param_nu, string param_epsilon, string param_kappa"
" [,int variant [, int region]])``"
msgstr ""

# 671033aad6d445f4ad86d3891110f03e
#: ../source/scilab/cmdref_gf_model_set.rst:1247
msgid ""
"Add a term corresponding to the classical Reissner-Mindlin plate model "
"for which <literal>varname_u3</literal> is the transverse displacement, "
"<literal>varname_theta</literal> the rotation of fibers normal to the "
"midplane, 'param_E' the Young Modulus, <literal>param_nu</literal> the "
"poisson ratio, <literal>param_epsilon</literal> the plate thickness, "
"<literal>param_kappa</literal> the shear correction factor. Note that "
"since this brick uses the high level generic assembly language, the "
"parameter can be regular expression of this language. There are three "
"variants. <literal>variant = 0</literal> corresponds to the an unreduced "
"formulation and in that case only the integration method "
"<literal>mim</literal> is used. Practically this variant is not usable "
"since it is subject to a strong locking phenomenon. <literal>variant = "
"1</literal> corresponds to a reduced integration where "
"<literal>mim</literal> is used for the rotation term and "
"<literal>mim_reduced</literal> for the transverse shear term. "
"<literal>variant = 2</literal> (default) corresponds to the projection "
"onto a rotated RT0 element of the transverse shear term. For the moment, "
"this is adapted to quadrilateral only (because it is not sufficient to "
"remove the locking phenomenon on triangle elements). Note also that if "
"you use high order elements, the projection on RT0 will reduce the order "
"of the approximation. Returns the brick index in the model."
msgstr ""

# 86b8fb20407a426bb952ebc12d741997
#: ../source/scilab/cmdref_gf_model_set.rst:1273
msgid ""
"``ind = gf_model_set(model M, 'add mass brick', mesh_im mim, string "
"varname[, string dataexpr_rho[, int region]])``"
msgstr ""

# 76df305bb892481eba424100ef5fa628
#: ../source/scilab/cmdref_gf_model_set.rst:1275
msgid ""
"Add mass term to the model relatively to the variable "
"<literal>varname</literal>. If specified, the data "
"<literal>dataexpr_rho</literal> is the density (1 if omitted). "
"<literal>region</literal> is an optional mesh region on which the term is"
" added. If it is not specified, it is added on the whole mesh. Return the"
" brick index in the model."
msgstr ""

# 056bed1b6a534522993e1019f924aa73
#: ../source/scilab/cmdref_gf_model_set.rst:1282
msgid "``gf_model_set(model M, 'shift variables for time integration')``"
msgstr ""

# 641402541697418a816443d146dd6807
#: ../source/scilab/cmdref_gf_model_set.rst:1284
msgid ""
"Function used to shift the variables of a model to the data corresponding"
" of ther value on the previous time step for time integration schemes. "
"For each variable for which a time integration scheme has been declared, "
"the scheme is called to perform the shift. This function has to be called"
" between two time steps."
msgstr ""

# a13bf0304aa344b0a715b9052308ea26
#: ../source/scilab/cmdref_gf_model_set.rst:1291
msgid "``gf_model_set(model M, 'perform init time derivative', scalar ddt)``"
msgstr ""

# 37ce80330c5b49e5b543a82a3828d72f
#: ../source/scilab/cmdref_gf_model_set.rst:1293
msgid ""
"By calling this function, indicates that the next solve will compute the "
"solution for a (very) small time step <literal>ddt</literal> in order to "
"initalize the data corresponding to the derivatives needed by time "
"integration schemes (mainly the initial time derivative for order one in "
"time problems  and the second order time derivative for second order in "
"time problems). The next solve will not change the value of the "
"variables."
msgstr ""

# 9cca4e6f04214f5489c2c2777c3376ca
#: ../source/scilab/cmdref_gf_model_set.rst:1301
msgid "``gf_model_set(model M, 'set time step', scalar dt)``"
msgstr ""

# fa1a54d101fb479f999f636a79776558
#: ../source/scilab/cmdref_gf_model_set.rst:1303
msgid ""
"Set the value of the time step to <literal>dt</literal>. This value can "
"be change from a step to another for all one-step schemes (i.e for the "
"moment to all proposed time integration schemes)."
msgstr ""

# ba1f0883af7f492f931a4360c1e82ddc
#: ../source/scilab/cmdref_gf_model_set.rst:1308
msgid "``gf_model_set(model M, 'set time', scalar t)``"
msgstr ""

# 5981389341fd4deb926808db043b0e8f
#: ../source/scilab/cmdref_gf_model_set.rst:1310
msgid ""
"Set the value of the data <literal>t</literal> corresponding to the "
"current time to <literal>t</literal>."
msgstr ""

# 28893500577c44a99af9d4ed0098b2c2
#: ../source/scilab/cmdref_gf_model_set.rst:1314
msgid ""
"``gf_model_set(model M, 'add theta method for first order', string "
"varname, scalar theta)``"
msgstr ""

# 10664b4697e44f9c87a2e3b98e8aed33
#: ../source/scilab/cmdref_gf_model_set.rst:1316
msgid ""
"Attach a theta method for the time discretization of the variable "
"<literal>varname</literal>. Valid only if there is at most first order "
"time derivative of the variable."
msgstr ""

# 0d5c218526c64831aa1bc6859ece5db3
#: ../source/scilab/cmdref_gf_model_set.rst:1321
msgid ""
"``gf_model_set(model M, 'add theta method for second order', string "
"varname, scalar theta)``"
msgstr ""

# 6941c0de39174ccaaf7cd8b1760638ba
# fef1827d0c2f466281f40330088aa50b
#: ../source/scilab/cmdref_gf_model_set.rst:1323
#: ../source/scilab/cmdref_gf_model_set.rst:1330
msgid ""
"Attach a theta method for the time discretization of the variable "
"<literal>varname</literal>. Valid only if there is at most second order "
"time derivative of the variable."
msgstr ""

# 409f633bfdeb4bce91df334d0976ca17
#: ../source/scilab/cmdref_gf_model_set.rst:1328
msgid ""
"``gf_model_set(model M, 'add Newmark scheme', string varname, scalar "
"beta, scalar gamma)``"
msgstr ""

# c653c5d68b6b43269bf7f29ef468ab18
#: ../source/scilab/cmdref_gf_model_set.rst:1335
msgid "``gf_model_set(model M, 'disable bricks', ivec bricks_indices)``"
msgstr ""

# 27d0f07e72174a358d705fc670aa38c0
#: ../source/scilab/cmdref_gf_model_set.rst:1337
msgid ""
"Disable a brick (the brick will no longer participate to the building of "
"the tangent linear system)."
msgstr ""

# 6c76eeb429a84255b8617bb8f01c7097
#: ../source/scilab/cmdref_gf_model_set.rst:1341
msgid "``gf_model_set(model M, 'enable bricks', ivec bricks_indices)``"
msgstr ""

# d009746f9e224382bf90f0afe0b1d7fb
#: ../source/scilab/cmdref_gf_model_set.rst:1343
msgid "Enable a disabled brick."
msgstr ""

# 3e917f15a1cb49f6a775924beca70271
#: ../source/scilab/cmdref_gf_model_set.rst:1346
msgid "``gf_model_set(model M, 'disable variable', string varname)``"
msgstr ""

# 95e46b7fc6224316852c7b48160e0364
#: ../source/scilab/cmdref_gf_model_set.rst:1348
msgid ""
"Disable a variable for a solve (and its attached multipliers). The next "
"solve will operate only on the remaining variables. This allows to solve "
"separately different parts of a model. If there is a strong coupling of "
"the variables, a fixed point strategy can the be used."
msgstr ""

# 3cc10f7ee737495ca3d5d59917433b3c
#: ../source/scilab/cmdref_gf_model_set.rst:1355
msgid "``gf_model_set(model M, 'enable variable', string varname)``"
msgstr ""

# 71fcbdb4373c490b8e41b742860a851b
#: ../source/scilab/cmdref_gf_model_set.rst:1357
msgid "Enable a disabled variable (and its attached multipliers)."
msgstr ""

# ba8756bb82f44c24a40bc0e5eb8c9956
#: ../source/scilab/cmdref_gf_model_set.rst:1360
msgid "``gf_model_set(model M, 'first iter')``"
msgstr ""

# 454ad0d5435d45278bfecc18bbaff9f0
#: ../source/scilab/cmdref_gf_model_set.rst:1362
msgid "To be executed before the first iteration of a time integration scheme."
msgstr ""

# 5b34a2c0931049c18eb64657bbc55292
#: ../source/scilab/cmdref_gf_model_set.rst:1366
msgid "``gf_model_set(model M, 'next iter')``"
msgstr ""

# d7d51aa7566d4772ab80dd18efd5b01f
#: ../source/scilab/cmdref_gf_model_set.rst:1368
msgid "To be executed at the end of each iteration of a time integration scheme."
msgstr ""

# 58b7919a431a4fe2bc6522a4f8401b25
#: ../source/scilab/cmdref_gf_model_set.rst:1372
msgid ""
"``ind = gf_model_set(model M, 'add basic contact brick', string "
"varname_u, string multname_n[, string multname_t], string dataname_r, "
"spmat BN[, spmat BT, string dataname_friction_coeff][, string "
"dataname_gap[, string dataname_alpha[, int augmented_version[, string "
"dataname_gamma, string dataname_wt]]])``"
msgstr ""

# ab28951a8d494f95b82ba4ad1a422a49
#: ../source/scilab/cmdref_gf_model_set.rst:1374
msgid ""
"Add a contact with or without friction brick to the model. If U is the "
"vector of degrees of freedom on which the unilateral constraint is "
"applied, the matrix <literal>BN</literal> have to be such that this "
"constraint is defined by <latex style=\"text\"><![CDATA[B_N U \\le "
"0]]></latex>. A friction condition can be considered by adding the three "
"parameters <literal>multname_t</literal>, <literal>BT</literal> and "
"<literal>dataname_friction_coeff</literal>. In this case, the tangential "
"displacement is <latex style=\"text\"><![CDATA[B_T U]]></latex> and the "
"matrix <literal>BT</literal> should have as many rows as "
"<literal>BN</literal> multiplied by <latex "
"style=\"text\"><![CDATA[d-1]]></latex> where <latex "
"style=\"text\"><![CDATA[d]]></latex> is the domain dimension. In this "
"case also, <literal>dataname_friction_coeff</literal> is a data which "
"represents the coefficient of friction. It can be a scalar or a vector "
"representing a value on each contact condition.  The unilateral "
"constraint is prescribed thank to a multiplier "
"<literal>multname_n</literal> whose dimension should be equal to the "
"number of rows of <literal>BN</literal>. If a friction condition is "
"added, it is prescribed with a multiplier <literal>multname_t</literal> "
"whose dimension should be equal to the number of rows of "
"<literal>BT</literal>. The augmentation parameter <literal>r</literal> "
"should be chosen in a range of acceptabe values (see Getfem user "
"documentation). <literal>dataname_gap</literal> is an optional parameter "
"representing the initial gap. It can be a single value or a vector of "
"value. <literal>dataname_alpha</literal> is an optional homogenization "
"parameter for the augmentation parameter (see Getfem user documentation)."
"  The parameter <literal>augmented_version</literal> indicates the "
"augmentation strategy : 1 for the non-symmetric Alart-Curnier augmented "
"Lagrangian, 2 for the symmetric one (except for the coupling between "
"contact and Coulomb friction), 3 for the unsymmetric method with "
"augmented multipliers, 4 for the unsymmetric method with augmented "
"multipliers and De Saxce projection."
msgstr ""

# 614587c780e243419086f9a9f779a809
#: ../source/scilab/cmdref_gf_model_set.rst:1404
msgid ""
"``ind = gf_model_set(model M, 'add basic contact brick two deformable "
"bodies', string varname_u1, string varname_u2, string multname_n, string "
"dataname_r, spmat BN1, spmat BN2[, string dataname_gap[, string "
"dataname_alpha[, int augmented_version]]])``"
msgstr ""

# f3bd5c793803405c9bac348baa761ef2
#: ../source/scilab/cmdref_gf_model_set.rst:1423
msgid "Add a frictionless contact condition to the model between two deformable"
msgstr ""

# 8a9004580ff148b8bd88f2488ecc2a7a
#: ../source/scilab/cmdref_gf_model_set.rst:1407
msgid ""
"bodies. If U1, U2 are the vector of degrees of freedom on which the "
"unilateral constraint is applied, the matrices <literal>BN1</literal> and"
" <literal>BN2</literal> have to be such that this condition is defined by"
" $B_{N1} U_1 B_{N2} U_2 + \\le gap$. The constraint is prescribed thank "
"to a multiplier <literal>multname_n</literal> whose dimension should be "
"equal to the number of lines of <literal>BN</literal>. The augmentation "
"parameter <literal>r</literal> should be chosen in a range of acceptabe "
"values (see Getfem user documentation). <literal>dataname_gap</literal> "
"is an optional parameter representing the initial gap. It can be a single"
" value or a vector of value. <literal>dataname_alpha</literal> is an "
"optional homogenization parameter for the augmentation parameter (see "
"Getfem user documentation). The parameter <literal>aug_version</literal> "
"indicates the augmentation strategy : 1 for the non-symmetric Alart-"
"Curnier augmented Lagrangian, 2 for the symmetric one, 3 for the "
"unsymmetric method with augmented multiplier."
msgstr ""

# c057ecb11a16451a853a950746b5b1ea
#: ../source/scilab/cmdref_gf_model_set.rst:1425
msgid "``gf_model_set(model M, 'contact brick set BN', int indbrick, spmat BN)``"
msgstr ""

# fcba7b3e3b414ebeba3d60551ecfb039
#: ../source/scilab/cmdref_gf_model_set.rst:1427
msgid "Can be used to set the BN matrix of a basic contact/friction brick."
msgstr ""

# c535071855144138b0fa454ec4180ddb
#: ../source/scilab/cmdref_gf_model_set.rst:1430
msgid "``gf_model_set(model M, 'contact brick set BT', int indbrick, spmat BT)``"
msgstr ""

# 0f3292d6be41487ba46ca41c51112057
#: ../source/scilab/cmdref_gf_model_set.rst:1432
msgid "Can be used to set the BT matrix of a basic contact with friction brick."
msgstr ""

# fb9ef629957648beb996ddc112932d59
#: ../source/scilab/cmdref_gf_model_set.rst:1436
msgid ""
"``ind = gf_model_set(model M, 'add nodal contact with rigid obstacle "
"brick',  mesh_im mim, string varname_u, string multname_n[, string "
"multname_t], string dataname_r[, string dataname_friction_coeff], int "
"region, string obstacle[,  int augmented_version])``"
msgstr ""

# e55c33e9af944e10a163f7b6c784a7b5
#: ../source/scilab/cmdref_gf_model_set.rst:1438
msgid ""
"Add a contact with or without friction condition with a rigid obstacle to"
" the model. The condition is applied on the variable "
"<literal>varname_u</literal> on the boundary corresponding to "
"<literal>region</literal>. The rigid obstacle should be described with "
"the string <literal>obstacle</literal> being a signed distance to the "
"obstacle. This string should be an expression where the coordinates are "
"'x', 'y' in 2D and 'x', 'y', 'z' in 3D. For instance, if the rigid "
"obstacle correspond to <latex style=\"text\"><![CDATA[z \\le "
"0]]></latex>, the corresponding signed distance will be simply \"z\". "
"<literal>multname_n</literal> should be a fixed size variable whose size "
"is the number of degrees of freedom on boundary "
"<literal>region</literal>. It represents the contact equivalent nodal "
"forces. In order to add a friction condition one has to add the "
"<literal>multname_t</literal> and "
"<literal>dataname_friction_coeff</literal> parameters. "
"<literal>multname_t</literal> should be a fixed size variable whose size "
"is the number of degrees of freedom on boundary <literal>region</literal>"
" multiplied by <latex style=\"text\"><![CDATA[d-1]]></latex> where <latex"
" style=\"text\"><![CDATA[d]]></latex> is the domain dimension. It "
"represents the friction equivalent nodal forces. The augmentation "
"parameter <literal>r</literal> should be chosen in a range of acceptabe "
"values (close to the Young modulus of the elastic body, see Getfem user "
"documentation).  <literal>dataname_friction_coeff</literal> is the "
"friction coefficient. It could be a scalar or a vector of values "
"representing the friction coefficient on each contact node. The parameter"
" <literal>augmented_version</literal> indicates the augmentation strategy"
" : 1 for the non-symmetric Alart-Curnier augmented Lagrangian, 2 for the "
"symmetric one (except for the coupling between contact and Coulomb "
"friction), 3 for the new unsymmetric method. Basically, this brick "
"compute the matrix BN and the vectors gap and alpha and calls the basic "
"contact brick."
msgstr ""

# 3b453a9855e1416a87c9730344ae49f7
#: ../source/scilab/cmdref_gf_model_set.rst:1467
msgid ""
"``ind = gf_model_set(model M, 'add contact with rigid obstacle brick',  "
"mesh_im mim, string varname_u, string multname_n[, string multname_t], "
"string dataname_r[, string dataname_friction_coeff], int region, string "
"obstacle[,  int augmented_version])``"
msgstr ""

# 69741ada747048aab0805dd9cfd5a1fa
#: ../source/scilab/cmdref_gf_model_set.rst:1469
msgid ""
"DEPRECATED FUNCTION. Use 'add nodal contact with rigid obstacle brick' "
"instead."
msgstr ""

# 13d047fc84e14ab39b7b1139e3e4649d
#: ../source/scilab/cmdref_gf_model_set.rst:1472
msgid ""
"``ind = gf_model_set(model M, 'add integral contact with rigid obstacle "
"brick',  mesh_im mim, string varname_u, string multname, string "
"dataname_obstacle, string dataname_r [, string dataname_friction_coeff], "
"int region [, int option [, string dataname_alpha [, string dataname_wt "
"[, string dataname_gamma [, string dataname_vt]]]]])``"
msgstr ""

# 2c3e6b7d2bea411a9529b23b5f8bfe52
#: ../source/scilab/cmdref_gf_model_set.rst:1474
msgid ""
"Add a contact with or without friction condition with a rigid obstacle to"
" the model. This brick adds a contact which is defined in an integral "
"way. It is the direct approximation of an augmented Lagrangian "
"formulation (see Getfem user documentation) defined at the continuous "
"level. The advantage is a better scalability: the number of Newton "
"iterations should be more or less independent of the mesh size. The "
"contact condition is applied on the variable <literal>varname_u</literal>"
" on the boundary corresponding to <literal>region</literal>. The rigid "
"obstacle should be described with the data "
"<literal>dataname_obstacle</literal> being a signed distance to the "
"obstacle (interpolated on a finite element method). "
"<literal>multname</literal> should be a fem variable representing the "
"contact stress. An inf-sup condition beetween <literal>multname</literal>"
" and <literal>varname_u</literal> is required. The augmentation parameter"
" <literal>dataname_r</literal> should be chosen in a range of acceptabe "
"values. The optional parameter <literal>dataname_friction_coeff</literal>"
" is the friction coefficient which could be constant or defined on a "
"finite element method. Possible values for <literal>option</literal> is 1"
" for the non-symmetric Alart-Curnier augmented Lagrangian method, 2 for "
"the symmetric one, 3 for the non-symmetric Alart-Curnier method with an "
"additional augmentation and 4 for a new unsymmetric method. The default "
"value is 1. In case of contact with friction, "
"<literal>dataname_alpha</literal> and <literal>dataname_wt</literal> are "
"optional parameters to solve evolutionary friction problems. "
"<literal>dataname_gamma</literal> and <literal>dataname_vt</literal> "
"represent optional data for adding a parameter-dependent sliding velocity"
" to the friction condition."
msgstr ""

# d990d7931eaf4728982e5d86f92932df
#: ../source/scilab/cmdref_gf_model_set.rst:1501
msgid ""
"``ind = gf_model_set(model M, 'add penalized contact with rigid obstacle "
"brick',  mesh_im mim, string varname_u, string dataname_obstacle, string "
"dataname_r [, string dataname_coeff], int region [, int option, string "
"dataname_lambda, [, string dataname_alpha [, string dataname_wt]]])``"
msgstr ""

# ab049ec1bdba48609d1271e21e2325d5
#: ../source/scilab/cmdref_gf_model_set.rst:1503
msgid ""
"Add a penalized contact with or without friction condition with a rigid "
"obstacle to the model. The condition is applied on the variable "
"<literal>varname_u</literal> on the boundary corresponding to "
"<literal>region</literal>. The rigid obstacle should be described with "
"the data <literal>dataname_obstacle</literal> being a signed distance to "
"the obstacle (interpolated on a finite element method). The penalization "
"parameter <literal>dataname_r</literal> should be chosen large enough to "
"prescribe approximate non-penetration and friction conditions but not too"
" large not to deteriorate too much the conditionning of the tangent "
"system. <literal>dataname_lambda</literal> is an optional parameter used "
"if option is 2. In that case, the penalization term is shifted by lambda "
"(this allows the use of an Uzawa algorithm on the corresponding augmented"
" Lagrangian formulation)"
msgstr ""

# 00893a9eed364eab9b0d216672902b7b
#: ../source/scilab/cmdref_gf_model_set.rst:1520
msgid ""
"``ind = gf_model_set(model M, 'add Nitsche contact with rigid obstacle "
"brick', mesh_im mim, string varname, string Neumannterm, string "
"dataname_obstacle, string gamma0name,  int region[, scalar theta[, string"
" dataname_friction_coeff[, string dataname_alpha, string "
"dataname_wt]]])``"
msgstr ""

# 11032c09713842b7a293a2cc4e2a19c7
#: ../source/scilab/cmdref_gf_model_set.rst:1522
msgid ""
"Adds a contact condition with or without Coulomb friction on the variable"
" <literal>varname</literal> and the mesh boundary "
"<literal>region</literal>. The contact condition is prescribed with "
"Nitsche's method. The rigid obstacle should be described with the data "
"<literal>dataname_obstacle</literal> being a signed distance to the "
"obstacle (interpolated on a finite element method). "
"<literal>gamma0name</literal> is the Nitsche's method parameter. "
"<literal>theta</literal> is a scalar value which can be positive or "
"negative. <literal>theta = 1</literal> corresponds to the standard "
"symmetric method which is conditionnaly coercive for  "
"<literal>gamma0</literal> small. <literal>theta = -1</literal> "
"corresponds to the skew-symmetric method which is inconditionnaly "
"coercive. <literal>theta = 0</literal> is the simplest method for which "
"the second derivative of the Neumann term is not necessary. The optional "
"parameter <literal>dataname_friction_coeff</literal> is the friction "
"coefficient which could be constant or defined on a finite element "
"method. CAUTION: This brick has to be added in the model after all the "
"bricks corresponding to partial differential terms having a Neumann term."
" Moreover, This brick can only be applied to bricks declaring their "
"Neumann terms. Returns the brick index in the model."
msgstr ""

# d042e0df0c404680a6e9257d65c5d910
#: ../source/scilab/cmdref_gf_model_set.rst:1544
msgid ""
"``ind = gf_model_set(model M, 'add Nitsche midpoint contact with rigid "
"obstacle brick', mesh_im mim, string varname, string Neumannterm, string "
"Neumannterm_wt, string dataname_obstacle, string gamma0name,  int region,"
" scalar theta, string dataname_friction_coeff, string dataname_alpha, "
"string dataname_wt)``"
msgstr ""

# 806a98c88da04066a667d9b578f70ac2
#: ../source/scilab/cmdref_gf_model_set.rst:1546
msgid ""
"EXPERIMENTAL BRICK: for midpoint scheme only !! Adds a contact condition "
"with or without Coulomb friction on the variable "
"<literal>varname</literal> and the mesh boundary "
"<literal>region</literal>. The contact condition is prescribed with "
"Nitsche's method. The rigid obstacle should be described with the data "
"<literal>dataname_obstacle</literal> being a signed distance to the "
"obstacle (interpolated on a finite element method). "
"<literal>gamma0name</literal> is the Nitsche's method parameter. "
"<literal>theta</literal> is a scalar value which can be positive or "
"negative. <literal>theta = 1</literal> corresponds to the standard "
"symmetric method which is conditionnaly coercive for  "
"<literal>gamma0</literal> small. <literal>theta = -1</literal> "
"corresponds to the skew-symmetric method which is inconditionnaly "
"coercive. <literal>theta = 0</literal> is the simplest method for which "
"the second derivative of the Neumann term is not necessary. The optional "
"parameter <literal>dataname_friction_coeff</literal> is the friction "
"coefficient which could be constant or defined on a finite element "
"method. Returns the brick index in the model."
msgstr ""

# 60e6f3015c8b4631ab0265023f980fc4
#: ../source/scilab/cmdref_gf_model_set.rst:1567
msgid ""
"``ind = gf_model_set(model M, 'add Nitsche fictitious domain contact "
"brick', mesh_im mim, string varname1, string varname2, string "
"dataname_d1, string dataname_d2, string gamma0name [, scalar theta[, "
"string dataname_friction_coeff[, string dataname_alpha, string "
"dataname_wt1,string dataname_wt2]]])``"
msgstr ""

# cc63e18ddae141ad82550ff7a35f9094
#: ../source/scilab/cmdref_gf_model_set.rst:1569
msgid ""
"Adds a contact condition with or without Coulomb friction between two "
"bodies in a fictitious domain. The contact condition is applied on the "
"variable <literal>varname_u1</literal> corresponds with the first and "
"slave body with Nitsche's method and on the variable "
"<literal>varname_u2</literal> corresponds with the second and master body"
" with Nitsche's method. The contact condition is evaluated on the "
"fictitious slave boundary. The first body should be described by the "
"level-set <literal>dataname_d1</literal> and the second body should be "
"described by the level-set <literal>dataname_d2</literal>. "
"<literal>gamma0name</literal> is the Nitsche's method parameter. "
"<literal>theta</literal> is a scalar value which can be positive or "
"negative. <literal>theta = 1</literal> corresponds to the standard "
"symmetric method which is conditionnaly coercive for  "
"<literal>gamma0</literal> small. <literal>theta = -1</literal> "
"corresponds to the skew-symmetric method which is inconditionnaly "
"coercive. <literal>theta = 0</literal> is the simplest method for which "
"the second derivative of the Neumann term is not necessary. The optional "
"parameter <literal>dataname_friction_coeff</literal> is the friction "
"coefficient which could be constant or defined on a finite element "
"method. CAUTION: This brick has to be added in the model after all the "
"bricks corresponding to partial differential terms having a Neumann term."
" Moreover, This brick can only be applied to bricks declaring their "
"Neumann terms. Returns the brick index in the model."
msgstr ""

# def0ad9b132b47edad8f0980e467c616
#: ../source/scilab/cmdref_gf_model_set.rst:1592
msgid ""
"``ind = gf_model_set(model M, 'add nodal contact between nonmatching "
"meshes brick',  mesh_im mim1[, mesh_im mim2], string varname_u1[, string "
"varname_u2], string multname_n[, string multname_t], string dataname_r[, "
"string dataname_fr], int rg1, int rg2[, int slave1, int slave2,  int "
"augmented_version])``"
msgstr ""

# c598488aff964cb5b0eeee8a9fbefda2
#: ../source/scilab/cmdref_gf_model_set.rst:1594
msgid ""
"Add a contact with or without friction condition between two faces of one"
" or two elastic bodies. The condition is applied on the variable "
"<literal>varname_u1</literal> or the variables "
"<literal>varname_u1</literal> and <literal>varname_u2</literal> depending"
" if a single or two distinct displacement fields are given. Integers "
"<literal>rg1</literal> and <literal>rg2</literal> represent the regions "
"expected to come in contact with each other. In the single displacement "
"variable case the regions defined in both <literal>rg1</literal> and "
"<literal>rg2</literal> refer to the variable "
"<literal>varname_u1</literal>. In the case of two displacement variables,"
" <literal>rg1</literal> refers to <literal>varname_u1</literal> and "
"<literal>rg2</literal> refers to <literal>varname_u2</literal>. "
"<literal>multname_n</literal> should be a fixed size variable whose size "
"is the number of degrees of freedom on those regions among the ones "
"defined in <literal>rg1</literal> and <literal>rg2</literal> which are "
"characterized as \"slaves\". It represents the contact equivalent nodal "
"normal forces. <literal>multname_t</literal> should be a fixed size "
"variable whose size corresponds to the size of "
"<literal>multname_n</literal> multiplied by qdim - 1 . It represents the "
"contact equivalent nodal tangent (frictional) forces. The augmentation "
"parameter <literal>r</literal> should be chosen in a range of acceptabe "
"values (close to the Young modulus of the elastic body, see Getfem user "
"documentation). The friction coefficient stored in the parameter "
"<literal>fr</literal> is either a single value or a vector of the same "
"size as <literal>multname_n</literal>. The optional parameters "
"<literal>slave1</literal> and <literal>slave2</literal> declare if the "
"regions defined in <literal>rg1</literal> and <literal>rg2</literal> are "
"correspondingly considered as \"slaves\". By default "
"<literal>slave1</literal> is true and <literal>slave2</literal> is false,"
" i.e. <literal>rg1</literal> contains the slave surfaces, while 'rg2' the"
" master surfaces. Preferrably only one of <literal>slave1</literal> and "
"<literal>slave2</literal> is set to true.  The parameter "
"<literal>augmented_version</literal> indicates the augmentation strategy "
": 1 for the non-symmetric Alart-Curnier augmented Lagrangian, 2 for the "
"symmetric one (except for the coupling between contact and Coulomb "
"friction), 3 for the new unsymmetric method. Basically, this brick "
"computes the matrices BN and BT and the vectors gap and alpha and calls "
"the basic contact brick."
msgstr ""

# a20259e521124f24849c82daa5d628f9
#: ../source/scilab/cmdref_gf_model_set.rst:1626
msgid ""
"``ind = gf_model_set(model M, 'add nonmatching meshes contact brick',  "
"mesh_im mim1[, mesh_im mim2], string varname_u1[, string varname_u2], "
"string multname_n[, string multname_t], string dataname_r[, string "
"dataname_fr], int rg1, int rg2[, int slave1, int slave2,  int "
"augmented_version])``"
msgstr ""

# 0d187b23535f465fa6ea5e258724769e
#: ../source/scilab/cmdref_gf_model_set.rst:1628
msgid ""
"DEPRECATED FUNCTION. Use 'add nodal contact between nonmatching meshes "
"brick' instead."
msgstr ""

# 4c3bc2a04d844d998d592dfc2ff9dda7
#: ../source/scilab/cmdref_gf_model_set.rst:1631
msgid ""
"``ind = gf_model_set(model M, 'add integral contact between nonmatching "
"meshes brick',  mesh_im mim, string varname_u1, string varname_u2, string"
" multname, string dataname_r [, string dataname_friction_coeff], int "
"region1, int region2 [, int option [, string dataname_alpha [, string "
"dataname_wt1 , string dataname_wt2]]])``"
msgstr ""

# 930f7e0e1e9649fb8562fa78ab06838f
#: ../source/scilab/cmdref_gf_model_set.rst:1633
msgid ""
"Add a contact with or without friction condition between nonmatching "
"meshes to the model. This brick adds a contact which is defined in an "
"integral way. It is the direct approximation of an augmented agrangian "
"formulation (see Getfem user documentation) defined at the continuous "
"level. The advantage should be a better scalability: the number of Newton"
" iterations should be more or less independent of the mesh size. The "
"condition is applied on the variables <literal>varname_u1</literal> and "
"<literal>varname_u2</literal> on the boundaries corresponding to "
"<literal>region1</literal> and <literal>region2</literal>. "
"<literal>multname</literal> should be a fem variable representing the "
"contact stress for the frictionless case and the contact and friction "
"stress for the case with friction. An inf-sup condition between "
"<literal>multname</literal> and <literal>varname_u1</literal> and "
"<literal>varname_u2</literal> is required. The augmentation parameter "
"<literal>dataname_r</literal> should be chosen in a range of acceptable "
"values. The optional parameter <literal>dataname_friction_coeff</literal>"
" is the friction coefficient which could be constant or defined on a "
"finite element method on the same mesh as <literal>varname_u1</literal>. "
"Possible values for <literal>option</literal> is 1 for the non-symmetric "
"Alart-Curnier augmented Lagrangian method, 2 for the symmetric one, 3 for"
" the non-symmetric Alart-Curnier method with an additional augmentation "
"and 4 for a new unsymmetric method. The default value is 1. In case of "
"contact with friction, <literal>dataname_alpha</literal>, "
"<literal>dataname_wt1</literal> and <literal>dataname_wt2</literal> are "
"optional parameters to solve evolutionary friction problems."
msgstr ""

# 942dcd89219f46a299ca49fc5c4608e9
#: ../source/scilab/cmdref_gf_model_set.rst:1661
msgid ""
"``ind = gf_model_set(model M, 'add penalized contact between nonmatching "
"meshes brick',  mesh_im mim, string varname_u1, string varname_u2, string"
" dataname_r [, string dataname_coeff], int region1, int region2 [, int "
"option [, string dataname_lambda, [, string dataname_alpha [, string "
"dataname_wt1, string dataname_wt2]]]])``"
msgstr ""

# 2ab5d8e3cba5454dbbb888f771ad3cac
#: ../source/scilab/cmdref_gf_model_set.rst:1663
msgid ""
"Add a penalized contact condition with or without friction between "
"nonmatching meshes to the model. The condition is applied on the "
"variables <literal>varname_u1</literal> and  "
"<literal>varname_u2</literal> on the boundaries corresponding to "
"<literal>region1</literal> and <literal>region2</literal>. The "
"penalization parameter <literal>dataname_r</literal> should be chosen "
"large enough to prescribe approximate non-penetration and friction "
"conditions but not too large not to deteriorate too much the "
"conditionning of the tangent system. The optional parameter "
"<literal>dataname_friction_coeff</literal> is the friction coefficient "
"which could be constant or defined on a finite element method on the same"
" mesh as <literal>varname_u1</literal>. "
"<literal>dataname_lambda</literal> is an optional parameter used if "
"option is 2. In that case, the penalization term is shifted by lambda "
"(this allows the use of an Uzawa algorithm on the corresponding augmented"
" Lagrangian formulation) In case of contact with friction, "
"<literal>dataname_alpha</literal>, <literal>dataname_wt1</literal> and "
"<literal>dataname_wt2</literal> are optional parameters to solve "
"evolutionary friction problems."
msgstr ""

# 41caa164c44a443dbd41e1709b01c2fc
#: ../source/scilab/cmdref_gf_model_set.rst:1684
msgid ""
"``ind = gf_model_set(model M, 'add integral large sliding contact brick "
"raytracing', string dataname_r, scalar release_distance, [, string "
"dataname_fr[, string dataname_alpha[, int version]]])``"
msgstr ""

# 64d5c5a3d67c48e49f90c403da918c41
#: ../source/scilab/cmdref_gf_model_set.rst:1686
msgid ""
"Adds a large sliding contact with friction brick to the model. This brick"
" is able to deal with self-contact, contact between several deformable "
"bodies and contact with rigid obstacles. It uses the high-level generic "
"assembly. It adds to the model a raytracing_interpolate_transformation "
"object. For each slave boundary a multiplier variable should be defined. "
"The release distance should be determined with care (generally a few "
"times a mean element size, and less than the thickness of the body). "
"Initially, the brick is added with no contact boundaries. The contact "
"boundaries and rigid bodies are added with special functions. "
"<literal>version</literal> is 0 (the default value) for the non-symmetric"
" version and 1 for the more symmetric one (not fully symmetric even "
"without friction)."
msgstr ""

# 028d6afd123745c49a7e50214711859b
#: ../source/scilab/cmdref_gf_model_set.rst:1701
msgid ""
"``gf_model_set(model M, 'add rigid obstacle to large sliding contact "
"brick', int indbrick, string expr, int N)``"
msgstr ""

# 117f47df8b3b4a0cb62addf8a39a965b
# f2687b987e6947ddbdb289137c4ff680
#: ../source/scilab/cmdref_gf_model_set.rst:1703
#: ../source/scilab/cmdref_gf_model_set.rst:1749
msgid ""
"Adds a rigid obstacle to an existing large sliding contact with friction "
"brick. <literal>expr</literal> is an expression using the high-level "
"generic assembly language (where <literal>x</literal> is the current "
"point n the mesh) which should be a signed distance to the obstacle. "
"<literal>N</literal> is the mesh dimension."
msgstr ""

# 9c11c93e2eb34cb3a934fd306cc18299
#: ../source/scilab/cmdref_gf_model_set.rst:1710
msgid ""
"``gf_model_set(model M, 'add master contact boundary to large sliding "
"contact brick', int indbrick, mesh_im mim, int region, string dispname[, "
"string wname])``"
msgstr ""

# cc3741f797fe4309ab0f770d72f2bfac
#: ../source/scilab/cmdref_gf_model_set.rst:1712
msgid ""
"Adds a master contact boundary to an existing large sliding contact with "
"friction brick."
msgstr ""

# e3b77580a03043a9a7c249b5b64902ca
#: ../source/scilab/cmdref_gf_model_set.rst:1716
msgid ""
"``gf_model_set(model M, 'add slave contact boundary to large sliding "
"contact brick', int indbrick, mesh_im mim, int region, string dispname, "
"string lambdaname[, string wname])``"
msgstr ""

# 4c2b0ba1e94f4244a3040eab997450f1
#: ../source/scilab/cmdref_gf_model_set.rst:1718
msgid ""
"Adds a slave contact boundary to an existing large sliding contact with "
"friction brick."
msgstr ""

# d08655c8fc39432290d4970c9b2f8787
#: ../source/scilab/cmdref_gf_model_set.rst:1722
msgid ""
"``gf_model_set(model M, 'add master slave contact boundary to large "
"sliding contact brick', int indbrick, mesh_im mim, int region, string "
"dispname, string lambdaname[, string wname])``"
msgstr ""

# 6f7416ff254f4d238f49fc20ff75128e
#: ../source/scilab/cmdref_gf_model_set.rst:1724
msgid ""
"Adds a contact boundary to an existing large sliding contact with "
"friction brick which is both master and slave (allowing the self-"
"contact)."
msgstr ""

# f5be84c5de094655aeadc36d2827401c
#: ../source/scilab/cmdref_gf_model_set.rst:1729
msgid ""
"``ind = gf_model_set(model M, 'add Nitsche large sliding contact brick "
"raytracing', bool unbiased_version, string dataname_r, scalar "
"release_distance[, string dataname_fr[, string dataname_alpha[, int "
"version]]])``"
msgstr ""

# 0329c58f918b422eaf5569a66b9a2fbe
#: ../source/scilab/cmdref_gf_model_set.rst:1731
msgid ""
"Adds a large sliding contact with friction brick to the model based on "
"the Nitsche's method. This brick is able to deal with self-contact, "
"contact between several deformable bodies and contact with rigid "
"obstacles. It uses the high-level generic assembly. It adds to the model "
"a raytracing_interpolate_transformation object. \"unbiased_version\" "
"refers to the version of Nische's method to be used. (unbiased or biased "
"one). For each slave boundary a  material law should be defined as a "
"function of the dispacement variable on this boundary. The release "
"distance should be determined with care (generally a few times a mean "
"element size, and less than the thickness of the body). Initially, the "
"brick is added with no contact boundaries. The contact boundaries and "
"rigid bodies are added with special functions. <literal>version</literal>"
" is 0 (the default value) for the non-symmetric version and 1 for the "
"more symmetric one (not fully symmetric even without friction)."
msgstr ""

# a55ee92d8b284cf486ac4b163379aac4
#: ../source/scilab/cmdref_gf_model_set.rst:1747
msgid ""
"``gf_model_set(model M, 'add rigid obstacle to Nitsche large sliding "
"contact brick', int indbrick, string expr, int N)``"
msgstr ""

# 700f95534943409c8c6e6fea938d63b3
#: ../source/scilab/cmdref_gf_model_set.rst:1756
msgid ""
"``gf_model_set(model M, 'add master contact boundary to biased Nitsche "
"large sliding contact brick', int indbrick, mesh_im mim, int region, "
"string dispname[, string wname])``"
msgstr ""

# b685e72dd4bb415a83159d9255a7c331
#: ../source/scilab/cmdref_gf_model_set.rst:1758
msgid ""
"Adds a master contact boundary to an existing biased Nitsche's large "
"sliding contact with friction brick."
msgstr ""

# c5d7c34312294390a42931a9c3d4f143
#: ../source/scilab/cmdref_gf_model_set.rst:1762
msgid ""
"``gf_model_set(model M, 'add slave contact boundary to biased Nitsche "
"large sliding contact brick', int indbrick, mesh_im mim, int region, "
"string dispname, string lambdaname[, string wname])``"
msgstr ""

# e3b884a87c824c77b3384e193bdcfcc1
#: ../source/scilab/cmdref_gf_model_set.rst:1764
msgid ""
"Adds a slave contact boundary to an existing biased Nitsche's large "
"sliding contact with friction brick."
msgstr ""

# c783c303535e4b84bf1118da50997762
#: ../source/scilab/cmdref_gf_model_set.rst:1768
msgid ""
"``gf_model_set(model M, 'add contact boundary to unbiased Nitsche large "
"sliding contact brick', int indbrick, mesh_im mim, int region, string "
"dispname, string lambdaname[, string wname])``"
msgstr ""

# eb82b03263c641ee9cea9a638c080df5
#: ../source/scilab/cmdref_gf_model_set.rst:1770
msgid ""
"Adds a contact boundary to an existing unbiased Nitschelarge sliding "
"contact with friction brick which is both master and slave."
msgstr ""

